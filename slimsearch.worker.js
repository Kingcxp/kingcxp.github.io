[...new Array(6)].map((e,t)=>`[vp-content] h${t+1}`).join(",");const{entries:$}=Object,{fromEntries:st}=Object,nt="ENTRIES",D="KEYS",W="VALUES",_="";class F{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=b(this._path);if(b(s)===_)return{done:!1,value:this.result()};const n=t.get(b(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=b(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>b(t)).filter(t=>t!==_).join("")}value(){return b(this._path).node.get(_)}result(){switch(this._type){case W:return this.value();case D:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const b=e=>e[e.length-1],ot=(e,t,s)=>{const n=new Map;if(typeof t!="string")return n;const o=t.length+1,r=o+s,i=new Uint8Array(r*o).fill(s+1);for(let c=0;c<o;++c)i[c]=c;for(let c=1;c<r;++c)i[c*o]=c;return q(e,t,s,n,i,1,o,""),n},q=(e,t,s,n,o,r,i,c)=>{const h=r*i;t:for(const u of e.keys())if(u===_){const d=o[h-1];d<=s&&n.set(c,[e.get(u),d])}else{let d=r;for(let a=0;a<u.length;++a,++d){const m=u[a],g=i*d,y=g-i;let l=o[g];const f=Math.max(0,d-s-1),w=Math.min(i-1,d+s);for(let p=f;p<w;++p){const C=m!==t[p],S=o[y+p]+ +C,I=o[y+p+1]+1,x=o[g+p]+1,k=o[g+p+1]=Math.min(S,I,x);k<l&&(l=k)}if(l>s)continue t}q(e.get(u),t,s,n,o,d,i,c+u)}};class z{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=M(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,r]=L(n);for(const i of o.keys())if(i!==_&&i.startsWith(r)){const c=new Map;return c.set(i.slice(r.length),o.get(i)),new z(c,t)}}return new z(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,rt(this._tree,t)}entries(){return new F(this,nt)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return ot(this._tree,t,s)}get(t){const s=v(this._tree,t);return s!==void 0?s.get(_):void 0}has(t){return v(this._tree,t)?.has(_)??!1}keys(){return new F(this,D)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,E(this._tree,t).set(_,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=E(this._tree,t);return n.set(_,s(n.get(_))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=E(this._tree,t);let o=n.get(_);return o===void 0&&n.set(_,o=s()),o}values(){return new F(this,W)}[Symbol.iterator](){return this.entries()}static from(t){const s=new z;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return z.from(Object.entries(t))}}const M=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==_&&t.startsWith(n))return s.push([e,n]),M(e.get(n),t.slice(n.length),s);return s.push([e,t]),M(void 0,"",s)},v=(e,t)=>{if(t.length===0||!e)return e;for(const s of e.keys())if(s!==_&&t.startsWith(s))return v(e.get(s),t.slice(s.length))},E=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const r of e.keys())if(r!==_&&t[n]===r[0]){const i=Math.min(s-n,r.length);let c=1;for(;c<i&&t[n+c]===r[c];)++c;const h=e.get(r);if(c===r.length)e=h;else{const u=new Map;u.set(r.slice(c),h),e.set(t.slice(n,n+c),u),e.delete(r),e=u}n+=c;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},rt=(e,t)=>{const[s,n]=M(e,t);if(s!==void 0){if(s.delete(_),s.size===0)A(n);else if(s.size===1){const[o,r]=s.entries().next().value;R(n,o,r)}}},A=e=>{if(e.length===0)return;const[t,s]=L(e);if(t.delete(s),t.size===0)A(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==_&&R(e.slice(0,-1),n,o)}},R=(e,t,s)=>{if(e.length===0)return;const[n,o]=L(e);n.set(o+t,s),n.delete(o)},L=e=>e[e.length-1],it=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},ct=/[\n\r\p{Z}\p{P}]+/u,j="or",N="and",ut="and_not",dt=(e,t)=>{e.includes(t)||e.push(t)},B=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},P=({score:e},{score:t})=>t-e,ht=()=>new Map,O=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},G=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,H={[j]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:r,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),B(n.terms,r)}}return e},[N]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:r,terms:i,match:c}=t.get(n);B(o.terms,i),s.set(n,{score:o.score+r,terms:o.terms,match:Object.assign(o.match,c)})}return s},[ut]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},lt=(e,t,s,n,o,r)=>{const{k:i,b:c,d:h}=r;return Math.log(1+(s-t+.5)/(t+.5))*(h+e*(i+1)/(e+i*(1-c+c*n/o)))},ft=e=>(t,s,n)=>({term:t,fuzzy:typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy??!1,prefix:typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0,termBoost:typeof e.boostTerm=="function"?e.boostTerm(t,s,n):1}),J=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},at=(e,t,s,n)=>{if(!e._index.has(n)){J(e,s,t,n);return}const o=e._index.fetch(n,ht),r=o.get(t),i=r?.get(s);!r||typeof i>"u"?J(e,s,t,n):i<=1?r.size<=1?o.delete(t):r.delete(s):r.set(s,i-1),e._index.get(n).size===0&&e._index.delete(n)},mt={k:1.2,b:.7,d:.5},gt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(ct),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{console?.[e]?.(t)},autoVacuum:!0},Y={combineWith:j,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:mt},pt={combineWith:N,prefix:(e,t,s)=>t===s.length-1},_t={batchSize:1e3,batchWait:10},K={minDirtFactor:.1,minDirtCount:20},yt={..._t,...K},U=Symbol("*"),wt=(e,t)=>{const s=new Map,n={...e._options.searchOptions,...t};for(const[o,r]of e._documentIds){const i=n.boostDocument?n.boostDocument(r,"",e._storedFields.get(o)):1;s.set(o,{score:i,terms:[],match:{}})}return s},Q=(e,t=j)=>{if(e.length===0)return new Map;const s=t.toLowerCase();if(!(s in H))throw new Error(`Invalid combination operator: ${t}`);return e.reduce(H[s])},T=(e,t,s,n,o,r,i,c,h,u=new Map)=>{if(r==null)return u;for(const d of Object.keys(i)){const a=i[d],m=e._fieldIds[d],g=r.get(m);if(g==null)continue;let y=g.size;const l=e._avgFieldLength[m];for(const f of g.keys()){if(!e._documentIds.has(f)){at(e,m,f,s),y-=1;continue}const w=c?c(e._documentIds.get(f),s,e._storedFields.get(f)):1;if(!w)continue;const p=g.get(f),C=e._fieldLength.get(f)[m],S=lt(p,y,e._documentCount,C,l,h),I=n*o*a*w*S,x=u.get(f);if(x){x.score+=I,dt(x.terms,t);const k=G(x.match,s);k?k.push(d):x.match[s]=[d]}else u.set(f,{score:I,terms:[t],match:{[s]:[d]}})}}return u},xt=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields??e._options.fields).reduce((l,f)=>({...l,[f]:G(n.boost,f)||1}),{}),{boostDocument:r,weights:i,maxFuzzy:c,bm25:h}=n,{fuzzy:u,prefix:d}={...Y.weights,...i},a=e._index.get(t.term),m=T(e,t.term,t.term,1,t.termBoost,a,o,r,h);let g,y;if(t.prefix&&(g=e._index.atPrefix(t.term)),t.fuzzy){const l=t.fuzzy===!0?.2:t.fuzzy,f=l<1?Math.min(c,Math.round(t.term.length*l)):l;f&&(y=e._index.fuzzyGet(t.term,f))}if(g)for(const[l,f]of g){const w=l.length-t.term.length;if(!w)continue;y?.delete(l);const p=d*l.length/(l.length+.3*w);T(e,t.term,l,p,t.termBoost,f,o,r,h,m)}if(y)for(const l of y.keys()){const[f,w]=y.get(l);if(!w)continue;const p=u*l.length/(l.length+w);T(e,t.term,l,p,t.termBoost,f,o,r,h,m)}return m},X=(e,t,s={})=>{if(t===U)return wt(e,s);if(typeof t!="string"){const d={...s,...t,queries:void 0},a=t.queries.map(m=>X(e,m,d));return Q(a,d.combineWith)}const{tokenize:n,processTerm:o,searchOptions:r}=e._options,i={tokenize:n,processTerm:o,...r,...s},{tokenize:c,processTerm:h}=i,u=c(t).flatMap(d=>h(d)).filter(d=>!!d).map(ft(i)).map(d=>xt(e,d,i));return Q(u,i.combineWith)},Z=(e,t,s={})=>{const{searchOptions:n}=e._options,o={...n,...s},r=X(e,t,s),i=[];for(const[c,{score:h,terms:u,match:d}]of r){const a=u.length||1,m={id:e._documentIds.get(c),score:h*a,terms:Object.keys(d),queryTerms:u,match:d};Object.assign(m,e._storedFields.get(c)),(o.filter==null||o.filter(m))&&i.push(m)}return t===U&&o.boostDocument==null||i.sort(P),i},zt=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:r,terms:i}of Z(e,t,s)){const c=i.join(" "),h=n.get(c);h!=null?(h.score+=r,h.count+=1):n.set(c,{score:r,terms:i,count:1})}const o=[];for(const[r,{score:i,terms:c,count:h}]of n)o.push({suggestion:r,terms:c,score:i/h});return o.sort(P),o};class bt{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if(!t?.fields)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?yt:t.autoVacuum;this._options={...gt,...t,autoVacuum:s,searchOptions:{...Y,...t.searchOptions},autoSuggestOptions:{...pt,...t.autoSuggestOptions}},this._index=new z,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=K,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[r,i]of n)o[r]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,version:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const kt=e=>new bt(e),It=({documentCount:e,nextId:t,fieldIds:s,averageFieldLength:n,dirtCount:o,version:r},i)=>{if(r!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const c=kt(i);return c._documentCount=e,c._nextId=t,c._idToShortId=new Map,c._fieldIds=s,c._avgFieldLength=n,c._dirtCount=o??0,c._index=new z,c},Mt=(e,t)=>{const{index:s,documentIds:n,fieldLength:o,storedFields:r}=e,i=It(e,t);i._documentIds=O(n),i._fieldLength=O(o),i._storedFields=O(r);for(const[c,h]of i._documentIds)i._idToShortId.set(h,c);for(const[c,h]of s){const u=new Map;for(const d of Object.keys(h))u.set(parseInt(d,10),O(h[d]));i._index.set(c,u)}return i},V=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let r=0,i=0;const c=(u,d=!1)=>{let a;i===0?a=u.length>20?`… ${u.slice(-20)}`:u:d?a=u.length+i>100?`${u.slice(0,100-i)}… `:u:a=u.length>20?`${u.slice(0,20)} … ${u.slice(-20)}`:u,a&&o.push(a),i+=a.length,d||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let h=s.indexOf(n,r);if(h===-1)return null;for(;h>=0;){const u=h+n.length;if(c(e.slice(r,h)),r=u,i>100)break;h=s.indexOf(n,r)}return i<100&&c(e.slice(r),!0),o},Ot=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),Ct=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),tt=(e,t,s={})=>{const n={};return Z(t,e,{boost:{h:2,t:1,c:4},prefix:!0,...s}).forEach(o=>{const{id:r,terms:i,score:c}=o,h=r.includes("@"),u=r.includes("#"),[d,a]=r.split(/[#@]/),m=Number(d),g=i.sort((l,f)=>l.length-f.length).filter((l,f)=>i.slice(f+1).every(w=>!w.includes(l))),{contents:y}=n[m]??={title:"",contents:[]};if(h)y.push([{type:"customField",id:m,index:a,display:g.map(l=>o.c.map(f=>V(f,l))).flat().filter(l=>l!==null)},c]);else{const l=g.map(f=>V(o.h,f)).filter(f=>f!==null);if(l.length&&y.push([{type:u?"heading":"title",id:m,...u&&{anchor:a},display:l},c]),"t"in o&&o.t)for(const f of o.t){const w=g.map(p=>V(f,p)).filter(p=>p!==null);w.length&&y.push([{type:"text",id:m,...u&&{anchor:a},display:w},c])}}}),$(n).sort(([,o],[,r])=>"max"==="total"?Ot(o,r):Ct(o,r)).map(([o,{title:r,contents:i}])=>{if(!r){const c=it(t,o);c&&(r=c.h)}return{title:r,contents:i.map(([c])=>c)}})},et=(e,t,s={})=>{const n=zt(t,e,{fuzzy:.2,maxFuzzy:3,...s}).map(({suggestion:o})=>o);return e.includes(" ")?n:n.filter(o=>!o.includes(" "))},St=st($(JSON.parse("{\"/\":{\"documentCount\":89,\"nextId\":89,\"documentIds\":{\"0\":\"0\",\"1\":\"1\",\"2\":\"2\",\"3\":\"2@0\",\"4\":\"2@1\",\"5\":\"3\",\"6\":\"3@0\",\"7\":\"3@1\",\"8\":\"4\",\"9\":\"4@0\",\"10\":\"4@1\",\"11\":\"5\",\"12\":\"5@0\",\"13\":\"5@1\",\"14\":\"6\",\"15\":\"6@0\",\"16\":\"6@1\",\"17\":\"7\",\"18\":\"7@0\",\"19\":\"7@1\",\"20\":\"8\",\"21\":\"8@0\",\"22\":\"8@1\",\"23\":\"9\",\"24\":\"9@0\",\"25\":\"9@1\",\"26\":\"10\",\"27\":\"10@0\",\"28\":\"10@1\",\"29\":\"11\",\"30\":\"11@0\",\"31\":\"11@1\",\"32\":\"12\",\"33\":\"12@0\",\"34\":\"12@1\",\"35\":\"13\",\"36\":\"13@0\",\"37\":\"13@1\",\"38\":\"14\",\"39\":\"14@0\",\"40\":\"14@1\",\"41\":\"15\",\"42\":\"15#struct\",\"43\":\"15#union\",\"44\":\"15@0\",\"45\":\"15@1\",\"46\":\"16\",\"47\":\"16@0\",\"48\":\"16@1\",\"49\":\"17\",\"50\":\"17@0\",\"51\":\"17@1\",\"52\":\"18\",\"53\":\"18@0\",\"54\":\"18@1\",\"55\":\"19\",\"56\":\"19@0\",\"57\":\"19@1\",\"58\":\"20\",\"59\":\"20@0\",\"60\":\"20@1\",\"61\":\"21\",\"62\":\"21@0\",\"63\":\"21@1\",\"64\":\"22\",\"65\":\"22@0\",\"66\":\"22@1\",\"67\":\"23\",\"68\":\"23@0\",\"69\":\"23@1\",\"70\":\"24\",\"71\":\"24@0\",\"72\":\"24@1\",\"73\":\"25\",\"74\":\"25@0\",\"75\":\"25@1\",\"76\":\"26\",\"77\":\"26@0\",\"78\":\"26@1\",\"79\":\"27\",\"80\":\"27@0\",\"81\":\"27@1\",\"82\":\"28\",\"83\":\"28@0\",\"84\":\"28@1\",\"85\":\"29\",\"86\":\"30\",\"87\":\"31\",\"88\":\"32\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1],\"1\":[1],\"2\":[4,162],\"3\":[null,null,2],\"4\":[null,null,1],\"5\":[3,24],\"6\":[null,null,2],\"7\":[null,null,1],\"8\":[2,167],\"9\":[null,null,2],\"10\":[null,null,1],\"11\":[2,168],\"12\":[null,null,2],\"13\":[null,null,1],\"14\":[4,154],\"15\":[null,null,2],\"16\":[null,null,1],\"17\":[4,136],\"18\":[null,null,3],\"19\":[null,null,2],\"20\":[5,334],\"21\":[null,null,3],\"22\":[null,null,2],\"23\":[6,174],\"24\":[null,null,3],\"25\":[null,null,2],\"26\":[6,65],\"27\":[null,null,3],\"28\":[null,null,2],\"29\":[4,51],\"30\":[null,null,3],\"31\":[null,null,2],\"32\":[4,190],\"33\":[null,null,3],\"34\":[null,null,2],\"35\":[6,280],\"36\":[null,null,3],\"37\":[null,null,2],\"38\":[4,278],\"39\":[null,null,3],\"40\":[null,null,2],\"41\":[5,8],\"42\":[1,123],\"43\":[1,50],\"44\":[null,null,3],\"45\":[null,null,2],\"46\":[6,70],\"47\":[null,null,3],\"48\":[null,null,2],\"49\":[6,136],\"50\":[null,null,3],\"51\":[null,null,2],\"52\":[4,122],\"53\":[null,null,3],\"54\":[null,null,2],\"55\":[3,9],\"56\":[null,null,3],\"57\":[null,null,2],\"58\":[2,181],\"59\":[null,null,3],\"60\":[null,null,2],\"61\":[3,63],\"62\":[null,null,2],\"63\":[null,null,2],\"64\":[2,21],\"65\":[null,null,2],\"66\":[null,null,2],\"67\":[3,27],\"68\":[null,null,2],\"69\":[null,null,2],\"70\":[5,6],\"71\":[null,null,2],\"72\":[null,null,2],\"73\":[3,35],\"74\":[null,null,2],\"75\":[null,null,2],\"76\":[3,17],\"77\":[null,null,2],\"78\":[null,null,2],\"79\":[5,47],\"80\":[null,null,2],\"81\":[null,null,2],\"82\":[3,42],\"83\":[null,null,2],\"84\":[null,null,2],\"85\":[1,3],\"86\":[2],\"87\":[3],\"88\":[3]},\"averageFieldLength\":[3.0290390351711616,93.84743778381136,1.8931216100452037],\"storedFields\":{\"0\":{\"h\":\"主页\"},\"1\":{\"h\":\"文章\"},\"2\":{\"h\":\"关于 CRLF 和 LF\",\"t\":[\"大家可能在做 CQ's Challenge 的时候发现利用 getchar() 读掉换行符的方式（这在平时 OJ 上都是非常有效的）出现了意想不到的问题，样例在本地跑的是对的，但是交上去就不大对劲，这到底是什么情况？\",\"是这样的，某 CQ 在 Windows 下出题，一开始并没有考虑到这个问题，所以使用了自己用 C++ 编写的随机数程序，并直接在 Windows 平台的环境下自动生成数据。\",\"那在 Windows 平台下生成数据会有什么区别呢？\",\"是这样的，Windows 下的换行符和 Linux 下的换行符实际上并不一样，Linux 下的换行符是 LF，也就是大家平时碰到的，行末有一个换行符 \\\\n 来表示换行，但是 Windows 下就不一样了，它实际上是 CRLF，也即用 \\\\r\\\\n 来表示换行，所以当你发现你的 getchar 不好用了，实际上也许就是 CRLF 在捣鬼。\",\"虽然说 OJ 数据按照标准应当是统一使用 LF 换行的，大大地提高了各位的做题体验，但是大部分情况下，我们并无法确定出题人用的是 CRLF 还是 LF，所以还是需要一种更稳妥的读入数据的方式，来帮助我们绕过这个 CRLF 和 LF 的问题。\",\"解决这个问题的方法一般有两种：\",\"1.老老实实使用 scanf 进行读入数据\",\"我们都非常清楚（应该？），scanf 读入数据的时候，除了读入单个字符（%c），其它情况下，scanf 都会自动跳过空白符和一些无关的特殊字符，甚至你还可以利用 scanf 来指定输入的格式（如果你会用正则表达式的话），也就是说，当输入数据一切正常的时候，直接使用 scanf，而不去在意输入格式的具体情况，是一种非常好的做法。\",\"2.继续使用 getchar()，但用另一种方式\",\"scanf 比 getchar 要智能的多，但是这种智能，是用时间来换的，也就是说，读入同样多的数据量，scanf 读入的速度，比 getchar 要慢不少，这么强大的工具，怎么会随手把它丢掉。\",\"那用 getchar 如何绕过这些问题呢？ 答案是：用 while，直到读入到自己需要的数据。\",\"这里举个例子可能会更清楚一点。\",\"scanf读入整数好慢好慢（当然printf也有点点慢，不过还好），如果你做过 CQ's Challenge C题的早期版本，你就会发现用 scanf 是无法通过的，只能拿到 80 分，那我们可以利用 getchar 来优化整数的读入过程：\",\"#define isdigit(ch) (ch >= '0' && ch <= '9') // isdigit()实际上在ctype.h当中有定义，这里假定你没有引用 void readInt(int* n) { *n = 0; // 用来表示这个数字是正数还是负数 int sign = 1; char ch = getchar(); // 直到读到我们需要的数字 while(!isdigit(ch)) { ch = getchar(); // 有负号，是负数，在数据都是非负整数的情况下甚至可以舍去这条判断。 if (ch == '-') { sign = -1; } } // 是数字，连续读入（因为是一个完整的数字），直到读到非数字（标志结束） while (isdigit(ch)) { // 因为上面已经读到一个了，所以我们先把它处理了 *n = ((*n) << 3) + ((*n) << 1) + ch - '0'; // 这里的((*n) << 3) + ((*n) << 1)实际上就是 (*n) * 10 的意思，只不过位运算和加法都比乘法快 // 想一想为什么是这个式子 ch = getchar(); } *n = (*n) * sign; // 处理符号问题 } // 具体使用： int n; readInt(&n); \",\"利用这种写法我们就获得了一种读入整数的更快的方式，你看到我们是怎样绕过 LF 和 CRLF 的问题的了吗？\",\"实际上这种绕过方式的精髓在于，我们不是碰到无关的就跳过，而是不断读入直到读入到我们需要的东西再进行处理，这样在读入的过程中就自然而然地略过了无关的字符，达成了目标。\",\"用 CRLF 出题，我真的错了！特以此篇，以表歉意 OTZ\"]},\"3\":{\"c\":[\"C 语言学习分享\"]},\"4\":{\"c\":[\"CPL\"]},\"5\":{\"h\":\"小游戏项目不知道怎么写？我来助你！\",\"t\":[\"还在为不知道怎么写CPL课程的小游戏项目而烦恼吗？\",\"那可真是太巧了！我这恰好一不小心花了点时间写了一个小项目：\",\"你猜怎么着！恰好完成了其中一道期末项目的要求！\",\"我将代码都留了下来，并且编写了一段较为详尽的教程来告诉你我是怎么写出这个项目的。\",\"我把项目放在 GitHub 这里了！要是真的不知道大项目该怎么写，那你也来看看吧！\",\"别忘了给我点颗星~o((>ω< ))o\",\"（特别提醒：可以参考我的代码，学习我的一些做法，但是不能直接抄袭，这是对课程、老师和其它同学的不尊重！，如若抄袭并不幸被查重，后果自负）\"]},\"6\":{\"c\":[\"C 语言学习分享\"]},\"7\":{\"c\":[\"CPL\"]},\"8\":{\"h\":\"随机数据生成 & 正确性验证\",\"t\":[\"某 CQ 今天发现有不少同学会在群里面求某道题的测试数据来验证自己程序的正确性。\",\"每个人程序的做法是不同的，错误也很可能出在五花八门的地方，也就是说，同样的数据，别人是对的你不一定对，别人是错的你也不一定就是错的。\",\"经常在群里求数据解决问题是不可取的，首先没有那么多的测试数据来给，其次也并不知道你错在哪里，不能给出更有针对性的数据。\",\"那么我们怎么能更高效的获得可能使你程序出错的数据呢？某 CQ 就在这里给大家介绍介绍：\",\"首先我们需要自己写个程序来生成随机的测试数据：\",\"C 语言怎么写随机数呢？直接上代码你就懂了！\",\"#include<stdio.h> #include<stdlib.h> int random(int l, int r) { return rand() % (r - l + 1) + l; } int main() { srand(time(0)); int a = random(1, 10000), b = random(1, 10000); printf(\\\"%d %d\\\\n\\\", a, b); return 0; } \",\"这样就写好了一个生成 A+B Problem 的数据的随机数程序。\",\"我们来具体解析几个陌生的东西。这些东西都在 stdlib.h 里：\",\"time(0) 指获取当前系统时间，它会动态返回一个不同的 int 值。\",\"srand() 指的是设置随机数种子，当你将系统时间设置为随机数种子的时候，这样种子就会在不断的变化，在这里提一嘴，同样的种子出来的随机数是不会变的，内部的计算原理某 CQ 并不清楚。\",\"而 rand() 就是取一个范围是 1 到 65535 的随机整数值，在这里我们假定数据范围是 1 到 10000 ，所以我们自己写了一个 random 函数用来生成 l 到 r 范围内的随机数，其中用取模来限制 rand() 的值的范围。\",\"这里要特别注意，如果需要更大的数据，你可以将多个 rand() 相乘，但是请注意范围可能会超过 int，必要时记得开 long long。\",\"学会了生成随机数，我们就可以根据不同题目的输入要求来构造大量的随机数据啦！（因为每次跑代码所得到的结果都不一样）\",\"数据有了，那我用我自己的程序跑出结果我也不知道对不对啊？而且这样手动生成数据，也太麻烦了吧，效率太低，而且找到我想要的数据就算运气好也要花不少时间，这可怎么办呢？\",\"接下来就轮到我们的对拍上场辣！\",\"首先我们需要一个保证正确的代码生成的可执行文件用来作为标准输出正确答案，当某 CQ 发出这个帖子之后，他会在频道当中新开一个分区用来放近期题库正确可执行文件的下载链接，各位可以自行去下载。\",\"接下来我们假设： 接下来所有的文件都在同一个文件夹里 你的程序生成的可执行文件叫 code.exe 你的随机数程序生成的可执行文件叫 rand.exe 完全正确的程序生成的可执行文件叫 std.exe\",\"新建一个文件 check.bat（注意后缀名），填入以下代码：\",\"@echo off :loop rand.exe > data.in std.exe < data.in > std.out code.exe < data.in > code.out fc std.out code.out if not errorlevel 1 goto loop pause goto loop \",\"接下来我们来具体解释这些批处理命令：\",\"@echooff：关闭输入显示（否则刷屏警告）:loop：goto 嘛，洒洒水啦~>：将输出内容附到指定文件上<：将内容输入到程序中运行 两者可以按照逻辑顺序连用fc：(file compare)是 windows 的指令，它会比较两个文件之间有什么区别，并且输出结果if not errorlevel 1 goto loop：if 大家都很熟，这个 errorlevel 指的就是 fc 的程序返回值，如果是 1，那么这两个文件之间并没有差异，我们就直接 goto loop 生成之后的数据，如果不是 1，那么说明有问题，就停下来让你去 data.in 里面看是什么数据，然后当你按下任意按钮以后它会继续生成新数据。\",\"这里要注意的是，fc对文件的判断要求可能比oj要求更高，行末的空格最好别有（\",\"这样就造出了一个全自动的判别机，你可以开着这个程序来自动找到使你程序出错的针对性数据（虽然运气不好的话可能还是要跑很久）\",\"提示\",\"如果你正在使用你是 Linux，说明你是操作系统大神，这里就不介绍 Linux 下怎么写对拍了，和 Windows 下实际上是一样的，只是命令不同而已。\"]},\"9\":{\"c\":[\"C 语言学习分享\"]},\"10\":{\"c\":[\"CPL\"]},\"11\":{\"h\":\"控制时空复杂度：和超时爆空间说拜拜\",\"t\":[\"随着题目难度的增大，某 CQ 发现开始有越来越多的同学对空间超限以及时间超限发出了疑问。\",\"某 CQ 十分的奇怪：明明题目的时空限制放的都很宽啊，怎么会出现超时超空间的问题呢？\",\"一问发现有些同学的算法不是很好，导致在一些数据范围比较大的题目当中甚至出现了三重循环，这你不超时谁超时？如果看上去并不会超但是却时间超限了，那往往是死循环导致的。\",\"那么我们到底该怎么样控制我们程序的时空复杂度呢？\",\"其实十分的简单！下面就来大致的讲一讲罢！\",\"时间复杂度：\",\"这个时候你可以盯着题目给定的数据范围看，看看 n 的最大可以到多少，还有一些其它的数据范围，当你想好你将会怎么来做这道题之后，你就可以通过这些东西来计算自己应该用哪种数据类型（int -> long long）\",\"然后，最重要的来了！\",\"你盯着数据范围看，看够了再盯着自己循环次数最多的那个地方看（一次递归也算作一次循环），按照最大的数据范围计算出在最坏的情况下，你这里的循环要进行多少次，去掉一些没必要的常数，然后以 1亿 为准，在 1亿 左右或者小于 1亿 的循环次数，那你完全不用担心超时（正常机子 1亿 次循环次数大概刚好不过1s的时间限制，不过oj的机子貌似比较好，稍微超一点点也不大要紧，但不要太多）\",\"另外一种可能导致时间超限的原因可能是无限递归或者死循环，这个时候你需要检查你所有的while循环有没有出现恒为真的情况、递归的终止条件有没有写完整（以及剪枝是否到位，有时剪枝是优化时间的很关键的一步）、还有for循环有没有写成别的奇怪的东西（例如：for (int j = 1; i <= n; ++j)），解决这些问题估计死循环也很难存在了\",\"举个例子：n的数据范围是1到100000，你要对这个数据进行归并排序。\",\"那么你会发现，首先你会需要循环n次来读入，但实际上这个不是最要紧的，最要紧的是排序的过程，你会发现，当你每次将某一个序列分割的时候，实际上你合并的时候需要将这两半序列都过一遍，也就是说你每次将序列分成两半，你都需要进行 n 次循环次数，而将一个长度为n的序列分割至最小需要 log2​n 次所以这个程序实际上需要约 nlog2​n 次的循环次数，这就是归并排序在时间上的复杂度，算算超过了 1亿 吗？并没有，所以这个数据范围，归并排序是可以过的。但是冒泡排序和插入排序它们就不太好过了，你会发现它们在时间上的复杂度都是n²，远远超过了1亿（1e10），这就过不去时间限制了。\",\"空间复杂度：\",\"这东西不要太简单，如果你空间超限，那么恭喜你犯了除编译错误以外第二傻的问题（说的严重点），因为这东西真的太好算辣！\",\"sizeof(x) 可以算出 x 这个变量/数组/指针等任意东西所占用的内存大小，是按照字节来计算的，比如说 int 占 4 个字节，char 占 1 个字节。\",\"仔细观察每道题的标题，你会发现一个叫做空间限制的东西。\",\"你再仔细看你会发现它大概是 256 MB，那我们就以 256 MB 为标准来提一提，比如说你开了一些数组，假设现在有 a、b、c 三个数组，你想知道它们占了多少空间，那你可以尝试输出 (sizeof(a) + sizeof(b) + sizeof(c)) / 1024 / 1024，如果它大于等于 256，那你肯定就寄了。\",\"当然，你也可以借助空间限制来完成一些本来不可能的操作：\",\"比如，内存分配器这道题，题目要求明显是要你用链表来动态分配内存，因为它并没有明确告诉你到底要用多大的数组才够用，如果你想使用静态数组，你就一定得知道该用多大，而借助空间限制我们可以了解到：题目要求你用这么多内存来解决问题，那它肯定不会让你的空间超过这个限制，也就是说，你只要尽可能顶着空间限制开，那肯定没问题。\",\"观察题目我们知道需要开两个 int 数组，当然还要算上其它的一些变量函数啥的也会占内存，我们可以分出大概 200 多 MB 给这两个数组，那也就是每个数组有 100 MB 可以开，我们知道一个 int 占 4 个字节，1024 个字节是 1 KB，1024 KB 是 1 MB，所以我们的数组长度可以开到 100∗1024∗1024/4=26214400 个，经过测试的确是可以过的，所以，当我们的做法受到限制的时候，我们甚至可以利用空间限制来另辟蹊径，找到一种更容易写出的解决方案。\",\"看完这个，再去看两道题实战演练一下，相信你们再也不会在群里问超时怎么办，超空间怎么办这一类的问题了吧？\"]},\"12\":{\"c\":[\"C 语言学习分享\"]},\"13\":{\"c\":[\"CPL\"]},\"14\":{\"h\":\"XMake，你的 SDL2 项目打包好帮手\",\"t\":[\"XMake 是由国人开发的基于 Lua 的 C/C++ 构建系统，支持多重编译器和平台，利用 Lua 轻量、简洁、灵活、跨平台等特性，带来不一样的构建体验。\",\"请注意：不建议使用除 vscode 以外的编辑器使用 XMake 编写项目，这些编辑器有 XMake 插件但并不好用，没有办法提供合适的 include 解析，导致编写代码十分的困难，好在我们现在仅仅是借助 XMake 来帮助我们打包项目，在这里我们以 SDL2 为例，但 XMake 不仅限于此，它有十分充足的仓库，你几乎能在里面找到所有你想要使用的 C/C++ 库。\",\"安装\",\"安装指示在官方页面上写的非常清楚，就不在这里多写了\",\"镜像加速\",\"XMake 的 C/C++ 包都在 GitHub 上，访问速度很慢，甚至在一定程度上使用了魔法的情况下还会出现下载失败的情况，十分影响使用体验，因此十分有必要借助 github 镜像加速这个过程，在命令行中运行以下命令来使用 xmake 内部提供的镜像：\",\"xmake g --proxy_pac=github_mirror.lua \",\"工具链\",\"XMake支持几乎所有常见的工具链，XMake 也会在你的环境中探测使用它认为最合适的工具链，特别地，Windows 下建议使用 MSVC 构建工具链，它最稳定。\",\"XMake，启动！\",\"所有的前置步骤已经完成，下面就可以来开始打包项目了！我们以 SDLTest 项目名为例，来创建并编译一个新的SDL2项目吧！ 首先在指定的文件夹路径下使用 xmake 命令创建一个名为 SDLTest 的新项目：\",\"xmake create SDLTest \",\"它会在当前路径下创建一个名为 SDLTest 的文件夹，并在该文件夹中生成以下目录结构：\",\"其中 src/ 文件夹是存放项目代码的位置，.gitignore 文件与 git 有关，在此不多说，而 xmake.lua 文件便是这个 xmake 项目的配置文件，它的默认内容如下：\",\"你会发现，事实上我们还并没有将 SDL2 添加到我们的配置文件中作为编译内容的一部分，这一步其实很容易，我们只需要在仓库中找到对应的库名，并像这样添加到配置当中即可：\",\"保存！在 SDLTest/ 文件夹路径的命令行中输入：\",\"xmake\",\"即可启动编译！此时，xmake 会自动检查平台、工具链和需要安装的内容，并询问是否需要安装：\",\"输入 y 并回车，xmake 便会使用指定的工具链编译对应的库并安装到全局（xmake的安装位置）。\",\"此时，我们已经准备好编译运行我们的 SDL2 程序了！ 我在 Gitee 上随便找了一个 SDL2 编写的 tetris项目，并将代码拷贝到了 src 文件夹，并且这些文件正好适合 xmake.lua 的 add_files 命令\",\"那么，编译，启动！\",\"xmake xmake run \",\"使用 xmake 编译的项目也不需要考虑动态链接库的问题， xmake 考虑到了这一点，它将链接库也一起带了进去，让可执行文件点开即玩，非常顺畅！\",\"vscode includePath 配置（可选）\",\"虽然 xmake 官网上提供了详尽的解决方案，但是实际用起来效果并不尽如人意，相信使用 vscode 的大部分同学都使用了 C/C++ 插件吧？ Ctrl + Shift + P运行C/C++ 编辑配置：UI命令，并编辑includePath，添加 xmake 的安装路径/packages/////include ，然后再去看你的代码，就会发现 include 解析成功啦\"]},\"15\":{\"c\":[\"C 语言学习分享\"]},\"16\":{\"c\":[\"CPL\"]},\"17\":{\"h\":\"南哪 2022-0-intro\",\"t\":[\"各位好啊！这里是某 CQ！\",\"我不是佬，只是一个想为大家着想的菜菜OIer\",\"所以我们在这里正式推出C-PL dotOJ补完计划！\",\"很多同学反映，我们的OJ题目与上课内容脱节，上课内容听不懂。\",\"怎么办呢？某 CQ 来帮你！\",\"在某 CQ 仍然会当天课程的情况下，我们每周的C语言课后会尽快在洛谷挑选一些适合大家练习的题目，供大家为本周的OJ困难挑战做准备练习，同时也希望大家能获得对程序设计更深的理解。\",\"某 CQ 也会在题单的介绍中，为大家提供一些也许不是特别好的讲解。来帮助大家理解当周的课程。\",\"某 CQ 的其它课程成绩并不是很好，希望各位佬们能够帮助某 CQ！OTZ\",\"现在我们所在的是 0-intro 题单！\",\"在这周的课程中，我们学会了 C 语言的基本设计结构，也学到了基本的interger类型变量的定义、输入和输出。\",\"大体格式如下：\",\"#include <stdio.h> int main() { return 0; } \",\"这一部分是需要同学们记住的\",\"我们现在还无法理解 int main() 和 return 0 的具体意思，所以我们暂且先把这个放在一边，只需要知道一个程序不能少了上面代码的任何一个东西\",\"而 #include <stdio.h> 是指使编译器包含(include) stdio.h 这一 C 语言库的指令\",\"提示\",\"stdio.h 这个库来头可不小，他的std指的是标准(standard)，而io指的是输入输出(in, out)，连起来读就是标准输入输出库，.h 是它的文件名后缀，由此可知，我们在程序中输入输出都离不开它。\",\"在课程中，我们也学到了基本的输入输出指令\",\"输入：\",\"scanf(\\\"%d\\\", &a) \",\"其中 %d 表示我们想要读入一个整型(int)变量，之后跟上&号和我们想要存入这个数据的变量名。\",\"提示\",\"& 号表示这个变量的地址，这个很好理解啊，如果你直接写变量名，那 scanf 了解到的是这个变量的值，而要想写入数据，scanf 必须要知道这个变量的地址在哪里，它才好将读入的值存过去，所以，非常重要的一点是读入一定不能少了 &\",\"输出：\",\"printf(\\\"%d\\\\n\\\", a); \",\"提示\",\"printf 指令的内部需要给出一个用 \\\"\\\" 括起来的字符串和若干变量，当我们在 \\\"\\\" 里面填入东西，printf 就会输出对应的东西，而当我们写入 %d 的时候，就相当于告诉 printf，这里需要输出一个变量，而之后的给出的变量必须与按照前面字符串中出现的 %d 一一对应的给出，顺序也不能错。\",\"第零章我们只学了整型变量 int\",\"而且我们并不需要知道这是什么意思\",\"我们只需要知道，我们只要写出一行：\",\"int a; \",\"我们就能定义一个名为 a 的整型变量，而且我们能用上面的输入输出来对这个变量进行操作\",\"在学完 int 之后，我们又学了赋值语句和基本的四则运算\",\"赋值语句我们用的是 = 这个传奇的符号，它的能力是将它右侧的值赋给左侧的变量，于是我们便学会了对变量进行基本的处理：\\\\\",\"int a = 1, b = 2; int sum = a + b; \",\"这一章的内容貌似确实就该这么多，知道了这一点点东西，没想到我们已经能编写出一个能干点事情的程序了。那么，快来试试吧！\",\"某 CQ 祝大家在之后的题单中能够快乐地提升自己。\",\"题单链接：\",\"南哪2022-0-intro - 题单 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\"]},\"18\":{\"c\":[\"CPL DotOJ 补完计划\"]},\"19\":{\"c\":[\"CPL\",\"DotOJ\"]},\"20\":{\"h\":\"南哪 2022-1-types-io\",\"t\":[\"各位好呀，这里是某 CQ！\",\"今天给大家带来 1-types-io 的练习题单~\",\"根据 types-io 的题目，我们可以看出，这章主要是考察各位同学对变量类型的把控并使用变量类型及四则运算以及 math.h 库中的一些函数来解决较为实际的问题，所以这次我们主要的关注点是变量类型以及一些要注意的点。\",\"首先先来列一下常见的变量类型：\",\"int Num_int; long long Num_long_long; float Num_float; double Num_double; char ch; bool flag; // 注意，这里是随便命名，并不是某种标准的命名法，请不要参考！ \",\"int 类型：\",\"int 类型被称为 32 位带符号整数，它是用 32 个二进制位来表示的整数，同时，它的最高位用来表示符号，如果该位是 1 则这个数是负数。所以 int 类型真正用来表示数据大小的只有 31 位，这也就直接决定了 int 类型能表示的范围是 -2147483648 ~ 2147483647，也就是2的31次方减去1\",\"提示\",\"之所以负数能到 -2147483648，是因为在计算机中，负数是以补码的形式存储的，也就是把正数的二进制取反再加 1，所以 -2147483648 的补码就是 0，所以它实际上就是 0\",\"如果你确定不会出现负数，而且你想追求更大一些的表示范围的话，你可以使用 unsigned int 来充分利用这 32 位，即使它不再能表示负数。\",\"int 类型在 scanf 和 printf 里面的表示是%d\",\"unsigned int 类型在 scanf 和 printf 里面的表示是%u\",\"long long 类型：\",\"和 int 实际上一样，只不过人家是 64 位的，比 int 大得多。\",\"也有 unsigned long long，很好用\",\"long long 类型在 scanf 和 printf 里面的表示是 %lld\",\"unsigned long long 在 scanf 和 printf 里面的表示是 %llu\",\"关于整型变量的补充：\",\"其实在大部分情况下，大家需要用到的还是整型变量，所以在此某 CQ 希望给出更多的一些小技巧。\",\"关于存储空间：\",\"大家可能知道，也可能不知道，二进制的 8 个位成一个字节，也就是 1 Byte，或者 1 B，而 1024 B = 1 KB，而 1024 KB = 1 MB\",\"当我们在做题的时候，会看到题目给定的时空限制。\",\"当我们思考一道题如何去做的时候，也不要忘了去算一算自己到底用掉了多少空间，或者花去了多少的时间(最简单的方式是以1亿次循环为标准，超出即危险)，以避免空间超限和时间超限的问题。\",\"当然，当你拿不到完全分的时候，使用超时的算法拿部分分未尝不可。\",\"关于溢出：\",\"整型变量的溢出实际上比较好控制，当你超过一个整形变量能够表示的范围时，它会从它能表示范围的另一端重新开始，比如一个 int 变量存了 2147483647，加上 1 就变成了 -2147483648\",\"注意\",\"实际上，溢出是未定义行为，它的具体表现取决于编译器，所以你最好还是不要去尝试溢出，除非你非常清楚你自己在做什么。\",\"float 类型：\",\"float 类型被称为单精度浮点数，能被用来表示小数，但是表示的精度有限。\",\"float 类型在 scanf 和 printf 里面的表示是 %f\",\"double 类型：\",\"double 类型被称为双精度浮点数，是我们常用的小数变量类型，能表示更多的小数位。\",\"double 类型在scanf和printf里面的表示是%lf\",\"一些注意点：\",\"math.h 库中的函数实际上大多数的实现都是基于 double 的，使用 float 可能会出现一些精度上的问题\",\"printf 输出的一些奇技淫巧在此并不赘述。\",\"char 类型：\",\"char 类型表示一个字符，ascii 码里面实际上并没有多少东西，所以实际上一个 char 变量只有 8 位，也就是 1 个字节，最多只能表示到 255，在答疑中发现有人尝试用字符存大于 255 的数字，这个是值得注意的。\",\"char 类型在 scanf 和 printf 里面的表示是 %c\",\"一些注意点：\",\"可能不少同学去记'0'、'a'、'A'的ascii值，实际上是没有必要的，比如你可以使用'0'来直接表示字符0代表的值，C语言是认识这些东西的。\",\"注意\",\"当你 scanf 一个字符的时候，它是紧接着向后读一个字符，没错，这意味着换行符和空格也包括在内，使用时需要特别注意。\",\"bool 类型：\",\"bool 类型只有两种状态：0 或者 1，需要用到 stdbool.h 的库\",\"因为存储空间占用至少是 1 B，所以 bool 类型硬生生占了1B的内存，虽然它实际上只有1bit。\",\"提示\",\"至少占用 1 Byte 的内存空间是因为 C 语言的变量存储是对齐的，也就是内存地址是 8 的整数倍，所以 bool 类型实际上也会占用 1 Byte 的内存空间。\",\"bool 类型因为较 int 占用内存更加少而常被用在一些判断中。以及地图障碍的记录。\",\"关于 getchar() 和 putchar()：\",\"这俩货其实根本没必要知道，和 scanf%c 还有 printf%c 实际上是一样的\",\"提示\",\"但是它们更快。😉\",\"关于 enum：\",\"枚举类型实际上也是 int，但可以为这个变量的特定值附上特定的名字，可以用来很方便地表示一些固定的值，比如一周的星期几，一年中的月份，等等。\",\"比如：\",\"enum week { Monday = 0, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday }; \",\"这样，我们就可以使用 Monday 来表示星期一，使用 Tuesday 来表示星期二……\",\"提示\",\"枚举类型默认从 0 开始，你也可以为某个特定的枚举指定值，如不指定，则它的值为前一个枚举的取值 +1\",\"关于 typedef：\",\"typedef 可以用来给一个类型起一个新的名字，比如：\",\"typedef int integer; \",\"这样，我们就可以使用 integer 来表示 int 类型了。\",\"关于 math.h\",\"常见的数学函数，比如开根 sqrt，立方根 cbrt，乘方 pow，对数 log，绝对值 abs，这些，如果想用，除了自己写，就只能借助这个库了，当然，每个函数都有属于它自己的坑（比如 pow 难以接受负数），在使用之前，最好先查清楚怎么用。\",\"写出更好看的代码格式（非常重要）：\",\"一种好的代码格式，能让你的程序看上去更加清晰，检查起来好检查，也许也可以让你更有耐心地去Debug，而且别人看了至少也会觉着蛮清爽的。\",\"下面来举一个某 CQ 喜欢的代码格式：\",\"#include <stdio.h> long long solve(long long year, long long month, long long day) { long long a = (14ll - month) / 12ll; long long y = year + 4800ll - a; long long m = month + 12ll * a - 3ll; return day + ((153ll * m + 2ll) / 5ll) + 365ll * y + y / 4ll - y / 100ll + y / 400ll - 32045; } int main(int argc, char *argv[]) { long long year, month, day; scanf(\\\"%lld%lld%lld\\\", year, month, day); printf(\\\"%lld\\\\n\\\", solve(year, month, day)); return 0; } \",\"写出这样的代码具体改变了什么呢？\",\"控制好语句块的缩进\",\"对于附属于某一语句（比如 int main()、以及之后要学到的 for、if 等）的内容，我们需要相对于原来的语句额外缩进一个 Tab，而不是和原来那句并排写，那样只会导致更大的混乱。\",\"灵活运用 Tab 制表符来让你的程序变得更美观，比如：\",\"int numA, numA; char ch; long long ans; \",\"语句块之间可以适当空行\",\"虽然 C 语言中空行并不会影响程序，但是适当的空行可以让你的程序看起来区分步骤更加明显\",\"多加空格\",\"大家可能会问：加空格干什么用呢？\",\"空格能让你的不少算式看上去更加分散，易于分辨哪个是哪个，同时也可以使算式看上去更加易于理解。\",\"比如说上面那个长式子，给大家拿出来对比一下：\",\"long long ans = day + ((153ll * m + 2ll) / 5ll) + 365ll * y + y / 4ll - y / 100ll + y / 400ll - 32045; long long ans=day+((153ll*m+2ll)/5ll)+365ll*y+y/4ll-y/100ll+y/400ll-32045; \",\"区别非常明显，某 CQ 表示第二行代码根本不想看。\",\"另外某 CQ 想要提醒下各位同学，每道题有条件可把之前的代码清空了重写，这样可以更快地提高打字速度。\",\"某 CQ 知道各位同学已经学过了if和for还有while，但某 CQ 还是建议同学们使用当周的知识点解决问题。\",\"1-types-io就这些，其它内容个人根据需求自己看。\",\"题单链接：\",\"南哪2022-1-types-io - 题单 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\"]},\"21\":{\"c\":[\"CPL DotOJ 补完计划\"]},\"22\":{\"c\":[\"CPL\",\"DotOJ\"]},\"23\":{\"h\":\"南哪 2022-2-if-for-array\",\"t\":[\"if-for-array。在这一章中我们学会了 C 语言编程中最基础也是最重要的两种结构：分支结构以及循环结构\",\"以及一种最重要的写法：数组，这使得我们开始有能力处理大量的数据。\",\"if 语句，先来看一下用法：\",\"if (year % 4 == 0 && year % 100 != 0 || year % 400 == 0) { printf(\\\"是闰年。\\\\n\\\"); } else if (year % 10 == 0) { printf(\\\"是个整十数的年份。\\\"); } else { printf(\\\"貌似是个年份\\\"); } \",\"当 if 语句中条件成立的时候，便会执行 if 语句之后大括号里面的内容，如果条件不成立，且这个 if 后面有紧接着对应的 else 的时候，便会执行 else 之后大括号里面的内容\",\"if 语句可以进行嵌套，类似上面的写法，来对某个值进行分类\",\"同时，在使用 if-else 语句的时候，某 CQ 希望大家无论语句多少都加上大括号，以避免一些逻辑上的问题，因为有时，if 里面仍然有 if-else ，而如果没有加大括号，编译器便会选择最近的 if 来作为判断条件，这可能会导致一些意料之外的结果\",\"如果你想使用多种判断，你可以使用逻辑与(&&)还有逻辑或(||)来连接多个判断。\",\"其它的逻辑判断符号除了相等(==)特别一些（为了和赋值语句区分开），其它的也不太容易错\",\"提示\",\"if 判断条件中非 0 即真，比如：\",\"if (1) if (-1) if (a = 100) \",\"这些if条件之后的语句可以执行\",\"而：\",\"int n = 0; if (n) //... \",\"这个 if 之后的语句并不能执行。\",\"for 循环，先来看一下写法：\",\"for (int i = 1; i <= n; ++i) { printf(\\\"*\\\"); } \",\"可以看到，for 循环当中我们用两个分号将其分成了三个部分。\",\"第一个部分是初始化部分，在其中可以直接定义一个变量，也可以直接给某个变量附上初值，也可以不填。\",\"第二个部分是判断部分，只有判断条件成立，for 循环才会继续。\",\"第三个部分是处理部分，在每次循环结束的时候，这里面的操作都会进行一次。\",\"在每次循环结束并完成 for 循环中的处理部分后，for 循环会进行一次判断部分，如果判断不成立，for 循环就会结束。\",\"提示\",\"你可以使用 continue 语句来直接进入下一次循环\",\"你可以使用 break 语句来直接跳出循环\",\"我们还学习了数组。数组这东西好理解啊，我们把它想象成一个有限长的数列，数列中的每一个位置上都存储了一个对应类型的变量，我们需要提前指定这个数组的大小，我们也需要通过指定位置来调用某一个元素。\",\"int a[100005]; for (int i = 1; i <= 100000; ++i) { a[i] = i; } \",\"a 是我们建的数组的名字，我们在后面加上方括号，填上数字来告诉编译器我们想定义一个数组，长度为多少，之后我们就可以通过在方括号里填数组下标的形式来访问某一个特定的元素。\",\"结合 for 循环和数组，我们便能对大量的数据进行处理，统一读入、统一输出。\",\"一些提示：\",\"当同学们使用 for 循环的时候，可以灵活运用内部的三大部分，不一定每一个部分都要死板的填上东西，只要你的思路没有错误，你可以采取更花式的写法，你也可以把 for 循环变成下一次要提到的 while 循环，因为定义和处理部分完全可以不填。\",\"这便是 2-if-for-array 的大致内容，某 CQ 希望同学们在题单的习题中能够练习掌握这些基本结构。\",\"我们在结尾附上位运算的运算法则：\",\"与运算（&）：\",\"0 & 0 = 0, 1 & 1 = 1, 0 & 1 = 0, 1 & 0 = 0 \",\"或运算（|）：\",\"0 | 0 = 0, 1 | 1 = 1, 0 | 1 = 1, 1 | 0 = 1 \",\"异或运算（^）\",\"0 ^ 0 = 0, 1 ^ 1 = 0, 1 ^ 0 = 1, 0 ^ 1 = 1 \",\"位移运算（<<、>>）\",\"a << x 将 a 左移 x 位，相当于乘上 2 的 x 次方，右移同理\",\"提示\",\"超出存储范围的位数将被抹除，不足的将填上0\",\"注意\",\"位运算的速度比正常运算要快，灵活使用可以提高代码的效率，但是使用时，需要注意运算符的运算顺序，必要的情况下，尽量加上括号\",\"比如，判断一个数是否为偶数，如果使用 % 运算符的话，除法的速度非常的慢，而如果使用 n & 1 来获取 n 二进制下第一位的取值来判断的话，速度会快很多\",\"题单链接：\",\"南哪2022-2-if-for-array - 题单 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\"]},\"24\":{\"c\":[\"CPL DotOJ 补完计划\"]},\"25\":{\"c\":[\"CPL\",\"DotOJ\"]},\"26\":{\"h\":\"南哪 2022-3-for-a-while\",\"t\":[\"这一章实际上和上一章并没有区别\",\"因为 while 循环实际上完全可以由 for 循环替代，除了 do-while 循环\",\"来简单提一下这两种循环：\",\"while (a < b) { a = a + 1; } \",\"do { a = a * 2; } while (a < b); \",\"while 循环很简单，只要括号里的条件成立，它就会一直执行。\",\"do-while 唯一不同的地方在于，无论条件成立与否它都会先执行一次，再进行判断。\",\"continue 和 break 语句在 while 循环中依旧适用。\",\"当输入不确定数量的数据时，我们可以通过 while 循环来实现：\",\"while (scanf(\\\"%d\\\", &n) != EOF) { /* ---- */ } \",\"还有一个重要的知识点，虽然某 CQ 并不会严格的证明，但是他告诉同学们，取模运算十分神奇，在运算过程中随时取模，最终得出的结果与只对结果取模是一样的！\",\"以后的题目中可能会出现对某一数字取模的情况，这很有可能是运算过程中产生的结果可能过大，需要同学们及时对各个数据进行取模。\",\"到这里就不得不提一嘴：很多同学遇到了自己检查不出来却实际上超出了变量可存储范围的运算，所以某 CQ 请各位同学们在进行变量相加或者相乘的时候，注意观察题目的数据范围思考在最坏的情况下自己的算式会不会有某个地方超出了变量的存储范围，如果是，则需要对自己的算式进行一定的修改，比如将除法提前。\",\"题单链接：\",\"南哪2022-3-for-a-while - 题单 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\"]},\"27\":{\"c\":[\"CPL DotOJ 补完计划\"]},\"28\":{\"c\":[\"CPL\",\"DotOJ\"]},\"29\":{\"h\":\"南哪 2022-4-loop\",\"t\":[\"这一章仍然在与上两章内容重复，只多了一个 goto 语句\",\"goto 语句并不建议使用，因为会造成代码逻辑的混乱，但当处在多重循环之中，想要一下子跳出所有的循环，一层一层 break 比较麻烦，这时候 goto 语句才有了用武之地。\",\"简单介绍一下使用方式：\",\"int ans = 0, n; scanf(\\\"%d\\\", &n); if (n == 0) { // n = 0 情况下，答案显然可以直接得出，那么可以跳过求解步骤直接输出答案 goto End; } // 假装这里有一大堆用于求解 ans 的语句 End: printf(\\\"%d\\\\n\\\", ans); \",\"提示\",\"goto 实际上是历史遗留问题，它来自于汇编语言，在高级语言中不建议使用，因为它的使用会导致代码逻辑混乱，难以调试。\",\"这次题单里面更多的会出现二维数组的题目，可以将它想象成一个棋盘，每一个格子都存上一个变量。\",\"题单链接：\",\"南哪2022-4-loops - 题单 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\"]},\"30\":{\"c\":[\"CPL DotOJ 补完计划\"]},\"31\":{\"c\":[\"CPL\",\"DotOJ\"]},\"32\":{\"h\":\"南哪 2022-5-function\",\"t\":[\"大家好啊，这里是某 CQ ！\",\"这次是第一次准时推出的C-PL dotOJ补完计划！\",\"其实这章题目还是挺水的，老师貌似是有选择性的听取了上次开会的提议，让OJ的前几题较为简单，便于练习。\",\"这章主要是要求我们通过函数将代码分块，各个函数解决小范围内的一些问题，然后将它们组合起来解决整个问题。\",\"如果你并没有学习函数并能灵活使用，那么这次的OJ作业对你来说仍然十分煎熬磨人。\",\"那么，函数究竟是干嘛用的呢？\",\"来看下面一个例子：\",\"int n; int cycle(int x) { if (x > n) { x -= n; } if (x < 1) { x += n; } return x; } int main() { while (1) { x = cycle(x + 1); } return 0; } \",\"（这代码当然是个死循环，不要想着去运行）\",\"（某 CQ 将这个函数用在了约瑟夫问题当中，他发现这玩意真的很好用。）\",\"通过写这样一个 cycle 函数，我们将 x 的值成功的限制在了 1 到 n 的范围内，使得 x 可以在某一范围内循环地往右运动。\",\"你实际上可以发现函数只不过是把一些东西放到另一个地方去写罢了。这有什么用呢？\",\"非也！当你在很多地方都要做同一种操作，你就堆在主函数里面？那自然写出来的代码是十分臃肿的。\",\"想想不久前你可能仍然挣扎在数百行代码之中，但你会发现你实际上大部分的代码都是在复制粘贴。\",\"如果有一种代码能够统一的表示这些操作，那该多好啊？\",\"这就是函数的用途所在，把一些繁复的语句打包，在你想用的时候，说一声就完事了。\",\"我们来分析一下函数的定义方法：\",\"首先，函数是不能定义在某一个函数里面的，我们一直在写的 int main() 就是一个特殊的函数。\",\"提示\",\"main 作为 C 语言规定的程序的入口，所有的程序都从这里开始执行，因此，每一个 C 语言程序都必须包含 main 函数\",\"我们以上面的 cycle 函数为例，来解释一下函数的结构：\",\"首先是这个函数的返回值类型：我们在 cycle 函数中需要获得 x 限制在 1 到 n 范围内的值，所以它的返回值肯定是我们想要得到的那个值，也就是一个 int 值。\",\"然后是这个函数的名字，这个不必说，函数后面一定有括号，括号中可以填一些传入该函数的参数，说人话，就是告诉函数它需要知道这些值，它才能给你算出答案来。在 cycle 函数中我们传入了经过处理的 x 值，希望通过函数将它限制在 1 到 n 的范围内。\",\"另外，如果你想要传入多个参数，你必须用逗号隔开并分别指定每一个变量的类型，即使变量类型是一样的也不行。\",\"最后是这个函数的主体部分，具体怎么实现自然不必说，大家应该都会。\",\"特别的，函数有一种特别的类型，叫做 void 函数，void 函数没有返回值，而仅仅是作为一个操作存在，在主函数中可以直接调用这个函数来实现这个操作。\",\"这也是某 CQ 一直想让你们把关键的变量放在主函数外面的原因。当你将函数定义在这些变量后面的时候，因为这些变量已经声明，在函数中没有变量与之重名的情况下（注意！这个非常的重要！），你可以调用和修改这些变量！\",\"举一个 void 函数的例子：\",\"int a[10005]; void reverse(int l, int r) { while (l < r) { int t = a[l]; a[l] = a[r]; a[r] = t; ++l, --r; } } \",\"通过这样一个函数，我们便实现了一个简单的操作：将数组从 l 到 r 这个区间反转。\",\"（这也正是某 CQ 在这周的 E 题 下一个排列中用到的函数）\",\"在函数的使用过程中，我们需要特别注意这一点：\",\"当一个函数有了返回值，这个函数就会直接结束。\",\"比如说大家可能已经尝试通过在主函数里直接 return 0; 来提前结束主函数，这也是一个优化的小技巧，当你的函数已经得出结论，没必要继续下去的时候，你能直接通过返回值来立即离开这个已经没有用的函数。\",\"可能你想问，void 函数也能返回值吗？\",\"当然可以啊，void 只要返回空的不就行了嘛，也就是说，在 void 函数中，你也可以使用 return; 来直接退出。\",\"这样就大致讲解了函数的使用方法。\",\"还不明白？来告诉你们一个使用实例：\",\"本周作业 D 题，也就是确定进制那道题，你可以编写一个判断是否确认符合进制规则的函数，再编写一个将 n 进制的数转化为 10 进制的数的函数，然后判断p,q,r是否在某一个进制下符合条件？只需要在这三个数都符合条件的情况下，转化为十进制的 p 和 q 的乘积等于十进制下的 r 就行了哦\",\"是不是感觉比不用函数的思路简单许多？\",\"（某 CQ 表示函数真的很好用，大家一定要多加练习）\",\"这次的题单也许会出现之前题单中出现的题目，某 CQ 这次希望大家使用函数的方法来解决这些题目。\",\"感谢各位的收看！\",\"题单链接：\",\"南哪2022-5-function - 题单 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\"]},\"33\":{\"c\":[\"CPL DotOJ 补完计划\"]},\"34\":{\"c\":[\"CPL\",\"DotOJ\"]},\"35\":{\"h\":\"南哪 2022-6-recursion EX 搜索\",\"t\":[\"特别注意：P2383 是最难的题，需要考虑大量的剪枝优化，建议放到最后做\",\"搜索的题目一开始做会有一点点难理解，练多了才会好，所以这次题目难度变化不会很大，但是数量增加（不过貌似也不是特别多的亚子）\",\"P1433 不要听题解瞎说，正常做数据范围应该是能过的\",\"这里到处都是重点，请各位同学一定要看到最后。\",\"各位好啊！又是我，某 CQ！\",\"发现大家递归好像做的还行了，但是好像基于递归来暴力求解一些问题还不太熟练。\",\"这次我们将从全排列问题开始讲起，将基于递归的搜索的通用做法来给大家过一遍。\",\"将 1 到 n 这 n 的数字按某种顺序排好，一共有多少种排法？并且我们要求你把所有的排法情况按照字典序输出。\",\"int a[N]; bool vis[N]; void permutations(int now) { // 所有的位置都放好数字了，直接输出 if (now > n) { // 这个输出自己写 output(); return; } for (int i = 1; i <= n; ++i) { // 如果这个数字没有被用过 if (!vis[i]){ // 标记为用过 vis[i] = true; // 搜索下一位 permutations(now + 1); // 这个数字不用了，取消标记 vis[i] = false; } } } \",\"实际上，上面的程序里面已经标注的很清楚了。\",\"在每个递归的子问题当中，我们只要处理当前这一位我们要填什么，这一位具体能填哪些数字由前面已经填过的位置决定。\",\"当填好这一位，我们去填下一位。\",\"当所有的位置都填好了，我们就直接输出，然后返回去找别的填数的可能。\",\"当返回前一位的时候，这一位上原本填的数字不要了，所以一定要记得把标记去除。\",\"在这里我们注意到几个问题，它们也正是搜索要注意的内容：\",\"首先，因为这样的穷举方式是基于递归的，所以终止条件依然少不了，不然就等着死循环吧。\",\"其次，能用这种穷举来解决的问题，某个子问题的求解不会被之后求解的另一个子问题所影响，而是只会被在其前面的子问题影响（或者子问题之间根本没有关系）。\",\"然后就是每一个子问题的具体求解，在求解下一个子问题之前一定要把当前子问题对之后子问题求解造成的影响记下来，当返回的时候，一定要把标记取消，否则会有意想不到的（或者意想得到的）问题。\",\"另外需要提醒的一点就是，递归中的错误很可能让人摸不着头脑，最适合的解决方法除了调试，也就只有把整段代码的逻辑重新过一遍才有可能解决了。\",\"听说有些老师在课上已经讲过了八皇后问题。\",\"实际上，在全排列这一代码的基础上稍加修改，我们就能得出求解八皇后问题的方法。\",\"我们按照 8 x 8 棋盘的行来分，显然每一行只可能有一个皇后，每个皇后的列号肯定也不一样，那么我们只要枚举每一行的皇后的列坐标就行。\",\"所以八皇后问题就是一个 n = 8 的全排列问题，不过，条件的判断略有不同。\",\"通过全排列我们已经解决了皇后们出现在同一行/列的问题，现在我们需要解决斜角上冲突的问题。\",\"如果说我们把前面已经找过的皇后全部过一遍一个一个判断，固然是可以的，但是这样做，如果我们将问题扩展到n皇后问题，就显得不那么优秀了，容易超时，那怎么办呢。\",\"注意看某一条从右上到左下的斜线上每一个点的坐标，你会发现，同一条斜线上的点，它们的行号和列号相加是相等的。\",\"从左上到右下的斜线同理，自己算一下这些点的行号和列号之间大概有什么关系。\",\"八皇后问题在洛谷上能找到这道题，在这里就不重复放这道题的具体解法了，这道题会被选在题单里面，如果仍然不是很理解，可以去看看题解。\",\"接下来进入十分重要的一环，在二维图上的路径搜索：\",\"拿一道简单的题目来举例：\",\"一个 n x m 的地图，从（1，1）走到（n，m），只能朝上下左右四个方向走，图中有一些障碍物，求最少要走多少步才能到终点。\",\"注意这里障碍物不止一个，可能有很多个，采取之前蚂蚁寻路的那种通过讨论绕开障碍物的做法是不可取的。\",\"我们先用递归的思路来考虑这个问题：\",\"终止条件：\",\"当我们到达终点或者没有路走了，我们就不需要进一步考虑下一个子问题了。\",\"之后的问题是否对前面的问题有影响：\",\"你走到某一个点，并不会影响前面你走过某个点。所有后面的问题对前面是没有影响的。\",\"具体子问题做法：\",\"当你在点（x，y）时，除了来路，你有三个方向可以走：\",\"如果某个方向上是障碍物或者地图边界，不能走，直接跳过这一个方向。\",\"如果某个方向上是能走的路，而且当前路径之前并没有走过，那么就走过去。\",\"所有的情况都探索完了，退到上一步，继续去找其它的情况，此时记得要把当前的标记去除（因为你需要标记某一个点你有没有走过）。\",\"这里有一个小技巧就是如果是障碍物，你可以直接把它标记为已经走过，这样就不会走上去了。\",\"来看一下展示具体做法的代码：\",\"// 定义方向，减少搜索过程中复制粘贴的工程量（以及其中高得离谱的错误率），这里为了方便，用0占掉了第一格 const int dx[5] = {0, 1, -1, 0, 0}; const int dy[5] = {0, 0, 0, 1, -1}; // 我们要找到最短路径，那么答案初始值应该是最大的，这样才能保证答案最短 int ans = 2147483647, n, m; // 存图实际上有 vis 数组（邻接矩阵）就够了 bool vis[N][N]; // dfs指的是深度优先搜索(Depth first search)从整个搜索过程思考一下为什么它叫这个名字 void dfs(int step, int x, int y) { // 如果这个位置并不能走，直接返回 if (vis[x][y]) { return; } // 走过了，打上标记 vis[x][y] = true; //如果这个位置在地图范围之外，也不能走，直接返回 if (x < 1 || x > n || y < 1 || y > m) { return; } if (x == n && y == m) { if (step < ans) { // 更新答案，同时不要忘了返回，不要继续往下找了 ans = step; } vis[x][y] = false; return; } // 枚举方向 for (int i = 1; i <= 4; ++i) { int nx = x + dx[i], ny = y + dy[i]; // 无所谓，边界条件会出手，直接走 dfs(step + 1, nx, ny); } //返回了，别忘了取消标记 vis[x][y] = false; } \",\"这便是最基本也是最常见的两种搜索，其它的搜索也许在形式上略有不同，但是也逃不过这种思路，记好某 CQ 总结的几点注意，绝对能把搜索写对。\",\"下面讲一点搜索的优化小技巧：\",\"如果你将整个搜索过程画图表示出来，它很像一个从根开始不断分叉的树，我们想要优化搜索，就需要将其中我们不需要的一些分支尽可能的去掉，所以我们很形象地把这种搜索优化方法称作剪枝，实际上就是通过添加一些边界条件来跳过一些不必要的搜索。\",\"其实上面那道图上寻路就可以进行剪枝优化，我们稍微修改一下上面的代码，就能得到：\",\"const int dx[5] = {0, 1, -1, 0, 0}; const int dy[5] = {0, 0, 0, 1, -1}; //定义方向，减少搜索过程中复制粘贴的工程量（以及其中高得离谱的错误率），这里为了方便，用0占掉了第一格 int ans = 2147483647, n, m; bool vis[N][N]; void dfs(int step, int x, int y) { if (vis[x][y]) { return; } vis[x][y] = true; if (x < 1 || x > n || y < 1 || y > m) { return; } // 如果已经走的步数都超过了现有的答案，那他之后怎么走都不会比答案更好了，走它干嘛 if (step > ans) { return; } // 答案已经最小，就没必要求下去了 if (ans == n + m - 2) { return; } if (x == n && y == m) { if (step < ans) { ans = step; return; } } for (int i = 1; i <= 4; ++i) { int nx = x + dx[i], ny = y + dy[i]; dfs(step + 1, nx, ny); // 原理同上 if (ans == n + m - 2) { return; } } vis[x][y] = false; } \",\"通过添加一些边界条件，我们去掉了一些没必要的搜索，优化了搜索的效率，这在一些题目里面，可能会成为至关重要的一环，说不定加了剪枝，你的程序虽然还是暴力，依旧很烂，但是就是能过，因为你实际上比一般的搜索优化了不少。\",\"接下来，题单中有一些搜索的题目，解决它们的任务就交给同学们辣！\",\"注：dfs 也可以用来填充图上的连通块（这其实十分重要！）\",\"UPD(2023.9.11): 在与同学观看的时候发现了代码中的错误，已经修正，代码缩进问题无法解决（频道似乎会吞空格）。\",\"题单链接：\",\"南哪2022-6-recursion EX 搜索 - 题单 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\"]},\"36\":{\"c\":[\"CPL DotOJ 补完计划\"]},\"37\":{\"c\":[\"CPL\",\"DotOJ\"]},\"38\":{\"h\":\"南哪 2022-6-recursion\",\"t\":[\"特别提醒：第一题数据范围太大不但需要高精度而且递归会超时，会做即可 如果想要了解如何不超时 请耐心将题单简介看完\",\"各位好啊，这里是某 CQ ！\",\"这次的题单提前，因为根据了解，大部分C语言老师实际上已经讲过递归了。\",\"某 CQ 也去听了课，根据上课的速度，某 CQ 感觉各位同学对递归可能是一知半解，还没有明白递归到底是干嘛用的。\",\"某 CQ 决定提前拿出题单，选择上课提到的三个比较经典的问题，帮大家把上课内容再过一遍。\",\"说到递归，我们肯定得从斐波那契数列讲起，这个可太经典了。\",\"先把代码写在这里，具体解释在下面：\",\"int f(int n) { if (n == 1 || n == 2) { return 1; } return f(n - 1) + f(n - 2); } \",\"在其中我们可以看到，函数自己调用了自己，虽然里面的参数好像不太一样。\",\"这到底是什么意思呢？\",\"我们可以更加形象地解释一下：\",\"要推出斐波那契数列，我们肯定少不了前两项，于是：\",\"f(1)、f(2)：我们知道自己是1\",\"而当n ≥ 3时：\",\"f(n)：我是多少？我不到啊？问问f(n - 1)和f(n - 2)\",\"f(n - 1)、f(n - 2)：问问前两项\",\"……\",\"从最高层一层一层询问下去，直到达到边界，知道确定的答案之后，再一层一层回来，这便是递归的原理。\",\"而我们如何去写递归，需要搞清楚两个关键点：\",\"1、边界条件是什么：\",\"就像斐波那契数列的第一和第二项一样，我们得有最小的问题的答案，才能一层一层递归，找出结果。如果没有边界，那我们面临的将是无穷无尽的鄙视链。\",\"2、对于当前的问题，我们该怎么处理：\",\"像斐波那契数列的第n项，我们不知道它是多少，但是我们能知道它由 n - 1 和 n - 2 两个子问题构成，所以我们想知道 f(n) ，只需要知道 f(n - 1) 和 f(n - 2) 就行了，至于它们两个是怎么求出来的，这实际上并不在我们的关心范围内。\",\"注：这样做在时间上并不合理，比如说要想知道 f(6)，大家可以去算一算到底调用了多少次 f(3)。但是这对我们理解递归有很有效的帮助。\",\"UPD：加入此类递归的一种优化方法。\",\"（这次题目选炸了，忘记重新过一遍数据范围了OTZ，请各位饶了我吧）\",\"有些同学可能做了这个题单发现有些题目递归来做特别容易超时，正是因为上述原因导致我们重复去求解了明明只需要求解一次的问题。\",\"那么我们能怎么解决重复求解的问题呢？\",\"诶，我每次求解出其中一个子问题就把它存到一个数组里边，下次需要就直接拿出来用，不就行了吗？\",\"我们还是用斐波那契数列来举例子：\",\"long long f[10005]; long long fib(int n) { if (f[n] != 0) { return f[n]; } return f[n] = fib(n - 1) + fib(n - 2); } int main() { f[1] = f[2] = 1; int n; scanf(\\\"%d\\\", &n); printf(\\\"%lld\\\\n\\\", fib(n)); } \",\"这样我们便通过将已经求解过的答案存到一个数组里来避免同一个子问题的重复求解，从而能在相当于n次循环的时间内解决了这个问题。\",\"某 CQ 将这种方法不太准确地称作递归的记忆化，这是一种还算很常用的用来避免重复求解子问题的优化方法。\",\"希望同学们能够掌握这种用空间换时间的优化方法，毕竟，空间比时间更好掌握。（空间可以算，非常直观，而时间有的时候很难看出来有没有超）\",\"下面来解决一个稍微难理解一点的：汉诺塔问题\",\"我们先来找边界条件：\",\"当起始柱子上只有一个盘子的时候，直接把它挪到终点柱子就好了。竟然这么简单，某 CQ 表示这非常的难以置信。\",\"然后我们来找盘子为 n 层时的处理方法：\",\"实际上我们可以把 n 层抽象成两层：最底下的一层和上面 n - 1 层，以方便我们将 n 的问题拆分成更小的同时又是方便解决的问题。\",\"然后考虑两层：我们得先把上面那个盘子移到中间柱子上面，再把下面一个盘子移到终点柱子上，最后把中间柱子上的那个盘子移到终点柱子上，完成汉诺塔的位移。\",\"所以我们怎么具体构造这个递归呢？先给代码后解释：\",\"void hanoi(int n, char a, char b, char c) { if (n == 1) { printf(\\\"%d:%c->%c\\\", n, a, c); } else { hanoi(n - 1, a, c, b); printf(\\\"%d:%c->%c\\\", n, a, c); hanoi(n - 1, b, a, c); } } \",\"先解释一下这个函数中各个参数的含义， n 自然不用说，表示 n 层，但是如果你将 a，b，c 认作是一柱二柱三柱那格局就小了，它们应该被称作起始柱子，中间柱子和终点柱子。在递归的过程中，这三个变量的表示的柱子实际上会不断变化，因为你在一些步骤中终点柱并不是最开始的那个终点柱：比如说两层的时候，你第一步是要移到中间柱上，而不是终点柱上，中间柱才是你这一步的终点柱。\",\"首先用if特判解决掉最小的问题，我们直接输出移动方式就行了。\",\"然后关键的在下面，对于 n 层，我们先将 n - 1 层从起始柱子通过终点柱子的帮助移到中间柱子去，这之后我们将最底下的那一层移到终点柱子上，这一步可以直接输出，最后我们将这 n - 1 层从中间柱子通过起点柱子的帮助，移到终点柱子上，这就是抽象为两层的汉诺塔问题的处理方法。\",\"通过这样的处理，我们将n层的问题，转化成了一次移动和两次 n - 1 层的问题，这样层层缩小，最终变成一层的可以直接解决的问题。\",\"实际上递归就是一种量变引起质变的方式，通过不断地解决小问题，总有一天你会发现，欸，大问题好像也就这么简简单单的解决了。\",\"递归真的很好用。\",\"最后我们来简单介绍一下归并排序，这个实际上比汉诺塔问题更加好理解。不过归并的过程略微有些烧脑，某 CQ 希望各位同学自己去写一写，找到自己的方法，某 CQ 会在题单中放一道经典的需要用归并排序的问题，并且某 CQ 会在接下来的讲解中一并讲掉这题是怎么做的（当然这只是解决那道题其中的一种方法）\",\"归并排序，这个就不给代码了，同学们需要自己写一写，找到自己习惯的写法。\",\"归并排序到底是什么意思？它又到底快在哪里呢？\",\"我们先解释一下归并排序的具体原理：\",\"归并排序的目的是通过二分将整个序列的排序分成两个小序列的排序，然后通过一种特定的合并的方法将两个有序的序列合成一个有序的序列。\",\"再来具体解释一下，比如我们想要排序下标从1到n的一个数组，那么我们实际上需要排序下标 1 到 (n + 1) / 2 的数组和 (n + 1) / 2 + 1 到 n 的数组，然后将这两个数组合并成一个有序的数组。\",\"通过这样以二分的方法将数组拆分，直到将数组拆成长度为1，那这个时候它本身就是有序的，非常好，不需要排序。\",\"然后具体的合并方式实际上很好想，实现起来略有一些麻烦，某 CQ 留给大家自己去实现。\",\"至于它为什么快呢？因为每一层递归，我们实际上等价于对整个数组循环一边，将它们两两合并，也就是循环了 n 次，而将这个数组二分我们只需要分 log2(n) 次就能将它分到最小，所以我们实际上只需要 n * log2(n) 次循环就能解决这个问题，比起冒泡排序和选择排序的 n * n 次循环就快上不少。\",\"这样，同学们是不是对递归有了更深的理解？\",\"开始做题吧！不过记得，递归的题目确实有点抽象，同学们需要通过一定量的练习才能掌握的差不多，这次题目的难度可能浮动有点大，因为确实有那么一点点难挑，同学们也许需要克服一点困难。\",\"下面是归并排序的一个应用的讲解：\",\"归并排序可以用来解决逆序对问题：\",\"在一个数列中，存在 i < j, 同时 a[i] > b[j] 这时我们称 (i, j) 这个二元组为这个数列的一个逆序对。\",\"显然冒泡排序可以解决这个问题，当我们需要交换两个相邻的数时，显然这两个数构成了一个逆序对，而将一个数组变为有序数组，我们一定要解决所有的逆序对才行。\",\"但是冒泡排序太慢了，我们不想用它，怎么办？\",\"归并排序来帮你！\",\"当我们想要合并两个序列的时候，逆序对可以计算吗？\",\"这个就给个提示，不具体讲了，留给有条件的同学们自己去思考，题单里有一道这个题，可以自己去写写看。\",\"祝大家本周末以及下周的期中考试愉快！\",\"提单链接：\",\"南哪2022-6-recursion - 题单 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\"]},\"39\":{\"c\":[\"CPL DotOJ 补完计划\"]},\"40\":{\"c\":[\"CPL\",\"DotOJ\"]},\"41\":{\"h\":\"南哪 2022-7-data-types\",\"t\":[\"data-types 中提到了一些更进阶的数据类型定义方式，在这里某 CQ 将一些内容重述，以便于更好地理解。\"]},\"42\":{\"h\":\"struct\",\"t\":[\"C 语言不是一种面向对象语言，因此，它没有对象的概念，但是结构体如果用的好的话，也能够媲美对象。\",\"struct 结构体是一种复合类型，它将多个不同类型的变量组合在一起，形成一个整体。\",\"struct 类型的变量在定义时，会分配一段连续的内存空间，其中包含内部所有字段的空间。\",\"在具体使用的时候，你需要先定义结构体类型及其成员，向编译器告知，你创建了这样一个类型，然后才可以使用这个类型来定义变量：\",\"// 定义结构体类型 struct Data { int data1; char data2; double data3; }; // 定义结构体变量 struct Data data; // 使用结构体变量 data.data1 = 1; data.data2 = 'a'; data.data3 = 3.14; \",\"使用 struct 可以很方便的将多个数据打包，使得程序更加的通俗易懂。\",\"提示\",\"你也可以不给结构体名字，它将作为匿名结构体，你没法再在别处使用它，你只能在创建的时候立刻使用它：\",\"struct { int data1; char data2; double data3; } data; data.data1 = 1; // ... \",\"提示\",\"使用之前提到过的 typedef，你可以将 struct 类型重命名，这样在定义变量时，就不需要写 struct 关键字了：\",\"你可以在 typedef 定义的别名中加上 _t 后缀，表示这是 typedef 定义的类型\",\"typedef struct Data data_t; struct Data { // ... } data_t data; // ... \",\"接下来，关键的来了，我们知道 C++ 中的结构体中是可以定义方法的，那么 C 语言中有没有办法实现类似的功能呢？\",\"有的，兄弟，有的，我们可以使用函数指针来申明一些结构体成员，在创建结构体变量实例时，我们可以将函数赋值给这些成员，这样就可以实现类似的方法功能了：\",\"比如，我们创建一个 utils_t 类型，来存放一些工具函数：\",\"typedef utils utils_t // 因为只是定义，所以函数参数部分，你可以不写变量名，实现的时候还是要写的 struct utils { void (*swap) (int *, int *); int (*max) (int, int); int (*min) (int, int); } // 实现这些函数 // 为避免重名，你最好加上前缀 void utils_swap(int *a, int *b) { int tmp = *a; *a = *b; *b = tmp; } int utils_max(int a, int b) { return a > b ? a : b; } int utils_min(int a, int b) { return a < b ? a : b; } // 在使用时，动态创建 `utils_t` 实例，在使用过后也指定销毁方法 // 这样看上去麻烦，但反而更有利于代码的管理 // 比如说你需要在创建时初始化一些字段值，在销毁时做一些清理工作，这样写就会很好改动。 utils_t *create_utils() { utils_t *this = malloc(sizeof(utils_t)); this->swap = utils_swap; this->max = utils_max; this->min = utils_min; return this; } void destroy_utils(utils_t *this) { free(this); } \",\"提示\",\"上面定义的方法都相当于是静态方法，这些方法不会与实例进行交互，如果一些方法涉及到与结构体实例发生交互，你只能通过传入实例来实现，像这样：\",\"typedef struct Dog dog_t struct Dog { int age; void (*grow) (dog_t *); } // 使用 `this`，让含义更贴近面向对象表达 void dog_grow(dog_t* this) { this->age += 1; } // ... // 使用 dog.grow(&dog); \"]},\"43\":{\"h\":\"union\",\"t\":[\"union 联合体，与 struct 结构体类似，但是它只能存放一种数据类型，而且所有字段共享同一块内存空间，因此，联合体的大小等于其中最大的字段的大小。\",\"联合体通常用于存储一些互斥的数据，比如，一个变量，它可能是整数，也可能是浮点数，也可能是字符，那么就可以使用联合体来存储，这样在存储时，只需要分配一块内存空间即可。\",\"union Data { int data1; char data2; double data3; }; union Data data; data.data1 = 1; // 此时，data2 和 data3 的值将不可预测 data.data2 = 'a'; // 此时，data1 和 data3 的值将不可预测 data.data3 = 3.14; // 此时，data1 和 data2 的值将不可预测 \",\"union 只是一种辅助手段，如果滥用，他只会严重破坏代码的可读性。你只应当在清楚自己到底在做什么的时候使用它。\",\"题单链接：\",\"南哪2022-7-data-types - 题单 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\",\"这次只有三道题\"]},\"44\":{\"c\":[\"CPL DotOJ 补完计划\"]},\"45\":{\"c\":[\"CPL\",\"DotOJ\"]},\"46\":{\"h\":\"南哪 2022-8-pointer EX 手搓链表\",\"t\":[\"链表在需要节省内存空间，同时不需要进行随机寻址操作时（也就是使用数组下标那种方式快速访问其中的任意一个元素），是非常优秀的数据结构。\",\"要想看懂它，实际上一段代码就足够：\",\"#include <stdio.h> #include <stdlib.h> // 链表的特点在于它占用的内存不像数组那样是连续的， // 这也正导致了链表需要更多的内存用来记录与某一个节点相连的其他节点，且不能直接调用链表当中某个元素的值 // 但是链表的好处在于它的内存是动态的，而且从头到尾顺序访问并不受影响 // 单独链表的应用范围，抛开没有不谈，还是有一点的 // 比如说某些非逼你需要动态维护数组大小的（我不说是哪道题，自己心里清楚 // 单个链表节点，这里演示的是两个方向都能查找的链表 typedef struct list_node list_node_t; struct list_node { int data; list_node_t *prev, *next; }; // 在pos指向的元素之后添加一个新的元素 void add(list_node_t *pos, int data) { list_node_t *node = malloc(sizeof(list_node_t)); node->prev = pos; node->next = pos->next; if (pos->next != NULL) pos->next->prev = node; pos->next = node; node->data = data; } // 删除pos指向的元素 void del(list_node_t *pos) { if (pos->prev != NULL) pos->prev->next = pos->next; if (pos->next != NULL) pos->next->prev = pos->prev; free(pos); } int main() { // 新建一个节点指向链表的开头以方便链表的遍历和添加删除。 list_node_t *list = malloc(sizeof(list_node_t)); list->prev = NULL; list->next = NULL; list->data = 114514; return 0; } // 代码未经检查，如果有误自己去改，意思到了（ \",\"题单链接：\",\"南哪2022-8-pointer EX 手搓链表 - 题单 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\",\"然而这也没有题……\"]},\"47\":{\"c\":[\"CPL DotOJ 补完计划\"]},\"48\":{\"c\":[\"CPL\",\"DotOJ\"]},\"49\":{\"h\":\"南哪 2022-8-pointer EX 动态数组\",\"t\":[\"这次我们介绍一个很方便但是在 C 语言当中依然用起来有些难度的东西——动态数组。\",\"行向量 vector，在 C++STL 当中有它，但我们更习惯称它位动态数组，它的特点就是能够动态分配数组的内存，方便我们应对未知数据量的问题。\",\"这么好用？不，它虽然优化了空间，但它也用掉了一部分的时间用来维护这个动态数组。不过总体上来说，这个动态数组还是很推荐学一学，用一用的。\",\"（有些人特别钟爱用 vector 存图，时间常数大的起飞，我不说是谁（︶^︶））\",\"接下来就大概的看一看实现的代码，相信加上注释和清晰的变量命名，你们应该能看懂。\",\"这次依旧没有经过检查，所以直接抄代码请你谨慎。\",\"#include <stdio.h> #include <stdlib.h> #include <string.h> // 建立一个行向量结构体，里面存三个指针 struct Vector { // 指向数组开头 int* begin; // 指向数组结尾 int* end; // 指向内存结尾 int* endOfStorage; }vec; // 初始化动态数组 void initialize() { vec.begin = vec.end = vec.endOfStorage = NULL; } // 删除这个动态数组，释放内存 void destroy() { free(vec.begin); } // 返回指向数组开头的指针 int* begin() { return vec.begin; } // 返回指向数组结尾的指针 int* end() { return vec.end; } // 返回当前数组大小 int size() { return vec.end - vec.begin; } // 返回当前数组容量 int capacity() { return vec.endOfStorage - vec.begin; } // 特别提醒，为了节约时间成本 // 每次扩容时会把容量多扩一些 // 因为每次扩容都需要重新申请一段内存，然后把原来的移过来 // 所以这里的容量和数组大小并不相同 // 将容量扩充至 n，如果当前容量不够需要重新申请内存 void reserve(int n) { if (n > capacity()) { int* tmp = malloc(n * sizeof(int)); int sz = size(); if (vec.begin) { for (int i = 0; i < sz; ++i) tmp[i] = vec.begin[i]; free(vec.begin); } vec.begin = tmp; vec.end = vec.begin + sz; vec.endOfStorage = vec.begin + n; } } // 改变数组长度至 n，其中未定义的数组元素会被赋值成 val void resize(int n, int val) { if (n > capacity()) reserve(n); for (int i = size(); i < n; ++i) vec.begin[i] = val; vec.end = vec.begin + n; } // 在数组尾部添加一个元素，值为 val void push_back(int val) { if (size() == capacity()) { int newcapacity = size() == 0 ? sizeof(int) : capacity() * 2; reserve(newcapacity); } *vec.end = val; ++vec.end; } void pop_back()// 在数组尾部删除一个元素 { if (size() > 0) --vec.end; } // 在数组的第 pos 位插入一个元素，值为val void insert(int pos, int val) { if (vec.end == vec.endOfStorage) reserve(size() + 1); for (int i = size(); i > pos; --i) *(vec.begin + i) = *(vec.begin + i - 1); *(vec.begin + pos) = val; ++vec.end; } // 删除数组的第 pos 位元素 void erase(int pos) { for (int i = size(); i > pos; --i) *(vec.begin + i - 1) = *(vec.begin + i); --vec.end; } // 获取数组的第 pos 位元素 int get(int pos) { return *(vec.begin + pos); } int main(int argc, char *argv[]) { initialize(); int x; scanf(\\\"%d\\\", &x); push_back(x); push_back(x); pop_back(); insert(0, 1); erase(0); destroy(); return 0; } \",\"注意\",\"在之后的 C++ 高级程序设计 课程作业中会出现这个数据结构！\",\"我警告过你了！\",\"题单链接：\",\"南哪2022-8-pointer EX 动态数组 - 题单 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\",\"这次还是没有题目做……\"]},\"50\":{\"c\":[\"CPL DotOJ 补完计划\"]},\"51\":{\"c\":[\"CPL\",\"DotOJ\"]},\"52\":{\"h\":\"南哪 2022-8-pointer\",\"t\":[\"这一章的内容实际上在题单《逃不掉的语法小技巧 指针》当中已经讲的差不多了，不过我们在这里还需要补充一些东西。\",\"在上一次介绍中我们在文末说到了这样一段话：\",\"顺带一提，我们知道数组的名字就是指向它第一个元素的指针，那么数组到底是什么意思呢？\",\"原来，数组后面方括号里面的数字实际上指的是相对于这个数组指针在内存上的偏移值，偏移 0 那就是第一个元素，偏移 1 那就是第二个元素，以此类推。\",\"由这句话我们知道了数组名字是个指针，而且它实际上指向了数组的第一个元素。\",\"我们都清楚这次的 OJ 十分的阴间，不允许使用 [] 来调用数组的某一位，甚至不让用 [] 开数组。\",\"这怎么能忍！这就告诉你们 dotOJ 究竟在搞什么花样！\",\"在第二题当中，我们需要开一个长度为 100000 的字符数组，我们就拿它来举例。\",\"首先，我们使用malloc来申请内存，具体如下：\",\"//别忘了包含stdlib.h char *s = (char *)malloc(100000 * sizeof(char)); \",\"申请完以后我们就可以使用s[i]来调用s数组的第i位了，但是显然题目不允许我们这样做，怎么办呢？\",\"我们注意到上面的malloc申请的实际上是一段连续的内存（不然没法调用数组的任意一个位置），所以我们可以尝试修改指针指向的地址来访问这个数组的任意一个位置。\",\"比如说我们想要输出这个字符数组：\",\"int len = strlen(s); for (int i = 0; i < len; ++i) putchar(*(s + i));//相当于s[i] putchar('\\\\n'); \",\"虽然这很好理解，但抛开好理解不谈，我们还是得好好理解为什么可以这样写（\",\"当然还有第一题我们需要提到的指针问题：\",\"既然存储数据都是 32 位，那么我们为什么不用不同的指针指向同一个 32 位呢？\",\"而且题目也解释的很清楚，一开始只是平平无奇的一个 int，你只需要一位一位读入二进制然后把它弄到一个 int 里面\",\"当然，实际上建议弄到 unsigned int 里面先搞，因为如果你没有学过之前学到的位运算，单纯用加法的话，int 的符号位可能会让你很头疼。\",\"当我们搞好这个 unsigned int 变量的值，我们用不同数据类型的指针指向这个变量（当然都需要是 32 位存储的变量）\",\"也就是分别用一个 int、一个 unsigned int、一个 float 指针指向这个 unsigned int 变量的存储位置，然后分别按要求输出就行了。\",\"这样做的原理是什么呢？\",\"因为内存总归是一位一位的，它很实在不会骗你，但是不同的变量类型理解内存上每一位的方式不一样，导致最终的结果就不一样。所以说，当我们用不同变量类型的指针指向同一个 32 位内存，它们理解内存的方式不同，导致你输出它们指向的变量的结果也就不同，这就是第一题想考察的地方。\",\"指针真的就没有了，如果想寻求些挑战，你可以去看看之后出来的指针EX。\",\"题单链接：\",\"南哪2022-8-pointer - 题单 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\",\"然而并没有题可以写（\"]},\"53\":{\"c\":[\"CPL DotOJ 补完计划\"]},\"54\":{\"c\":[\"CPL\",\"DotOJ\"]},\"55\":{\"h\":\"某 CQ の奇妙冒险\",\"t\":[\"某CQの奇妙冒险 - 题单 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\"]},\"56\":{\"c\":[\"CPL DotOJ 补完计划\"]},\"57\":{\"c\":[\"CPL\",\"DotOJ\"]},\"58\":{\"h\":\"逃不掉的语法小技巧 指针\",\"t\":[\"指针是 C 语言的核心技巧，通过指针，我们可以实现很多高级功能，比如动态内存分配、函数指针、回调函数等等。但是指针也是 C 语言中最容易出错的地方，因为指针的操作非常复杂，一不小心就会出错。本文将介绍一些指针的语法小技巧，帮助大家更好地理解和掌握指针。\",\"取地址：\",\"当我们想要获取某个变量的地址，首先找到这个变量的变量名，我们假设它是 a，如果你在这个变量名前面加上&（&a），那么恭喜你，你成功的取出了 a 这个变量的地址。\",\"特别地，如果是一个数组，那么它的数组名就是指向它第一个元素的地址，这也是为什么 scanf 数组的时候不要加 &\",\"存地址：\",\"现在你成功的取出了某个变量的地址（假设是一个int变量），你现在想把它存下来，以方便在其它函数里面找到这个变量，怎么办呢？\",\"你可以用 int *p；来新建一个指向 int 的指针变量。\",\"这里的 * 号指的是你告诉编译器你新建的变量是一个指针类型，这点要注意，因为一会这个符号还有另一个含义。\",\"提示\",\"我们建立的是指针变量，它本质上是一个存储地址的变量。\",\"用地址：\",\"我们现在得到了变量 a 的地址，并把它存在了 p1 这个指针变量里面。我们怎么来使用 p1 呢？\",\"这里我们又要用到 * 号\",\"当我们在定义过 p1 指针后再次使用 *p1，它的含义就发生了改变。\",\"这里的 *p1 指的是 p1 这个指针指向的变量，也就是说——\",\"*p1 实际上指的就是 a ，无论你在什么地方修改了它的值，a 的值也会随之发生改变。\",\"那么借助指针的这个性质，我们可以写一些更方便的函数来让我们的代码更加简洁。\",\"比如交换两个数，这个操作在某些问题中很常用，我相信大家都不想到处花上好几行的代码来实现它，那么我们可以这样写：\",\"void swap(int *a, int *b) { int t = *a; *a = *b; *b = t; } // 在main函数中↓ int a = 1, int b = 2; swap(&a, &b); // 结果：a = 2, b = 1 \",\"通过使用指针，我们可以利用这个swap函数来将某个和这个函数没有半毛钱关系的变量交换值。\",\"开一个指定大小的连续空间（以 Byte 为单位）：\",\"翻找 C Reference 我们可以找到 malloc 这个函数和 free 这个函数，这两种函数是我们经常可能要用到的。\",\"为什么要用 malloc 和 free 呢？\",\"我们知道，当你想根据输入的值来确定你的数组大小时，你必须得在确定了输入之后再新建数组，然而，这也意味着你的数组在新建时就受限于当前作用域，当这个函数结束，新建的数组就失效了。此时，如果你还在别处需要这个数组，你便没有办法再获得它了。\",\"所以，我们用 malloc 来向编译器申请一段内存空间，大小可以由你自己指定，它会将一段空间分配给你，并返回这段空间的首地址。这段空间来自堆空间，它不会受限于当前作用域，除非你在别处用 free 释放了它，否则它会一直存在。\",\"注意\",\"申请指针必须有始有终，否则会导致内存泄露（产生了大量的无效内存占用）！如果你发现你的程序越跑越慢，还关不掉，指不定就是内存泄露了！\",\"比如说，你想要申请一个 int 变量和一个大小为 n 的 int 数组，你可以这样写：\",\"int *p1 = (int *)malloc(sizeof(int)); int *p2 = (int *)malloc(sizeof(int) * n); \",\"注意，malloc 返回的是一个 void * 类型的指针，所以我们需要把它强制类型转换为 int * 类型的指针，否则编译器会报错。\",\"提示\",\"此时 p1 和 p2 的变量类型是一样的，但 p2 指向的是一段内存空间的首地址，你可以把它当作数组使用，但 p1，虽然你也可以把它当作只有一个元素的数组使用，但实际上和单个 int 变量的指针没有区别。\",\"当你使用完了之后，记得用 free 释放它：\",\"free(p1); free(p2); \",\"提示\",\"free 释放的是指针指向的内存空间，而不是指针本身！为了避免出现野指针，你一定要记得把指针空置！这是好习惯！\",\"p1 = NULL; p2 = NULL; \",\"顺带一提，我们知道数组的名字就是指向它第一个元素的指针，那么数组到底是什么意思呢？\",\"原来，数组后面方括号里面的数字实际上指的是相对于这个数组指针在内存上的偏移值，偏移0那就是第一个元素，偏移1那就是第二个元素，以此类推。\",\"也就是说，下面 if 中等号两侧这两种表达是等价的：\",\"int *p = malloc(sizeof(int) * n); if (*(p + 2) == p[2]) { // do something } \",\"题单链接（但是没有题）：逃不掉的语法小技巧 指针 - 题单 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\"]},\"59\":{\"c\":[\"CPL DotOJ 补完计划\"]},\"60\":{\"c\":[\"CPL\",\"DotOJ\"]},\"61\":{\"h\":\"1. SFML 简介和环境配置\",\"t\":[\"又到了和 SDL 一样痛苦的配环境环节！\",\"SFML (Simple and Fast Multimedia Library) 是一款非常好用的图形界面库，你用得到的功能（包括网络），它基本上都考虑到了。而且它具有非常良好的跨平台能力，它在各大平台上都能顺利地运行，且能够完美地适配不同的屏幕分辨率和尺寸，能让你获得最舒适的游戏体验。\",\"（所以为什么不用 Godot Engine 或者 Cocos2D 之类的呢？）\",\"我可不管，我就想用这个。\",\"另外学这个得先会点 C++。\",\"环境配置：\",\"MacOS：\",\"没用过，我不知道，我不会。\",\"Linux（Ubuntu为例）：\",\"这还用配环境？打开你的命令行\",\"sudo apt install libsfml-dev \",\"完成了，用 vscode 或者 clion 都行，只需要配置好编译命令或者 CmakeLists.txt 就行了\",\"提示\",\"也可以使用 xmake，用起来爽到高超！\",\"Windows： 把 sfml 包下下来，照着 SDL 类似的方法配置吧\",\"SFML 官网：https://sfml-dev.org\"]},\"62\":{\"c\":[\"C++ SFML\"]},\"63\":{\"c\":[\"C++\",\"SFML\"]},\"64\":{\"h\":\"2. 基础又经典的游戏结构理解\",\"t\":[\"搭配上SFML的内容，我们先写出类似学习SDL时的游戏结构：\",\"这件事做起来很轻松，不是吗？\",\"但是，这并不是很好看。我们为什么不把它重新包装一下，让它更好理解呢？这样如何？\",\"我们尽量把这些过程都拆开，分而治之，不然到时候很有可能搞不清自己到底在做什么。\",\"具体的函数实现就不放在这了，你自己心里面应该有数。\",\"这只是第一步，但是已经能足够我们写一些简单的东西了。\",\"在这之后我们将造出一系列轮子，最后再将他们拼接到一起，构建出我们想要的，更方便的游戏结构。\"]},\"65\":{\"c\":[\"C++ SFML\"]},\"66\":{\"c\":[\"C++\",\"SFML\"]},\"67\":{\"h\":\"3. 更轻松地存取文件，并尽可能阻止内存泄露\",\"t\":[\"把文件一个一个声明并且读入固然十分有效，但是太麻烦了，根本不好用。\",\"所以为什么我们不自己写一个类，让他来控制所有文件的存取呢？我们可以给每一个加载的内容都带上一个特殊的id，想要的时候再通过id把它取出来，这样既能保证文件只被加载一次，同时也能让存取的步骤更加的简单：\",\"load函数的实现：\",\"get函数的实现：\",\"为什么要准备两种load：\",\"用于视觉特效的sf::Shader的加载方式为：\",\"可以看到它在加载的过程中需要不止一个参数，所以再准备一个load以备不时之需。\",\"不支持的类型？： 由于sf::Music打开方式的特殊性（这里暂且不提），它的加载函数为openFromFile(path)而不是loadFromFile(path)。所以无法在这里加载，不过我们也并不会在ResourceHolder里面加载这种文件，我们显然需要一个单独的东西来处理游戏音乐和音效的。\"]},\"68\":{\"c\":[\"C++ SFML\"]},\"69\":{\"c\":[\"C++\",\"SFML\"]},\"70\":{\"h\":\"(4.5). 再看一眼 4 里面遗漏的东西\",\"t\":[\"有的时候我们还是需要获取某个东西的绝对位置，以方便我们进行碰撞检测等操作，所以，我们需要根据4中的树形编排方式再实现一点点东西：\",\"这样我们就也可以很轻松地借助相对位置得到绝对位置了。\"]},\"71\":{\"c\":[\"C++ SFML\"]},\"72\":{\"c\":[\"C++\",\"SFML\"]},\"73\":{\"h\":\"4. 更好的画面编排方式！\",\"t\":[\"在游戏中我们时常能见到某个实体围绕另一个实体做运动，它实际上是以这个被围绕的实体为参照的相对位置，如果直接使用绝对位置来计算固然可以，但是十分麻烦。比如某游戏中主角有一个闪电球始终环绕着旋转，这时我们既要考虑主角的运动情况，还要考虑到球绕着主角的旋转情况，计算起来非常地繁琐。\",\"又没有更好的方法可以解决这个问题呢？\",\"我们可以用“树”的结构来解决这个问题，依照上文的例子，我们把闪电球作为子节点连接到主角上，这时，我们便只需要考虑球的旋转就行，其他的位置已经由主角决定好，就相当于，坐标的变换从父节点到子节点一路叠Buff，用这种结构，我们甚至能为这个闪电球再添加围绕它的别的什么球。\",\"每个节点的性质需要能被绘制、能做坐标系上的变换，不能被随便拷贝（防止内存泄漏），所以最后得出的结构是这样的：\",\"实现：\",\"顺便，我们借着SceneNode顺便实现一下实体类（Entity），它只需要负责所有实体都会做的事情：运动。\",\"具体实现非常弱智，就不放了。\"]},\"74\":{\"c\":[\"C++ SFML\"]},\"75\":{\"c\":[\"C++\",\"SFML\"]},\"76\":{\"h\":\"5. 指令系统，不算高效但是更方便的游戏更新策略\",\"t\":[\"在游戏每帧的更新过程中对所有不同类型的实体，还有背景、GUI等进行更新是在是太麻烦了，而且，除了之前写好的SceneNode之外，你还需要东西来分类存储他们。 那太麻烦了，不好用，又没有更简单的？\",\"我们引入指令系统，将指令传入整棵树，让它自行选取符合条件的实体进行更新。每帧我们根据用户的输入情况以及游戏的整体情况决定需要进行哪些更新，然后往里面扔就完事了！\",\"这几样东西一摆，不说也应该知道干啥了吧？\"]},\"77\":{\"c\":[\"C++ SFML\"]},\"78\":{\"c\":[\"C++\",\"SFML\"]},\"79\":{\"h\":\"6. StateStack，游戏场景随便 push！\",\"t\":[\"我们都知道，我们游戏的场景之间的切换，都是依靠一个栈来实现。一个很简单的例子，当你启动游戏的时候，将标题画面的内容压入一个栈，当你选择开始游玩，将游戏的内容继续压入，当你结束游戏，游戏内容从栈中弹出，这时你又会重新看到原来的那个标题画面，我们想要达成这个简单的压入弹出。\",\"那想法就很简单了，写一个栈！然后把各种界面都整成同一种通用类型的子类往里面压入不就完事了？行，开写。\",\"StateStack 类：\",\"还有 State 类：\",\"照着写就完事了。\",\"不过有需要注意的一点：\",\"当游戏画面渲染的时候，我们有时想要让下层的界面也要显示出来，比如游戏暂停的时候，我们只是想不允许下一层内容更新，但是在画面上我们仍想要看到下一层内容，因为我们想要的暂停效果只不过是给画面蒙上一层灰色透明的长方形，然后在正当中贴上一个 PAUSE 而已。\",\"这时候 State 里面 update 和 handleEvent 以及 isLowerStateVisible 返回的 bool 内容就能派上用场了：\",\"draw 确实比较麻烦，因为它需要从下往上画，我们得先清楚我们要从哪里开始画：\"]},\"80\":{\"c\":[\"C++ SFML\"]},\"81\":{\"c\":[\"C++\",\"SFML\"]},\"82\":{\"h\":\"7. 音乐播放器，轻松拿捏游戏音乐和音效\",\"t\":[\"为了让我们能够很轻松地用简单的几句话控制音乐的播放、音量还有暂停，以及游戏音效的随意施放，我们有必要写两个类来分别处理音乐和音效：\",\"先给自己准备好的每一个音乐都准备好独特的id，在这里我们实际上还没有准备任何的音乐，所以我们这里只放上一个MusicCount用来占位。\",\"然后就是MusicPlayer类：\",\"在这里需要注意的是，音乐和其它文件是不一样的，音乐文件一般比较大，因为音乐很长，所以SFML的打开方式并不是像其他类型的文件一样，而是根据音乐播放的进度选取文件当中的某一段读入，在之后销毁掉换成另一段，也就是说这个音乐播放时需要保证文件一直能够访问到。\",\"此外是SoundPlayer：\",\"同理先记id\",\"在这里特别需要注意的是，游戏音效往往是有位置的，不仅仅是 3D 游戏会有声音随着位置改变，2D 游戏也是一样。一种理解是根据主角位置的不同将其他物体发出的声音按照方向环绕在玩家耳边，另一种理解是玩家坐在电脑面前，相当于在一张二维平面图上方一定距离处，在这个平面上不同位置发出的声音，玩家听到的感觉肯定也不一样。\",\"所以在写 SoundPlayer 的时候要特别注意这点。\",\"SFML Game Development 这本书为我们提供了非常合适的常量，我们直接用上：\",\"然后在播放的时候指定播放的位置。\",\"别忘了每次更新的时候要把已经播放完的音效清除。 这样就完成了对音乐和音效的播放的类的编写。\"]},\"83\":{\"c\":[\"C++ SFML\"]},\"84\":{\"c\":[\"C++\",\"SFML\"]},\"85\":{\"h\":\"\",\"t\":[\"404 Not Found\"]},\"86\":{\"h\":\"C 语言学习分享\"},\"87\":{\"h\":\"Dot OJ 补完计划\"},\"88\":{\"h\":\"C SFML 游戏开发\"}},\"dirtCount\":0,\"index\":[[\"玩家听到的感觉肯定也不一样\",{\"1\":{\"82\":1}}],[\"另一种理解是玩家坐在电脑面前\",{\"1\":{\"82\":1}}],[\"另外学这个得先会点\",{\"1\":{\"61\":1}}],[\"另外需要提醒的一点就是\",{\"1\":{\"35\":1}}],[\"另外\",{\"1\":{\"32\":1}}],[\"另外某\",{\"1\":{\"20\":1}}],[\"另外一种可能导致时间超限的原因可能是无限递归或者死循环\",{\"1\":{\"11\":1}}],[\"此外是soundplayer\",{\"1\":{\"82\":1}}],[\"此时记得要把当前的标记去除\",{\"1\":{\"35\":1}}],[\"此时\",{\"1\":{\"14\":2,\"43\":3,\"58\":2}}],[\"音乐文件一般比较大\",{\"1\":{\"82\":1}}],[\"音乐和其它文件是不一样的\",{\"1\":{\"82\":1}}],[\"音乐播放器\",{\"0\":{\"82\":1}}],[\"音量还有暂停\",{\"1\":{\"82\":1}}],[\"轻松拿捏游戏音乐和音效\",{\"0\":{\"82\":1}}],[\"轻量\",{\"1\":{\"14\":1}}],[\"确实比较麻烦\",{\"1\":{\"79\":1}}],[\"写一个栈\",{\"1\":{\"79\":1}}],[\"写出这样的代码具体改变了什么呢\",{\"1\":{\"20\":1}}],[\"写出更好看的代码格式\",{\"1\":{\"20\":1}}],[\"游戏开发\",{\"0\":{\"88\":1}}],[\"游戏也是一样\",{\"1\":{\"82\":1}}],[\"游戏会有声音随着位置改变\",{\"1\":{\"82\":1}}],[\"游戏音效往往是有位置的\",{\"1\":{\"82\":1}}],[\"游戏内容从栈中弹出\",{\"1\":{\"79\":1}}],[\"游戏场景随便\",{\"0\":{\"79\":1}}],[\"运动\",{\"1\":{\"73\":1}}],[\"运算符的话\",{\"1\":{\"23\":1}}],[\"防止内存泄漏\",{\"1\":{\"73\":1}}],[\"坐标的变换从父节点到子节点一路叠buff\",{\"1\":{\"73\":1}}],[\"依照上文的例子\",{\"1\":{\"73\":1}}],[\"依旧很烂\",{\"1\":{\"35\":1}}],[\"树\",{\"1\":{\"73\":1}}],[\"计算起来非常地繁琐\",{\"1\":{\"73\":1}}],[\"计算机科学教育新生态\",{\"1\":{\"17\":1,\"20\":1,\"23\":1,\"26\":1,\"29\":1,\"32\":1,\"35\":1,\"38\":1,\"43\":1,\"46\":1,\"49\":1,\"52\":1,\"55\":1,\"58\":1}}],[\"根本不好用\",{\"1\":{\"67\":1}}],[\"根据上课的速度\",{\"1\":{\"38\":1}}],[\"根据\",{\"1\":{\"20\":1}}],[\"更好的画面编排方式\",{\"0\":{\"73\":1}}],[\"更轻松地存取文件\",{\"0\":{\"67\":1}}],[\"更方便的游戏结构\",{\"1\":{\"64\":1}}],[\"更新答案\",{\"1\":{\"35\":1}}],[\"搭配上sfml的内容\",{\"1\":{\"64\":1}}],[\"基础又经典的游戏结构理解\",{\"0\":{\"64\":1}}],[\"官网\",{\"1\":{\"61\":1}}],[\"官网上提供了详尽的解决方案\",{\"1\":{\"14\":1}}],[\"照着写就完事了\",{\"1\":{\"79\":1}}],[\"照着\",{\"1\":{\"61\":1}}],[\"把文件一个一个声明并且读入固然十分有效\",{\"1\":{\"67\":1}}],[\"把\",{\"1\":{\"61\":1}}],[\"把一些繁复的语句打包\",{\"1\":{\"32\":1}}],[\"都是依靠一个栈来实现\",{\"1\":{\"79\":1}}],[\"都行\",{\"1\":{\"61\":1}}],[\"都会自动跳过空白符和一些无关的特殊字符\",{\"1\":{\"2\":1}}],[\"打开你的命令行\",{\"1\":{\"61\":1}}],[\"打上标记\",{\"1\":{\"35\":1}}],[\"环境配置\",{\"1\":{\"61\":1}}],[\"包下下来\",{\"1\":{\"61\":1}}],[\"包括网络\",{\"1\":{\"61\":1}}],[\"包都在\",{\"1\":{\"14\":1}}],[\"又没有更简单的\",{\"1\":{\"76\":1}}],[\"又没有更好的方法可以解决这个问题呢\",{\"1\":{\"73\":1}}],[\"又到了和\",{\"1\":{\"61\":1}}],[\"又是我\",{\"1\":{\"35\":1}}],[\"记得用\",{\"1\":{\"58\":1}}],[\"记好某\",{\"1\":{\"35\":1}}],[\"产生了大量的无效内存占用\",{\"1\":{\"58\":1}}],[\"申请指针必须有始有终\",{\"1\":{\"58\":1}}],[\"申请完以后我们就可以使用s\",{\"1\":{\"52\":1}}],[\"释放的是指针指向的内存空间\",{\"1\":{\"58\":1}}],[\"释放它\",{\"1\":{\"58\":1}}],[\"释放了它\",{\"1\":{\"58\":1}}],[\"释放内存\",{\"1\":{\"49\":1}}],[\"新建的数组就失效了\",{\"1\":{\"58\":1}}],[\"新建一个节点指向链表的开头以方便链表的遍历和添加删除\",{\"1\":{\"46\":1}}],[\"新建一个文件\",{\"1\":{\"8\":1}}],[\"翻找\",{\"1\":{\"58\":1}}],[\"呢\",{\"1\":{\"58\":2}}],[\"现在你成功的取出了某个变量的地址\",{\"1\":{\"58\":1}}],[\"现在我们需要解决斜角上冲突的问题\",{\"1\":{\"35\":1}}],[\"现在我们所在的是\",{\"1\":{\"17\":1}}],[\"帮助大家更好地理解和掌握指针\",{\"1\":{\"58\":1}}],[\"帮大家把上课内容再过一遍\",{\"1\":{\"38\":1}}],[\"本文将介绍一些指针的语法小技巧\",{\"1\":{\"58\":1}}],[\"本周作业\",{\"1\":{\"32\":1}}],[\"回调函数等等\",{\"1\":{\"58\":1}}],[\"の奇妙冒险\",{\"0\":{\"55\":1}}],[\"既然存储数据都是\",{\"1\":{\"52\":1}}],[\"究竟在搞什么花样\",{\"1\":{\"52\":1}}],[\"开写\",{\"1\":{\"79\":1}}],[\"开一个指定大小的连续空间\",{\"1\":{\"58\":1}}],[\"开数组\",{\"1\":{\"52\":1}}],[\"开始做题吧\",{\"1\":{\"38\":1}}],[\"开始\",{\"1\":{\"20\":1}}],[\"由于sf\",{\"1\":{\"67\":1}}],[\"由这句话我们知道了数组名字是个指针\",{\"1\":{\"52\":1}}],[\"由此可知\",{\"1\":{\"17\":1}}],[\"偏移1那就是第二个元素\",{\"1\":{\"58\":1}}],[\"偏移0那就是第一个元素\",{\"1\":{\"58\":1}}],[\"偏移\",{\"1\":{\"52\":2}}],[\"原来\",{\"1\":{\"52\":1,\"58\":1}}],[\"原理同上\",{\"1\":{\"35\":1}}],[\"顺便\",{\"1\":{\"73\":1}}],[\"顺带一提\",{\"1\":{\"52\":1,\"58\":1}}],[\"顺序也不能错\",{\"1\":{\"17\":1}}],[\"逃不掉的语法小技巧\",{\"0\":{\"58\":1},\"1\":{\"52\":1,\"58\":1}}],[\"课程作业中会出现这个数据结构\",{\"1\":{\"49\":1}}],[\"高级程序设计\",{\"1\":{\"49\":1}}],[\"获取数组的第\",{\"1\":{\"49\":1}}],[\"改变数组长度至\",{\"1\":{\"49\":1}}],[\"返回的\",{\"1\":{\"79\":1}}],[\"返回的是一个\",{\"1\":{\"58\":1}}],[\"返回当前数组容量\",{\"1\":{\"49\":1}}],[\"返回当前数组大小\",{\"1\":{\"49\":1}}],[\"返回指向数组结尾的指针\",{\"1\":{\"49\":1}}],[\"返回指向数组开头的指针\",{\"1\":{\"49\":1}}],[\"返回了\",{\"1\":{\"35\":1}}],[\"删除数组的第\",{\"1\":{\"49\":1}}],[\"删除这个动态数组\",{\"1\":{\"49\":1}}],[\"删除pos指向的元素\",{\"1\":{\"46\":1}}],[\"初始化动态数组\",{\"1\":{\"49\":1}}],[\"建立一个行向量结构体\",{\"1\":{\"49\":1}}],[\"建议放到最后做\",{\"1\":{\"35\":1}}],[\"方便我们应对未知数据量的问题\",{\"1\":{\"49\":1}}],[\"行\",{\"1\":{\"79\":1}}],[\"行向量\",{\"1\":{\"49\":1}}],[\"行末的空格最好别有\",{\"1\":{\"8\":1}}],[\"行末有一个换行符\",{\"1\":{\"2\":1}}],[\"动态数组\",{\"0\":{\"49\":1},\"1\":{\"49\":2}}],[\"动态创建\",{\"1\":{\"42\":1}}],[\"然而\",{\"1\":{\"58\":1}}],[\"然而并没有题可以写\",{\"1\":{\"52\":1}}],[\"然而这也没有题\",{\"1\":{\"46\":1}}],[\"然后在播放的时候指定播放的位置\",{\"1\":{\"82\":1}}],[\"然后在正当中贴上一个\",{\"1\":{\"79\":1}}],[\"然后就是musicplayer类\",{\"1\":{\"82\":1}}],[\"然后就是每一个子问题的具体求解\",{\"1\":{\"35\":1}}],[\"然后把各种界面都整成同一种通用类型的子类往里面压入不就完事了\",{\"1\":{\"79\":1}}],[\"然后把原来的移过来\",{\"1\":{\"49\":1}}],[\"然后往里面扔就完事了\",{\"1\":{\"76\":1}}],[\"然后分别按要求输出就行了\",{\"1\":{\"52\":1}}],[\"然后才可以使用这个类型来定义变量\",{\"1\":{\"42\":1}}],[\"然后具体的合并方式实际上很好想\",{\"1\":{\"38\":1}}],[\"然后将这两个数组合并成一个有序的数组\",{\"1\":{\"38\":1}}],[\"然后将它们组合起来解决整个问题\",{\"1\":{\"32\":1}}],[\"然后通过一种特定的合并的方法将两个有序的序列合成一个有序的序列\",{\"1\":{\"38\":1}}],[\"然后关键的在下面\",{\"1\":{\"38\":1}}],[\"然后考虑两层\",{\"1\":{\"38\":1}}],[\"然后我们来找盘子为\",{\"1\":{\"38\":1}}],[\"然后返回去找别的填数的可能\",{\"1\":{\"35\":1}}],[\"然后判断p\",{\"1\":{\"32\":1}}],[\"然后是这个函数的名字\",{\"1\":{\"32\":1}}],[\"然后再去看你的代码\",{\"1\":{\"14\":1}}],[\"然后以\",{\"1\":{\"11\":1}}],[\"然后\",{\"1\":{\"11\":1}}],[\"然后当你按下任意按钮以后它会继续生成新数据\",{\"1\":{\"8\":1}}],[\"意思到了\",{\"1\":{\"46\":1}}],[\"代码未经检查\",{\"1\":{\"46\":1}}],[\"代码缩进问题无法解决\",{\"1\":{\"35\":1}}],[\"单纯用加法的话\",{\"1\":{\"52\":1}}],[\"单个链表节点\",{\"1\":{\"46\":1}}],[\"单独链表的应用范围\",{\"1\":{\"46\":1}}],[\"抛开没有不谈\",{\"1\":{\"46\":1}}],[\"且能够完美地适配不同的屏幕分辨率和尺寸\",{\"1\":{\"61\":1}}],[\"且不能直接调用链表当中某个元素的值\",{\"1\":{\"46\":1}}],[\"且这个\",{\"1\":{\"23\":1}}],[\"链表的特点在于它占用的内存不像数组那样是连续的\",{\"1\":{\"46\":1}}],[\"链表在需要节省内存空间\",{\"1\":{\"46\":1}}],[\"手搓链表\",{\"0\":{\"46\":1},\"1\":{\"46\":1}}],[\"与\",{\"1\":{\"43\":1}}],[\"与运算\",{\"1\":{\"23\":1}}],[\"联合体通常用于存储一些互斥的数据\",{\"1\":{\"43\":1}}],[\"联合体的大小等于其中最大的字段的大小\",{\"1\":{\"43\":1}}],[\"联合体\",{\"1\":{\"43\":1}}],[\"`this`\",{\"1\":{\"42\":1}}],[\"`utils\",{\"1\":{\"42\":1}}],[\"像这样\",{\"1\":{\"42\":1}}],[\"像斐波那契数列的第n项\",{\"1\":{\"38\":1}}],[\"兄弟\",{\"1\":{\"42\":1}}],[\"定义的类型\",{\"1\":{\"42\":1}}],[\"定义的别名中加上\",{\"1\":{\"42\":1}}],[\"定义结构体变量\",{\"1\":{\"42\":1}}],[\"定义结构体类型\",{\"1\":{\"42\":1}}],[\"定义方向\",{\"1\":{\"35\":2}}],[\"向编译器告知\",{\"1\":{\"42\":1}}],[\"形成一个整体\",{\"1\":{\"42\":1}}],[\"结果\",{\"1\":{\"58\":1}}],[\"结构体类似\",{\"1\":{\"43\":1}}],[\"结构体是一种复合类型\",{\"1\":{\"42\":1}}],[\"结合\",{\"1\":{\"23\":1}}],[\"中等号两侧这两种表达是等价的\",{\"1\":{\"58\":1}}],[\"中的结构体中是可以定义方法的\",{\"1\":{\"42\":1}}],[\"中提到了一些更进阶的数据类型定义方式\",{\"1\":{\"41\":1}}],[\"中间柱才是你这一步的终点柱\",{\"1\":{\"38\":1}}],[\"中间柱子和终点柱子\",{\"1\":{\"38\":1}}],[\"7\",{\"0\":{\"41\":1,\"82\":1},\"1\":{\"43\":1}}],[\"提单链接\",{\"1\":{\"38\":1}}],[\"提示\",{\"1\":{\"8\":1,\"17\":3,\"20\":4,\"23\":3,\"29\":1,\"32\":1,\"42\":3,\"58\":3,\"61\":1}}],[\"祝大家本周末以及下周的期中考试愉快\",{\"1\":{\"38\":1}}],[\"祝大家在之后的题单中能够快乐地提升自己\",{\"1\":{\"17\":1}}],[\"留给有条件的同学们自己去思考\",{\"1\":{\"38\":1}}],[\"留给大家自己去实现\",{\"1\":{\"38\":1}}],[\"逆序对可以计算吗\",{\"1\":{\"38\":1}}],[\"显然这两个数构成了一个逆序对\",{\"1\":{\"38\":1}}],[\"显然冒泡排序可以解决这个问题\",{\"1\":{\"38\":1}}],[\"显然每一行只可能有一个皇后\",{\"1\":{\"35\":1}}],[\"存地址\",{\"1\":{\"58\":1}}],[\"存图\",{\"1\":{\"49\":1}}],[\"存图实际上有\",{\"1\":{\"35\":1}}],[\"存在\",{\"1\":{\"38\":1}}],[\"实例\",{\"1\":{\"42\":1}}],[\"实现\",{\"1\":{\"73\":1}}],[\"实现这些函数\",{\"1\":{\"42\":1}}],[\"实现的时候还是要写的\",{\"1\":{\"42\":1}}],[\"实现起来略有一些麻烦\",{\"1\":{\"38\":1}}],[\"实际上指的就是\",{\"1\":{\"58\":1}}],[\"实际上建议弄到\",{\"1\":{\"52\":1}}],[\"实际上一段代码就足够\",{\"1\":{\"46\":1}}],[\"实际上一样\",{\"1\":{\"20\":1}}],[\"实际上递归就是一种量变引起质变的方式\",{\"1\":{\"38\":1}}],[\"实际上我们可以把\",{\"1\":{\"38\":1}}],[\"实际上是历史遗留问题\",{\"1\":{\"29\":1}}],[\"实际上是一样的\",{\"1\":{\"20\":1}}],[\"实际上是没有必要的\",{\"1\":{\"20\":1}}],[\"实际上\",{\"1\":{\"20\":1,\"35\":2}}],[\"实际上你合并的时候需要将这两半序列都过一遍\",{\"1\":{\"11\":1}}],[\"实际上这种绕过方式的精髓在于\",{\"1\":{\"2\":1}}],[\"实际上就是通过添加一些边界条件来跳过一些不必要的搜索\",{\"1\":{\"35\":1}}],[\"实际上就是\",{\"1\":{\"2\":1}}],[\"实际上在ctype\",{\"1\":{\"2\":1}}],[\"实际上也许就是\",{\"1\":{\"2\":1}}],[\"归并排序来帮你\",{\"1\":{\"38\":1}}],[\"归并排序可以用来解决逆序对问题\",{\"1\":{\"38\":1}}],[\"归并排序的目的是通过二分将整个序列的排序分成两个小序列的排序\",{\"1\":{\"38\":1}}],[\"归并排序到底是什么意思\",{\"1\":{\"38\":1}}],[\"归并排序\",{\"1\":{\"38\":1}}],[\"归并排序是可以过的\",{\"1\":{\"11\":1}}],[\"欸\",{\"1\":{\"38\":1}}],[\"总有一天你会发现\",{\"1\":{\"38\":1}}],[\"总结的几点注意\",{\"1\":{\"35\":1}}],[\"转化成了一次移动和两次\",{\"1\":{\"38\":1}}],[\"转化为十进制的\",{\"1\":{\"32\":1}}],[\"移到终点柱子上\",{\"1\":{\"38\":1}}],[\"认作是一柱二柱三柱那格局就小了\",{\"1\":{\"38\":1}}],[\"自己心里清楚\",{\"1\":{\"46\":1}}],[\"自己算一下这些点的行号和列号之间大概有什么关系\",{\"1\":{\"35\":1}}],[\"自然不用说\",{\"1\":{\"38\":1}}],[\"完成了\",{\"1\":{\"61\":1}}],[\"完成汉诺塔的位移\",{\"1\":{\"38\":1}}],[\"完全正确的程序生成的可执行文件叫\",{\"1\":{\"8\":1}}],[\"层的问题\",{\"1\":{\"38\":1}}],[\"层从中间柱子通过起点柱子的帮助\",{\"1\":{\"38\":1}}],[\"层从起始柱子通过终点柱子的帮助移到中间柱子去\",{\"1\":{\"38\":1}}],[\"层\",{\"1\":{\"38\":3}}],[\"层抽象成两层\",{\"1\":{\"38\":1}}],[\"层时的处理方法\",{\"1\":{\"38\":1}}],[\"竟然这么简单\",{\"1\":{\"38\":1}}],[\"汉诺塔问题\",{\"1\":{\"38\":1}}],[\"毕竟\",{\"1\":{\"38\":1}}],[\"诶\",{\"1\":{\"38\":1}}],[\"忘记重新过一遍数据范围了otz\",{\"1\":{\"38\":1}}],[\"至于它为什么快呢\",{\"1\":{\"38\":1}}],[\"至于它们两个是怎么求出来的\",{\"1\":{\"38\":1}}],[\"至少占用\",{\"1\":{\"20\":1}}],[\"两个子问题构成\",{\"1\":{\"38\":1}}],[\"两者可以按照逻辑顺序连用fc\",{\"1\":{\"8\":1}}],[\"找到自己习惯的写法\",{\"1\":{\"38\":1}}],[\"找到自己的方法\",{\"1\":{\"38\":1}}],[\"找到一种更容易写出的解决方案\",{\"1\":{\"11\":1}}],[\"找出结果\",{\"1\":{\"38\":1}}],[\"才能一层一层递归\",{\"1\":{\"38\":1}}],[\"边界条件是什么\",{\"1\":{\"38\":1}}],[\"边界条件会出手\",{\"1\":{\"35\":1}}],[\"问问前两项\",{\"1\":{\"38\":1}}],[\"问问f\",{\"1\":{\"38\":1}}],[\"问题\",{\"1\":{\"35\":1}}],[\"≥\",{\"1\":{\"38\":1}}],[\"于是\",{\"1\":{\"38\":1}}],[\"于是我们便学会了对变量进行基本的处理\",{\"1\":{\"17\":1}}],[\"先给自己准备好的每一个音乐都准备好独特的id\",{\"1\":{\"82\":1}}],[\"先给代码后解释\",{\"1\":{\"38\":1}}],[\"先解释一下这个函数中各个参数的含义\",{\"1\":{\"38\":1}}],[\"先把代码写在这里\",{\"1\":{\"38\":1}}],[\"先来看一下写法\",{\"1\":{\"23\":1}}],[\"先来看一下用法\",{\"1\":{\"23\":1}}],[\"选择上课提到的三个比较经典的问题\",{\"1\":{\"38\":1}}],[\"决定提前拿出题单\",{\"1\":{\"38\":1}}],[\"感觉各位同学对递归可能是一知半解\",{\"1\":{\"38\":1}}],[\"感谢各位的收看\",{\"1\":{\"32\":1}}],[\"频道似乎会吞空格\",{\"1\":{\"35\":1}}],[\"已经修正\",{\"1\":{\"35\":1}}],[\"注\",{\"1\":{\"35\":1,\"38\":1}}],[\"注意这里障碍物不止一个\",{\"1\":{\"35\":1}}],[\"注意看某一条从右上到左下的斜线上每一个点的坐标\",{\"1\":{\"35\":1}}],[\"注意观察题目的数据范围思考在最坏的情况下自己的算式会不会有某个地方超出了变量的存储范围\",{\"1\":{\"26\":1}}],[\"注意\",{\"1\":{\"20\":3,\"23\":1,\"32\":1,\"49\":1,\"58\":2}}],[\"注意后缀名\",{\"1\":{\"8\":1}}],[\"优化了搜索的效率\",{\"1\":{\"35\":1}}],[\"绝对能把搜索写对\",{\"1\":{\"35\":1}}],[\"绝对值\",{\"1\":{\"20\":1}}],[\"无论你在什么地方修改了它的值\",{\"1\":{\"58\":1}}],[\"无论条件成立与否它都会先执行一次\",{\"1\":{\"26\":1}}],[\"无所谓\",{\"1\":{\"35\":1}}],[\"枚举方向\",{\"1\":{\"35\":1}}],[\"枚举类型默认从\",{\"1\":{\"20\":1}}],[\"枚举类型实际上也是\",{\"1\":{\"20\":1}}],[\"走它干嘛\",{\"1\":{\"35\":1}}],[\"走过了\",{\"1\":{\"35\":1}}],[\"走到\",{\"1\":{\"35\":1}}],[\"邻接矩阵\",{\"1\":{\"35\":1}}],[\"减少搜索过程中复制粘贴的工程量\",{\"1\":{\"35\":2}}],[\"继续去找其它的情况\",{\"1\":{\"35\":1}}],[\"继续使用\",{\"1\":{\"2\":1}}],[\"退到上一步\",{\"1\":{\"35\":1}}],[\"时间常数大的起飞\",{\"1\":{\"49\":1}}],[\"时间复杂度\",{\"1\":{\"11\":1}}],[\"时\",{\"1\":{\"35\":1}}],[\"终止条件\",{\"1\":{\"35\":1}}],[\"采取之前蚂蚁寻路的那种通过讨论绕开障碍物的做法是不可取的\",{\"1\":{\"35\":1}}],[\"求最少要走多少步才能到终点\",{\"1\":{\"35\":1}}],[\"图中有一些障碍物\",{\"1\":{\"35\":1}}],[\"从而能在相当于n次循环的时间内解决了这个问题\",{\"1\":{\"38\":1}}],[\"从最高层一层一层询问下去\",{\"1\":{\"38\":1}}],[\"从整个搜索过程思考一下为什么它叫这个名字\",{\"1\":{\"35\":1}}],[\"从\",{\"1\":{\"35\":1}}],[\"从左上到右下的斜线同理\",{\"1\":{\"35\":1}}],[\"拿一道简单的题目来举例\",{\"1\":{\"35\":1}}],[\"八皇后问题在洛谷上能找到这道题\",{\"1\":{\"35\":1}}],[\"容易超时\",{\"1\":{\"35\":1}}],[\"固然是可以的\",{\"1\":{\"35\":1}}],[\"列的问题\",{\"1\":{\"35\":1}}],[\"条件的判断略有不同\",{\"1\":{\"35\":1}}],[\"棋盘的行来分\",{\"1\":{\"35\":1}}],[\"听说有些老师在课上已经讲过了八皇后问题\",{\"1\":{\"35\":1}}],[\"递归的题目确实有点抽象\",{\"1\":{\"38\":1}}],[\"递归的终止条件有没有写完整\",{\"1\":{\"11\":1}}],[\"递归真的很好用\",{\"1\":{\"38\":1}}],[\"递归中的错误很可能让人摸不着头脑\",{\"1\":{\"35\":1}}],[\"否则编译器会报错\",{\"1\":{\"58\":1}}],[\"否则会导致内存泄露\",{\"1\":{\"58\":1}}],[\"否则会有意想不到的\",{\"1\":{\"35\":1}}],[\"否则它会一直存在\",{\"1\":{\"58\":1}}],[\"否则刷屏警告\",{\"1\":{\"8\":1}}],[\"取地址\",{\"1\":{\"58\":1}}],[\"取消标记\",{\"1\":{\"35\":1}}],[\"取模运算十分神奇\",{\"1\":{\"26\":1}}],[\"标记为用过\",{\"1\":{\"35\":1}}],[\"标志结束\",{\"1\":{\"2\":1}}],[\"练多了才会好\",{\"1\":{\"35\":1}}],[\"搜索下一位\",{\"1\":{\"35\":1}}],[\"搜索的题目一开始做会有一点点难理解\",{\"1\":{\"35\":1}}],[\"搜索\",{\"0\":{\"35\":1},\"1\":{\"35\":1}}],[\"q\",{\"1\":{\"32\":2}}],[\"进制的数的函数\",{\"1\":{\"32\":1}}],[\"进制的数转化为\",{\"1\":{\"32\":1}}],[\"进行读入数据\",{\"1\":{\"2\":1}}],[\"通过使用指针\",{\"1\":{\"58\":1}}],[\"通过指针\",{\"1\":{\"58\":1}}],[\"通过不断地解决小问题\",{\"1\":{\"38\":1}}],[\"通过这样以二分的方法将数组拆分\",{\"1\":{\"38\":1}}],[\"通过这样的处理\",{\"1\":{\"38\":1}}],[\"通过这样一个函数\",{\"1\":{\"32\":1}}],[\"通过添加一些边界条件\",{\"1\":{\"35\":1}}],[\"通过全排列我们已经解决了皇后们出现在同一行\",{\"1\":{\"35\":1}}],[\"通过写这样一个\",{\"1\":{\"32\":1}}],[\"举一个\",{\"1\":{\"32\":1}}],[\"举个例子\",{\"1\":{\"11\":1}}],[\"叫做\",{\"1\":{\"32\":1}}],[\"具体实现非常弱智\",{\"1\":{\"73\":1}}],[\"具体的函数实现就不放在这了\",{\"1\":{\"64\":1}}],[\"具体如下\",{\"1\":{\"52\":1}}],[\"具体解释在下面\",{\"1\":{\"38\":1}}],[\"具体子问题做法\",{\"1\":{\"35\":1}}],[\"具体怎么实现自然不必说\",{\"1\":{\"32\":1}}],[\"具体使用\",{\"1\":{\"2\":1}}],[\"括号中可以填一些传入该函数的参数\",{\"1\":{\"32\":1}}],[\"括起来的字符串和若干变量\",{\"1\":{\"17\":1}}],[\"范围内的值\",{\"1\":{\"32\":1}}],[\"范围内的随机数\",{\"1\":{\"8\":1}}],[\"限制在\",{\"1\":{\"32\":1}}],[\"作为\",{\"1\":{\"32\":1}}],[\"非也\",{\"1\":{\"32\":1}}],[\"非常好\",{\"1\":{\"38\":1}}],[\"非常直观\",{\"1\":{\"38\":1}}],[\"非常重要\",{\"1\":{\"20\":1}}],[\"非常重要的一点是读入一定不能少了\",{\"1\":{\"17\":1}}],[\"非常顺畅\",{\"1\":{\"14\":1}}],[\"使得程序更加的通俗易懂\",{\"1\":{\"42\":1}}],[\"使得\",{\"1\":{\"32\":1}}],[\"使用之前提到过的\",{\"1\":{\"42\":1}}],[\"使用结构体变量\",{\"1\":{\"42\":1}}],[\"使用时需要特别注意\",{\"1\":{\"20\":1}}],[\"使用超时的算法拿部分分未尝不可\",{\"1\":{\"20\":1}}],[\"使用\",{\"1\":{\"14\":1,\"20\":2,\"42\":3}}],[\"函数指针\",{\"1\":{\"58\":1}}],[\"函数自己调用了自己\",{\"1\":{\"38\":1}}],[\"函数也能返回值吗\",{\"1\":{\"32\":1}}],[\"函数的例子\",{\"1\":{\"32\":1}}],[\"函数没有返回值\",{\"1\":{\"32\":1}}],[\"函数有一种特别的类型\",{\"1\":{\"32\":1}}],[\"函数中\",{\"1\":{\"32\":1}}],[\"函数中我们传入了经过处理的\",{\"1\":{\"32\":1}}],[\"函数中需要获得\",{\"1\":{\"32\":1}}],[\"函数后面一定有括号\",{\"1\":{\"32\":1}}],[\"函数为例\",{\"1\":{\"32\":1}}],[\"函数是不能定义在某一个函数里面的\",{\"1\":{\"32\":1}}],[\"函数\",{\"1\":{\"32\":3}}],[\"函数究竟是干嘛用的呢\",{\"1\":{\"32\":1}}],[\"函数用来生成\",{\"1\":{\"8\":1}}],[\"各个函数解决小范围内的一些问题\",{\"1\":{\"32\":1}}],[\"各位好呀\",{\"1\":{\"20\":1}}],[\"各位好啊\",{\"1\":{\"17\":1,\"35\":1,\"38\":1}}],[\"各位可以自行去下载\",{\"1\":{\"8\":1}}],[\"便于练习\",{\"1\":{\"32\":1}}],[\"便会执行\",{\"1\":{\"23\":2}}],[\"便会使用指定的工具链编译对应的库并安装到全局\",{\"1\":{\"14\":1}}],[\"让它自行选取符合条件的实体进行更新\",{\"1\":{\"76\":1}}],[\"让它更好理解呢\",{\"1\":{\"64\":1}}],[\"让他来控制所有文件的存取呢\",{\"1\":{\"67\":1}}],[\"让含义更贴近面向对象表达\",{\"1\":{\"42\":1}}],[\"让oj的前几题较为简单\",{\"1\":{\"32\":1}}],[\"让可执行文件点开即玩\",{\"1\":{\"14\":1}}],[\"5\",{\"0\":{\"32\":1,\"70\":1,\"76\":1},\"1\":{\"32\":1,\"35\":4}}],[\"5ll\",{\"1\":{\"20\":3}}],[\"难以调试\",{\"1\":{\"29\":1}}],[\"难以接受负数\",{\"1\":{\"20\":1}}],[\"假设是一个int变量\",{\"1\":{\"58\":1}}],[\"假设现在有\",{\"1\":{\"11\":1}}],[\"假装这里有一大堆用于求解\",{\"1\":{\"29\":1}}],[\"答案已经最小\",{\"1\":{\"35\":1}}],[\"答案显然可以直接得出\",{\"1\":{\"29\":1}}],[\"答案是\",{\"1\":{\"2\":1}}],[\"情况下\",{\"1\":{\"29\":1}}],[\"简介和环境配置\",{\"0\":{\"61\":1}}],[\"简单介绍一下使用方式\",{\"1\":{\"29\":1}}],[\"简洁\",{\"1\":{\"14\":1}}],[\"再看一眼\",{\"0\":{\"70\":1}}],[\"再来具体解释一下\",{\"1\":{\"38\":1}}],[\"再把下面一个盘子移到终点柱子上\",{\"1\":{\"38\":1}}],[\"再一层一层回来\",{\"1\":{\"38\":1}}],[\"再编写一个将\",{\"1\":{\"32\":1}}],[\"再进行判断\",{\"1\":{\"26\":1}}],[\"再去看两道题实战演练一下\",{\"1\":{\"11\":1}}],[\"唯一不同的地方在于\",{\"1\":{\"26\":1}}],[\"速度会快很多\",{\"1\":{\"23\":1}}],[\"二进制下第一位的取值来判断的话\",{\"1\":{\"23\":1}}],[\"二进制的\",{\"1\":{\"20\":1}}],[\"判断一个数是否为偶数\",{\"1\":{\"23\":1}}],[\"判断条件中非\",{\"1\":{\"23\":1}}],[\"尽量加上括号\",{\"1\":{\"23\":1}}],[\"需要搞清楚两个关键点\",{\"1\":{\"38\":1}}],[\"需要考虑大量的剪枝优化\",{\"1\":{\"35\":1}}],[\"需要同学们及时对各个数据进行取模\",{\"1\":{\"26\":1}}],[\"需要注意运算符的运算顺序\",{\"1\":{\"23\":1}}],[\"需要用到\",{\"1\":{\"20\":1}}],[\"右移同理\",{\"1\":{\"23\":1}}],[\"左移\",{\"1\":{\"23\":1}}],[\"左右或者小于\",{\"1\":{\"11\":1}}],[\"^\",{\"1\":{\"23\":5,\"49\":1}}],[\"异或运算\",{\"1\":{\"23\":1}}],[\"或运算\",{\"1\":{\"23\":1}}],[\"或者意想得到的\",{\"1\":{\"35\":1}}],[\"或者子问题之间根本没有关系\",{\"1\":{\"35\":1}}],[\"或者花去了多少的时间\",{\"1\":{\"20\":1}}],[\"或者\",{\"1\":{\"20\":2,\"61\":2}}],[\"统一输出\",{\"1\":{\"23\":1}}],[\"统一读入\",{\"1\":{\"23\":1}}],[\"长度为多少\",{\"1\":{\"23\":1}}],[\"填上数字来告诉编译器我们想定义一个数组\",{\"1\":{\"23\":1}}],[\"填入以下代码\",{\"1\":{\"8\":1}}],[\"第一题数据范围太大不但需要高精度而且递归会超时\",{\"1\":{\"38\":1}}],[\"第一个部分是初始化部分\",{\"1\":{\"23\":1}}],[\"第三个部分是处理部分\",{\"1\":{\"23\":1}}],[\"第二个部分是判断部分\",{\"1\":{\"23\":1}}],[\"第零章我们只学了整型变量\",{\"1\":{\"17\":1}}],[\"循环来实现\",{\"1\":{\"26\":1}}],[\"循环中依旧适用\",{\"1\":{\"26\":1}}],[\"循环中的处理部分后\",{\"1\":{\"23\":1}}],[\"循环很简单\",{\"1\":{\"26\":1}}],[\"循环替代\",{\"1\":{\"26\":1}}],[\"循环实际上完全可以由\",{\"1\":{\"26\":1}}],[\"循环变成下一次要提到的\",{\"1\":{\"23\":1}}],[\"循环的时候\",{\"1\":{\"23\":1}}],[\"循环和数组\",{\"1\":{\"23\":1}}],[\"循环就会结束\",{\"1\":{\"23\":1}}],[\"循环会进行一次判断部分\",{\"1\":{\"23\":1}}],[\"循环才会继续\",{\"1\":{\"23\":1}}],[\"循环当中我们用两个分号将其分成了三个部分\",{\"1\":{\"23\":1}}],[\"循环\",{\"1\":{\"23\":2,\"26\":1}}],[\"类\",{\"1\":{\"79\":2}}],[\"类似的方法配置吧\",{\"1\":{\"61\":1}}],[\"类似上面的写法\",{\"1\":{\"23\":1}}],[\"类型的指针\",{\"1\":{\"58\":2}}],[\"类型的变量在定义时\",{\"1\":{\"42\":1}}],[\"类型重命名\",{\"1\":{\"42\":1}}],[\"类型了\",{\"1\":{\"20\":1}}],[\"类型因为较\",{\"1\":{\"20\":1}}],[\"类型实际上也会占用\",{\"1\":{\"20\":1}}],[\"类型硬生生占了1b的内存\",{\"1\":{\"20\":1}}],[\"类型只有两种状态\",{\"1\":{\"20\":1}}],[\"类型表示一个字符\",{\"1\":{\"20\":1}}],[\"类型在scanf和printf里面的表示是\",{\"1\":{\"20\":1}}],[\"类型在\",{\"1\":{\"20\":5}}],[\"类型能表示的范围是\",{\"1\":{\"20\":1}}],[\"类型真正用来表示数据大小的只有\",{\"1\":{\"20\":1}}],[\"类型被称为双精度浮点数\",{\"1\":{\"20\":1}}],[\"类型被称为单精度浮点数\",{\"1\":{\"20\":1}}],[\"类型被称为\",{\"1\":{\"20\":1}}],[\"类型\",{\"1\":{\"20\":6,\"42\":1}}],[\"后缀\",{\"1\":{\"42\":1}}],[\"后面有紧接着对应的\",{\"1\":{\"23\":1}}],[\"后果自负\",{\"1\":{\"5\":1}}],[\"貌似是个年份\",{\"1\":{\"23\":1}}],[\"知道确定的答案之后\",{\"1\":{\"38\":1}}],[\"知道各位同学已经学过了if和for还有while\",{\"1\":{\"20\":1}}],[\"知道了这一点点东西\",{\"1\":{\"17\":1}}],[\"每帧我们根据用户的输入情况以及游戏的整体情况决定需要进行哪些更新\",{\"1\":{\"76\":1}}],[\"每次扩容时会把容量多扩一些\",{\"1\":{\"49\":1}}],[\"每一个\",{\"1\":{\"32\":1}}],[\"每一个格子都存上一个变量\",{\"1\":{\"29\":1}}],[\"每道题有条件可把之前的代码清空了重写\",{\"1\":{\"20\":1}}],[\"每个节点的性质需要能被绘制\",{\"1\":{\"73\":1}}],[\"每个皇后的列号肯定也不一样\",{\"1\":{\"35\":1}}],[\"每个函数都有属于它自己的坑\",{\"1\":{\"20\":1}}],[\"每个人程序的做法是不同的\",{\"1\":{\"8\":1}}],[\"想想不久前你可能仍然挣扎在数百行代码之中\",{\"1\":{\"32\":1}}],[\"想要的时候再通过id把它取出来\",{\"1\":{\"67\":1}}],[\"想要一下子跳出所有的循环\",{\"1\":{\"29\":1}}],[\"想要提醒下各位同学\",{\"1\":{\"20\":1}}],[\"想一想为什么是这个式子\",{\"1\":{\"2\":1}}],[\"表示这是\",{\"1\":{\"42\":1}}],[\"表示这非常的难以置信\",{\"1\":{\"38\":1}}],[\"表示\",{\"1\":{\"38\":1}}],[\"表示函数真的很好用\",{\"1\":{\"32\":1}}],[\"表示第二行代码根本不想看\",{\"1\":{\"20\":1}}],[\"表示我们想要读入一个整型\",{\"1\":{\"17\":1}}],[\"区别非常明显\",{\"1\":{\"20\":1}}],[\"给大家拿出来对比一下\",{\"1\":{\"20\":1}}],[\"给这两个数组\",{\"1\":{\"11\":1}}],[\"易于分辨哪个是哪个\",{\"1\":{\"20\":1}}],[\"空间可以算\",{\"1\":{\"38\":1}}],[\"空间比时间更好掌握\",{\"1\":{\"38\":1}}],[\"空间复杂度\",{\"1\":{\"11\":1}}],[\"空格能让你的不少算式看上去更加分散\",{\"1\":{\"20\":1}}],[\"加入此类递归的一种优化方法\",{\"1\":{\"38\":1}}],[\"加空格干什么用呢\",{\"1\":{\"20\":1}}],[\"加上\",{\"1\":{\"20\":1}}],[\"语句才有了用武之地\",{\"1\":{\"29\":1}}],[\"语句并不建议使用\",{\"1\":{\"29\":1}}],[\"语句在\",{\"1\":{\"26\":1}}],[\"语句来直接跳出循环\",{\"1\":{\"23\":1}}],[\"语句来直接进入下一次循环\",{\"1\":{\"23\":1}}],[\"语句的时候\",{\"1\":{\"23\":1}}],[\"语句可以进行嵌套\",{\"1\":{\"23\":1}}],[\"语句之后大括号里面的内容\",{\"1\":{\"23\":1}}],[\"语句中条件成立的时候\",{\"1\":{\"23\":1}}],[\"语句\",{\"1\":{\"23\":1,\"29\":1}}],[\"语句块之间可以适当空行\",{\"1\":{\"20\":1}}],[\"语言当中依然用起来有些难度的东西\",{\"1\":{\"49\":1}}],[\"语言中最容易出错的地方\",{\"1\":{\"58\":1}}],[\"语言中有没有办法实现类似的功能呢\",{\"1\":{\"42\":1}}],[\"语言中空行并不会影响程序\",{\"1\":{\"20\":1}}],[\"语言不是一种面向对象语言\",{\"1\":{\"42\":1}}],[\"语言程序都必须包含\",{\"1\":{\"32\":1}}],[\"语言规定的程序的入口\",{\"1\":{\"32\":1}}],[\"语言编程中最基础也是最重要的两种结构\",{\"1\":{\"23\":1}}],[\"语言的核心技巧\",{\"1\":{\"58\":1}}],[\"语言的变量存储是对齐的\",{\"1\":{\"20\":1}}],[\"语言的基本设计结构\",{\"1\":{\"17\":1}}],[\"语言库的指令\",{\"1\":{\"17\":1}}],[\"语言怎么写随机数呢\",{\"1\":{\"8\":1}}],[\"语言学习分享\",{\"0\":{\"86\":1},\"2\":{\"3\":1,\"6\":1,\"9\":1,\"12\":1,\"15\":1}}],[\"制表符来让你的程序变得更美观\",{\"1\":{\"20\":1}}],[\"等\",{\"1\":{\"20\":1}}],[\"等等\",{\"1\":{\"20\":1}}],[\"对于\",{\"1\":{\"38\":1}}],[\"对于当前的问题\",{\"1\":{\"38\":1}}],[\"对于附属于某一语句\",{\"1\":{\"20\":1}}],[\"对数\",{\"1\":{\"20\":1}}],[\"控制好语句块的缩进\",{\"1\":{\"20\":1}}],[\"控制时空复杂度\",{\"0\":{\"11\":1}}],[\"喜欢的代码格式\",{\"1\":{\"20\":1}}],[\"检查起来好检查\",{\"1\":{\"20\":1}}],[\"乘方\",{\"1\":{\"20\":1}}],[\"立方根\",{\"1\":{\"20\":1}}],[\"常见的数学函数\",{\"1\":{\"20\":1}}],[\"则需要对自己的算式进行一定的修改\",{\"1\":{\"26\":1}}],[\"则它的值为前一个枚举的取值\",{\"1\":{\"20\":1}}],[\"则这个数是负数\",{\"1\":{\"20\":1}}],[\"😉\",{\"1\":{\"20\":1}}],[\"码里面实际上并没有多少东西\",{\"1\":{\"20\":1}}],[\"能做坐标系上的变换\",{\"1\":{\"73\":1}}],[\"能让你获得最舒适的游戏体验\",{\"1\":{\"61\":1}}],[\"能让你的程序看上去更加清晰\",{\"1\":{\"20\":1}}],[\"能用这种穷举来解决的问题\",{\"1\":{\"35\":1}}],[\"能表示更多的小数位\",{\"1\":{\"20\":1}}],[\"能被用来表示小数\",{\"1\":{\"20\":1}}],[\"除非你在别处用\",{\"1\":{\"58\":1}}],[\"除非你非常清楚你自己在做什么\",{\"1\":{\"20\":1}}],[\"除法的速度非常的慢\",{\"1\":{\"23\":1}}],[\"除了之前写好的scenenode之外\",{\"1\":{\"76\":1}}],[\"除了来路\",{\"1\":{\"35\":1}}],[\"除了\",{\"1\":{\"26\":1}}],[\"除了自己写\",{\"1\":{\"20\":1}}],[\"除了读入单个字符\",{\"1\":{\"2\":1}}],[\"溢出是未定义行为\",{\"1\":{\"20\":1}}],[\"整型变量的溢出实际上比较好控制\",{\"1\":{\"20\":1}}],[\"超出存储范围的位数将被抹除\",{\"1\":{\"23\":1}}],[\"超出即危险\",{\"1\":{\"20\":1}}],[\"超空间怎么办这一类的问题了吧\",{\"1\":{\"11\":1}}],[\"会分配一段连续的内存空间\",{\"1\":{\"42\":1}}],[\"会在接下来的讲解中一并讲掉这题是怎么做的\",{\"1\":{\"38\":1}}],[\"会在题单中放一道经典的需要用归并排序的问题\",{\"1\":{\"38\":1}}],[\"会做即可\",{\"1\":{\"38\":1}}],[\"会看到题目给定的时空限制\",{\"1\":{\"20\":1}}],[\"会自动检查平台\",{\"1\":{\"14\":1}}],[\"8\",{\"0\":{\"46\":1,\"49\":1,\"52\":1},\"1\":{\"20\":3,\"35\":3,\"46\":1,\"49\":1,\"52\":1}}],[\"80\",{\"1\":{\"2\":1}}],[\"希望各位同学自己去写一写\",{\"1\":{\"38\":1}}],[\"希望各位佬们能够帮助某\",{\"1\":{\"17\":1}}],[\"希望同学们能够掌握这种用空间换时间的优化方法\",{\"1\":{\"38\":1}}],[\"希望同学们在题单的习题中能够练习掌握这些基本结构\",{\"1\":{\"23\":1}}],[\"希望通过函数将它限制在\",{\"1\":{\"32\":1}}],[\"希望大家无论语句多少都加上大括号\",{\"1\":{\"23\":1}}],[\"希望给出更多的一些小技巧\",{\"1\":{\"20\":1}}],[\"很多同学遇到了自己检查不出来却实际上超出了变量可存储范围的运算\",{\"1\":{\"26\":1}}],[\"很多同学反映\",{\"1\":{\"17\":1}}],[\"很好用\",{\"1\":{\"20\":1}}],[\"6\",{\"0\":{\"35\":1,\"38\":1,\"79\":1},\"1\":{\"35\":1,\"38\":2}}],[\"64\",{\"1\":{\"20\":1}}],[\"65535\",{\"1\":{\"8\":1}}],[\"即使变量类型是一样的也不行\",{\"1\":{\"32\":1}}],[\"即使它不再能表示负数\",{\"1\":{\"20\":1}}],[\"即真\",{\"1\":{\"23\":1}}],[\"即可启动编译\",{\"1\":{\"14\":1}}],[\"ubuntu为例\",{\"1\":{\"61\":1}}],[\"union\",{\"0\":{\"43\":1},\"1\":{\"43\":4}}],[\"unsigned\",{\"1\":{\"20\":4,\"52\":4}}],[\"utils\",{\"1\":{\"42\":16}}],[\"update\",{\"1\":{\"79\":1}}],[\"upd\",{\"1\":{\"35\":1,\"38\":1}}],[\"u\",{\"1\":{\"20\":1}}],[\"ui命令\",{\"1\":{\"14\":1}}],[\"负数是以补码的形式存储的\",{\"1\":{\"20\":1}}],[\"之类的呢\",{\"1\":{\"61\":1}}],[\"之所以负数能到\",{\"1\":{\"20\":1}}],[\"之后的问题是否对前面的问题有影响\",{\"1\":{\"35\":1}}],[\"之后的语句并不能执行\",{\"1\":{\"23\":1}}],[\"之后我们就可以通过在方括号里填数组下标的形式来访问某一个特定的元素\",{\"1\":{\"23\":1}}],[\"之后大括号里面的内容\",{\"1\":{\"23\":1}}],[\"之后\",{\"1\":{\"17\":1}}],[\"之后跟上\",{\"1\":{\"17\":1}}],[\"~\",{\"1\":{\"20\":1}}],[\"位内存\",{\"1\":{\"52\":1}}],[\"位存储的变量\",{\"1\":{\"52\":1}}],[\"位呢\",{\"1\":{\"52\":1}}],[\"位元素\",{\"1\":{\"49\":2}}],[\"位插入一个元素\",{\"1\":{\"49\":1}}],[\"位运算的速度比正常运算要快\",{\"1\":{\"23\":1}}],[\"位移运算\",{\"1\":{\"23\":1}}],[\"位的\",{\"1\":{\"20\":1}}],[\"位\",{\"1\":{\"20\":3,\"23\":1,\"52\":1}}],[\"位带符号整数\",{\"1\":{\"20\":1}}],[\"请各位饶了我吧\",{\"1\":{\"38\":1}}],[\"请各位同学一定要看到最后\",{\"1\":{\"35\":1}}],[\"请各位同学们在进行变量相加或者相乘的时候\",{\"1\":{\"26\":1}}],[\"请耐心将题单简介看完\",{\"1\":{\"38\":1}}],[\"请不要参考\",{\"1\":{\"20\":1}}],[\"请注意\",{\"1\":{\"14\":1}}],[\"今天给大家带来\",{\"1\":{\"20\":1}}],[\"今天发现有不少同学会在群里面求某道题的测试数据来验证自己程序的正确性\",{\"1\":{\"8\":1}}],[\"补完计划\",{\"0\":{\"87\":1},\"2\":{\"18\":1,\"21\":1,\"24\":1,\"27\":1,\"30\":1,\"33\":1,\"36\":1,\"39\":1,\"44\":1,\"47\":1,\"50\":1,\"53\":1,\"56\":1,\"59\":1}}],[\"||\",{\"1\":{\"23\":2,\"35\":6,\"38\":1}}],[\"|\",{\"1\":{\"17\":1,\"20\":1,\"23\":6,\"26\":1,\"29\":1,\"32\":1,\"35\":1,\"38\":1,\"43\":1,\"46\":1,\"49\":1,\"52\":1,\"55\":1,\"58\":1}}],[\"洛谷\",{\"1\":{\"17\":1,\"20\":1,\"23\":1,\"26\":1,\"29\":1,\"32\":1,\"35\":1,\"38\":1,\"43\":1,\"46\":1,\"49\":1,\"52\":1,\"55\":1,\"58\":1}}],[\"快来试试吧\",{\"1\":{\"17\":1}}],[\"没用过\",{\"1\":{\"61\":1}}],[\"没必要继续下去的时候\",{\"1\":{\"32\":1}}],[\"没错\",{\"1\":{\"20\":1}}],[\"没想到我们已经能编写出一个能干点事情的程序了\",{\"1\":{\"17\":1}}],[\"没有办法提供合适的\",{\"1\":{\"14\":1}}],[\"赋值语句我们用的是\",{\"1\":{\"17\":1}}],[\"输出的一些奇技淫巧在此并不赘述\",{\"1\":{\"20\":1}}],[\"输出\",{\"1\":{\"17\":1}}],[\"输入和输出\",{\"1\":{\"17\":1}}],[\"输入\",{\"1\":{\"14\":1,\"17\":1}}],[\"必要的情况下\",{\"1\":{\"23\":1}}],[\"必要时记得开\",{\"1\":{\"8\":1}}],[\"必须要知道这个变量的地址在哪里\",{\"1\":{\"17\":1}}],[\"了解到的是这个变量的值\",{\"1\":{\"17\":1}}],[\"号\",{\"1\":{\"58\":1}}],[\"号指的是你告诉编译器你新建的变量是一个指针类型\",{\"1\":{\"58\":1}}],[\"号表示这个变量的地址\",{\"1\":{\"17\":1}}],[\"号和我们想要存入这个数据的变量名\",{\"1\":{\"17\":1}}],[\"变量和一个大小为\",{\"1\":{\"58\":1}}],[\"变量的指针没有区别\",{\"1\":{\"58\":1}}],[\"变量的存储位置\",{\"1\":{\"52\":1}}],[\"变量的值\",{\"1\":{\"52\":1}}],[\"变量只有\",{\"1\":{\"20\":1}}],[\"变量存了\",{\"1\":{\"20\":1}}],[\"变量\",{\"1\":{\"17\":1}}],[\"连起来读就是标准输入输出库\",{\"1\":{\"17\":1}}],[\"连续读入\",{\"1\":{\"2\":1}}],[\"他只会严重破坏代码的可读性\",{\"1\":{\"43\":1}}],[\"他发现这玩意真的很好用\",{\"1\":{\"32\":1}}],[\"他的std指的是标准\",{\"1\":{\"17\":1}}],[\"他会在频道当中新开一个分区用来放近期题库正确可执行文件的下载链接\",{\"1\":{\"8\":1}}],[\"题\",{\"1\":{\"32\":2}}],[\"题单里有一道这个题\",{\"1\":{\"38\":1}}],[\"题单中有一些搜索的题目\",{\"1\":{\"35\":1}}],[\"题单链接\",{\"1\":{\"17\":1,\"20\":1,\"23\":1,\"26\":1,\"29\":1,\"32\":1,\"35\":1,\"43\":1,\"46\":1,\"49\":1,\"52\":1,\"58\":1}}],[\"题单\",{\"1\":{\"17\":2,\"20\":1,\"23\":1,\"26\":1,\"29\":1,\"32\":1,\"35\":1,\"38\":1,\"43\":1,\"46\":1,\"49\":1,\"52\":1,\"55\":1,\"58\":1}}],[\"题目要求你用这么多内存来解决问题\",{\"1\":{\"11\":1}}],[\"题目要求明显是要你用链表来动态分配内存\",{\"1\":{\"11\":1}}],[\"同理先记id\",{\"1\":{\"82\":1}}],[\"同学们也许需要克服一点困难\",{\"1\":{\"38\":1}}],[\"同学们需要通过一定量的练习才能掌握的差不多\",{\"1\":{\"38\":1}}],[\"同学们需要自己写一写\",{\"1\":{\"38\":1}}],[\"同学们是不是对递归有了更深的理解\",{\"1\":{\"38\":1}}],[\"同一条斜线上的点\",{\"1\":{\"35\":1}}],[\"同时不需要进行随机寻址操作时\",{\"1\":{\"46\":1}}],[\"同时不要忘了返回\",{\"1\":{\"35\":1}}],[\"同时也能让存取的步骤更加的简单\",{\"1\":{\"67\":1}}],[\"同时也可以使算式看上去更加易于理解\",{\"1\":{\"20\":1}}],[\"同时也希望大家能获得对程序设计更深的理解\",{\"1\":{\"17\":1}}],[\"同时\",{\"1\":{\"20\":1,\"23\":1,\"38\":1}}],[\"同样的种子出来的随机数是不会变的\",{\"1\":{\"8\":1}}],[\"同样的数据\",{\"1\":{\"8\":1}}],[\"供大家为本周的oj困难挑战做准备练习\",{\"1\":{\"17\":1}}],[\"仍然会当天课程的情况下\",{\"1\":{\"17\":1}}],[\"怎么办\",{\"1\":{\"38\":1}}],[\"怎么办呢\",{\"1\":{\"17\":1,\"52\":1,\"58\":1}}],[\"怎么会出现超时超空间的问题呢\",{\"1\":{\"11\":1}}],[\"怎么会随手把它丢掉\",{\"1\":{\"2\":1}}],[\"南哪2022\",{\"1\":{\"17\":1,\"20\":1,\"23\":1,\"26\":1,\"29\":1,\"32\":1,\"35\":1,\"38\":1,\"43\":1,\"46\":1,\"49\":1,\"52\":1}}],[\"南哪\",{\"0\":{\"17\":1,\"20\":1,\"23\":1,\"26\":1,\"29\":1,\"32\":1,\"35\":1,\"38\":1,\"41\":1,\"46\":1,\"49\":1,\"52\":1}}],[\"添加\",{\"1\":{\"14\":1}}],[\"添加到我们的配置文件中作为编译内容的一部分\",{\"1\":{\"14\":1}}],[\"插件吧\",{\"1\":{\"14\":1}}],[\"插件但并不好用\",{\"1\":{\"14\":1}}],[\"可能会成为至关重要的一环\",{\"1\":{\"35\":1}}],[\"可能会出现一些精度上的问题\",{\"1\":{\"20\":1}}],[\"可能有很多个\",{\"1\":{\"35\":1}}],[\"可能你想问\",{\"1\":{\"32\":1}}],[\"可能不少同学去记\",{\"1\":{\"20\":1}}],[\"可选\",{\"1\":{\"14\":1}}],[\"可以很方便的将多个数据打包\",{\"1\":{\"42\":1}}],[\"可以自己去写写看\",{\"1\":{\"38\":1}}],[\"可以去看看题解\",{\"1\":{\"35\":1}}],[\"可以在某一范围内循环地往右运动\",{\"1\":{\"32\":1}}],[\"可以将它想象成一个棋盘\",{\"1\":{\"29\":1}}],[\"可以灵活运用内部的三大部分\",{\"1\":{\"23\":1}}],[\"可以看到它在加载的过程中需要不止一个参数\",{\"1\":{\"67\":1}}],[\"可以看到\",{\"1\":{\"23\":1}}],[\"可以用来给一个类型起一个新的名字\",{\"1\":{\"20\":1}}],[\"可以用来很方便地表示一些固定的值\",{\"1\":{\"20\":1}}],[\"可以开\",{\"1\":{\"11\":1}}],[\"可以算出\",{\"1\":{\"11\":1}}],[\"可以参考我的代码\",{\"1\":{\"5\":1}}],[\"配置\",{\"1\":{\"14\":1}}],[\"考虑到了这一点\",{\"1\":{\"14\":1}}],[\"编辑配置\",{\"1\":{\"14\":1}}],[\"编译器便会选择最近的\",{\"1\":{\"23\":1}}],[\"编译的项目也不需要考虑动态链接库的问题\",{\"1\":{\"14\":1}}],[\"编译\",{\"1\":{\"14\":1}}],[\"编写的\",{\"1\":{\"14\":1}}],[\"编写的随机数程序\",{\"1\":{\"2\":1}}],[\"编写项目\",{\"1\":{\"14\":1}}],[\"命令\",{\"1\":{\"14\":1}}],[\"命令创建一个名为\",{\"1\":{\"14\":1}}],[\"txt\",{\"1\":{\"61\":1}}],[\"this\",{\"1\":{\"42\":9}}],[\"thursday\",{\"1\":{\"20\":1}}],[\"t`\",{\"1\":{\"42\":1}}],[\"tmp\",{\"1\":{\"42\":2,\"49\":3}}],[\"true\",{\"1\":{\"35\":3}}],[\"t\",{\"1\":{\"32\":2,\"42\":12,\"46\":8,\"58\":2}}],[\"tab\",{\"1\":{\"20\":2}}],[\"typedef\",{\"1\":{\"20\":3,\"42\":6,\"46\":1}}],[\"types\",{\"0\":{\"20\":1,\"41\":1},\"1\":{\"20\":4,\"41\":1,\"43\":1}}],[\"tuesday\",{\"1\":{\"20\":2}}],[\"tetris项目\",{\"1\":{\"14\":1}}],[\"time\",{\"1\":{\"8\":2}}],[\"程序了\",{\"1\":{\"14\":1}}],[\"y+y\",{\"1\":{\"20\":1}}],[\"year\",{\"1\":{\"20\":5,\"23\":4}}],[\"y\",{\"1\":{\"14\":1,\"20\":10,\"35\":18}}],[\"保存\",{\"1\":{\"14\":1}}],[\"事实上我们还并没有将\",{\"1\":{\"14\":1}}],[\"文件夹\",{\"1\":{\"14\":1}}],[\"文件夹路径的命令行中输入\",{\"1\":{\"14\":1}}],[\"文件夹是存放项目代码的位置\",{\"1\":{\"14\":1}}],[\"文件便是这个\",{\"1\":{\"14\":1}}],[\"文件与\",{\"1\":{\"14\":1}}],[\"文章\",{\"0\":{\"1\":1}}],[\"项目的配置文件\",{\"1\":{\"14\":1}}],[\"项目名为例\",{\"1\":{\"14\":1}}],[\"项目打包好帮手\",{\"0\":{\"14\":1}}],[\"所有后面的问题对前面是没有影响的\",{\"1\":{\"35\":1}}],[\"所有的情况都探索完了\",{\"1\":{\"35\":1}}],[\"所有的位置都放好数字了\",{\"1\":{\"35\":1}}],[\"所有的程序都从这里开始执行\",{\"1\":{\"32\":1}}],[\"所有的前置步骤已经完成\",{\"1\":{\"14\":1}}],[\"所以在写\",{\"1\":{\"82\":1}}],[\"所以在此某\",{\"1\":{\"20\":1}}],[\"所以sfml的打开方式并不是像其他类型的文件一样\",{\"1\":{\"82\":1}}],[\"所以最后得出的结构是这样的\",{\"1\":{\"73\":1}}],[\"所以无法在这里加载\",{\"1\":{\"67\":1}}],[\"所以再准备一个load以备不时之需\",{\"1\":{\"67\":1}}],[\"所以为什么我们不自己写一个类\",{\"1\":{\"67\":1}}],[\"所以为什么不用\",{\"1\":{\"61\":1}}],[\"所以说\",{\"1\":{\"52\":1}}],[\"所以直接抄代码请你谨慎\",{\"1\":{\"49\":1}}],[\"所以函数参数部分\",{\"1\":{\"42\":1}}],[\"所以八皇后问题就是一个\",{\"1\":{\"35\":1}}],[\"所以终止条件依然少不了\",{\"1\":{\"35\":1}}],[\"所以一定要记得把标记去除\",{\"1\":{\"35\":1}}],[\"所以它的返回值肯定是我们想要得到的那个值\",{\"1\":{\"32\":1}}],[\"所以它实际上就是\",{\"1\":{\"20\":1}}],[\"所以某\",{\"1\":{\"26\":1}}],[\"所以实际上一个\",{\"1\":{\"20\":1}}],[\"所以你最好还是不要去尝试溢出\",{\"1\":{\"20\":1}}],[\"所以这里的容量和数组大小并不相同\",{\"1\":{\"49\":1}}],[\"所以这次题目难度变化不会很大\",{\"1\":{\"35\":1}}],[\"所以这次我们主要的关注点是变量类型以及一些要注意的点\",{\"1\":{\"20\":1}}],[\"所以这个数据范围\",{\"1\":{\"11\":1}}],[\"所以\",{\"1\":{\"11\":1,\"17\":1,\"20\":4,\"58\":1,\"70\":1}}],[\"所以我们这里只放上一个musiccount用来占位\",{\"1\":{\"82\":1}}],[\"所以我们需要把它强制类型转换为\",{\"1\":{\"58\":1}}],[\"所以我们可以尝试修改指针指向的地址来访问这个数组的任意一个位置\",{\"1\":{\"52\":1}}],[\"所以我们实际上只需要\",{\"1\":{\"38\":1}}],[\"所以我们怎么具体构造这个递归呢\",{\"1\":{\"38\":1}}],[\"所以我们想知道\",{\"1\":{\"38\":1}}],[\"所以我们很形象地把这种搜索优化方法称作剪枝\",{\"1\":{\"35\":1}}],[\"所以我们暂且先把这个放在一边\",{\"1\":{\"17\":1}}],[\"所以我们在这里正式推出c\",{\"1\":{\"17\":1}}],[\"所以我们的数组长度可以开到\",{\"1\":{\"11\":1}}],[\"所以我们自己写了一个\",{\"1\":{\"8\":1}}],[\"所以我们先把它处理了\",{\"1\":{\"2\":1}}],[\"所以还是需要一种更稳妥的读入数据的方式\",{\"1\":{\"2\":1}}],[\"所以当你发现你的\",{\"1\":{\"2\":1}}],[\"所以使用了自己用\",{\"1\":{\"2\":1}}],[\"启动\",{\"1\":{\"14\":2}}],[\"构建出我们想要的\",{\"1\":{\"64\":1}}],[\"构建工具链\",{\"1\":{\"14\":1}}],[\"构建系统\",{\"1\":{\"14\":1}}],[\"工具链和需要安装的内容\",{\"1\":{\"14\":1}}],[\"工具链\",{\"1\":{\"14\":1}}],[\"因此\",{\"1\":{\"32\":1,\"42\":1,\"43\":1}}],[\"因此十分有必要借助\",{\"1\":{\"14\":1}}],[\"因为音乐很长\",{\"1\":{\"82\":1}}],[\"因为我们想要的暂停效果只不过是给画面蒙上一层灰色透明的长方形\",{\"1\":{\"79\":1}}],[\"因为一会这个符号还有另一个含义\",{\"1\":{\"58\":1}}],[\"因为指针的操作非常复杂\",{\"1\":{\"58\":1}}],[\"因为内存总归是一位一位的\",{\"1\":{\"52\":1}}],[\"因为如果你没有学过之前学到的位运算\",{\"1\":{\"52\":1}}],[\"因为只是定义\",{\"1\":{\"42\":1}}],[\"因为确实有那么一点点难挑\",{\"1\":{\"38\":1}}],[\"因为每次扩容都需要重新申请一段内存\",{\"1\":{\"49\":1}}],[\"因为每次跑代码所得到的结果都不一样\",{\"1\":{\"8\":1}}],[\"因为每一层递归\",{\"1\":{\"38\":1}}],[\"因为根据了解\",{\"1\":{\"38\":1}}],[\"因为你在一些步骤中终点柱并不是最开始的那个终点柱\",{\"1\":{\"38\":1}}],[\"因为你实际上比一般的搜索优化了不少\",{\"1\":{\"35\":1}}],[\"因为你需要标记某一个点你有没有走过\",{\"1\":{\"35\":1}}],[\"因为这样的穷举方式是基于递归的\",{\"1\":{\"35\":1}}],[\"因为这些变量已经声明\",{\"1\":{\"32\":1}}],[\"因为这东西真的太好算辣\",{\"1\":{\"11\":1}}],[\"因为它需要从下往上画\",{\"1\":{\"79\":1}}],[\"因为它的使用会导致代码逻辑混乱\",{\"1\":{\"29\":1}}],[\"因为它并没有明确告诉你到底要用多大的数组才够用\",{\"1\":{\"11\":1}}],[\"因为会造成代码逻辑的混乱\",{\"1\":{\"29\":1}}],[\"因为\",{\"1\":{\"26\":1}}],[\"因为定义和处理部分完全可以不填\",{\"1\":{\"23\":1}}],[\"因为有时\",{\"1\":{\"23\":1}}],[\"因为存储空间占用至少是\",{\"1\":{\"20\":1}}],[\"因为上面已经读到一个了\",{\"1\":{\"2\":1}}],[\"因为是一个完整的数字\",{\"1\":{\"2\":1}}],[\"十分的阴间\",{\"1\":{\"52\":1}}],[\"十分的奇怪\",{\"1\":{\"11\":1}}],[\"十分影响使用体验\",{\"1\":{\"14\":1}}],[\"甚至不让用\",{\"1\":{\"52\":1}}],[\"甚至在一定程度上使用了魔法的情况下还会出现下载失败的情况\",{\"1\":{\"14\":1}}],[\"甚至你还可以利用\",{\"1\":{\"2\":1}}],[\"访问速度很慢\",{\"1\":{\"14\":1}}],[\"上面定义的方法都相当于是静态方法\",{\"1\":{\"42\":1}}],[\"上面的程序里面已经标注的很清楚了\",{\"1\":{\"35\":1}}],[\"上课内容听不懂\",{\"1\":{\"17\":1}}],[\"上随便找了一个\",{\"1\":{\"14\":1}}],[\"上\",{\"1\":{\"14\":1}}],[\"上都是非常有效的\",{\"1\":{\"2\":1}}],[\"镜像加速这个过程\",{\"1\":{\"14\":1}}],[\"镜像加速\",{\"1\":{\"14\":1}}],[\"安装指示在官方页面上写的非常清楚\",{\"1\":{\"14\":1}}],[\"安装\",{\"1\":{\"14\":1}}],[\"库中的函数实际上大多数的实现都是基于\",{\"1\":{\"20\":1}}],[\"库中的一些函数来解决较为实际的问题\",{\"1\":{\"20\":1}}],[\"库\",{\"1\":{\"14\":1}}],[\"好在我们现在仅仅是借助\",{\"1\":{\"14\":1}}],[\"导致你输出它们指向的变量的结果也就不同\",{\"1\":{\"52\":1}}],[\"导致最终的结果就不一样\",{\"1\":{\"52\":1}}],[\"导致编写代码十分的困难\",{\"1\":{\"14\":1}}],[\"导致在一些数据范围比较大的题目当中甚至出现了三重循环\",{\"1\":{\"11\":1}}],[\"解决它们的任务就交给同学们辣\",{\"1\":{\"35\":1}}],[\"解决这些问题估计死循环也很难存在了\",{\"1\":{\"11\":1}}],[\"解决这个问题的方法一般有两种\",{\"1\":{\"2\":1}}],[\"解析成功啦\",{\"1\":{\"14\":1}}],[\"解析\",{\"1\":{\"14\":1}}],[\"val\",{\"1\":{\"49\":8}}],[\"vec\",{\"1\":{\"49\":33}}],[\"vector\",{\"1\":{\"49\":3}}],[\"vis\",{\"1\":{\"35\":14}}],[\"vscode\",{\"1\":{\"14\":3,\"61\":1}}],[\"void\",{\"1\":{\"2\":1,\"32\":7,\"35\":3,\"38\":1,\"42\":5,\"46\":2,\"49\":8,\"58\":2}}],[\"带来不一样的构建体验\",{\"1\":{\"14\":1}}],[\"跨平台等特性\",{\"1\":{\"14\":1}}],[\"灵活使用可以提高代码的效率\",{\"1\":{\"23\":1}}],[\"灵活运用\",{\"1\":{\"20\":1}}],[\"灵活\",{\"1\":{\"14\":1}}],[\"利用\",{\"1\":{\"14\":1}}],[\"利用这种写法我们就获得了一种读入整数的更快的方式\",{\"1\":{\"2\":1}}],[\"支持多重编译器和平台\",{\"1\":{\"14\":1}}],[\"相当于在一张二维平面图上方一定距离处\",{\"1\":{\"82\":1}}],[\"相当于s\",{\"1\":{\"52\":1}}],[\"相当于乘上\",{\"1\":{\"23\":1}}],[\"相信加上注释和清晰的变量命名\",{\"1\":{\"49\":1}}],[\"相信使用\",{\"1\":{\"14\":1}}],[\"相信你们再也不会在群里问超时怎么办\",{\"1\":{\"11\":1}}],[\"相乘\",{\"1\":{\"8\":1}}],[\"经过测试的确是可以过的\",{\"1\":{\"11\":1}}],[\"经常在群里求数据解决问题是不可取的\",{\"1\":{\"8\":1}}],[\"个位成一个字节\",{\"1\":{\"20\":1}}],[\"个二进制位来表示的整数\",{\"1\":{\"20\":1}}],[\"个\",{\"1\":{\"11\":1}}],[\"个字节是\",{\"1\":{\"11\":1}}],[\"个字节\",{\"1\":{\"11\":3,\"20\":1}}],[\"kb\",{\"1\":{\"11\":2,\"20\":2}}],[\"多加空格\",{\"1\":{\"20\":1}}],[\"多\",{\"1\":{\"11\":1}}],[\"观察题目我们知道需要开两个\",{\"1\":{\"11\":1}}],[\"内容就能派上用场了\",{\"1\":{\"79\":1}}],[\"内部提供的镜像\",{\"1\":{\"14\":1}}],[\"内部的计算原理某\",{\"1\":{\"8\":1}}],[\"内存分配器这道题\",{\"1\":{\"11\":1}}],[\"三个数组\",{\"1\":{\"11\":1}}],[\"为什么要准备两种load\",{\"1\":{\"67\":1}}],[\"为什么要用\",{\"1\":{\"58\":1}}],[\"为单位\",{\"1\":{\"58\":1}}],[\"为了让我们能够很轻松地用简单的几句话控制音乐的播放\",{\"1\":{\"82\":1}}],[\"为了避免出现野指针\",{\"1\":{\"58\":1}}],[\"为了节约时间成本\",{\"1\":{\"49\":1}}],[\"为了和赋值语句区分开\",{\"1\":{\"23\":1}}],[\"为避免重名\",{\"1\":{\"42\":1}}],[\"为大家提供一些也许不是特别好的讲解\",{\"1\":{\"17\":1}}],[\"为例\",{\"1\":{\"14\":1}}],[\"为标准来提一提\",{\"1\":{\"11\":1}}],[\"为准\",{\"1\":{\"11\":1}}],[\"music打开方式的特殊性\",{\"1\":{\"67\":1}}],[\"multimedia\",{\"1\":{\"61\":1}}],[\"min\",{\"1\":{\"42\":3}}],[\"mirror\",{\"1\":{\"14\":1}}],[\"m+2ll\",{\"1\":{\"20\":1}}],[\"m\",{\"1\":{\"20\":3,\"35\":10}}],[\"month\",{\"1\":{\"20\":6}}],[\"monday\",{\"1\":{\"20\":2}}],[\"macos\",{\"1\":{\"61\":1}}],[\"malloc\",{\"1\":{\"42\":1,\"46\":2,\"49\":1,\"52\":1,\"58\":7}}],[\"max\",{\"1\":{\"42\":3}}],[\"math\",{\"1\":{\"20\":3}}],[\"main\",{\"1\":{\"8\":1,\"17\":2,\"20\":2,\"32\":4,\"38\":1,\"46\":1,\"49\":1}}],[\"msvc\",{\"1\":{\"14\":1}}],[\"mb\",{\"1\":{\"11\":5,\"20\":1}}],[\"仔细观察每道题的标题\",{\"1\":{\"11\":1}}],[\"404\",{\"1\":{\"85\":1}}],[\"400\",{\"1\":{\"23\":1}}],[\"400ll\",{\"1\":{\"20\":3}}],[\"4ll\",{\"1\":{\"20\":3}}],[\"4800ll\",{\"1\":{\"20\":1}}],[\"4=26214400\",{\"1\":{\"11\":1}}],[\"4\",{\"0\":{\"29\":1,\"70\":2,\"73\":1},\"1\":{\"11\":2,\"23\":1,\"29\":1,\"35\":2}}],[\"占用内存更加少而常被用在一些判断中\",{\"1\":{\"20\":1}}],[\"占\",{\"1\":{\"11\":3}}],[\"数列中的每一个位置上都存储了一个对应类型的变量\",{\"1\":{\"23\":1}}],[\"数组的时候不要加\",{\"1\":{\"58\":1}}],[\"数组后面方括号里面的数字实际上指的是相对于这个数组指针在内存上的偏移值\",{\"1\":{\"52\":1,\"58\":1}}],[\"数组这东西好理解啊\",{\"1\":{\"23\":1}}],[\"数组\",{\"1\":{\"11\":2,\"23\":1,\"35\":1,\"58\":1}}],[\"数据有了\",{\"1\":{\"8\":1}}],[\"数据按照标准应当是统一使用\",{\"1\":{\"2\":1}}],[\"xmake的安装位置\",{\"1\":{\"14\":1}}],[\"xmake支持几乎所有常见的工具链\",{\"1\":{\"14\":1}}],[\"xmake\",{\"0\":{\"14\":1},\"1\":{\"14\":24,\"61\":1}}],[\"x\",{\"1\":{\"11\":2,\"23\":3,\"32\":12,\"35\":20,\"49\":4}}],[\"说到递归\",{\"1\":{\"38\":1}}],[\"说不定加了剪枝\",{\"1\":{\"35\":1}}],[\"说人话\",{\"1\":{\"32\":1}}],[\"说一声就完事了\",{\"1\":{\"32\":1}}],[\"说的严重点\",{\"1\":{\"11\":1}}],[\"说明你是操作系统大神\",{\"1\":{\"8\":1}}],[\"远远超过了1亿\",{\"1\":{\"11\":1}}],[\"吗\",{\"1\":{\"11\":1}}],[\"算算超过了\",{\"1\":{\"11\":1}}],[\"次循环就快上不少\",{\"1\":{\"38\":1}}],[\"次循环就能解决这个问题\",{\"1\":{\"38\":1}}],[\"次循环次数\",{\"1\":{\"11\":1}}],[\"次循环次数大概刚好不过1s的时间限制\",{\"1\":{\"11\":1}}],[\"次就能将它分到最小\",{\"1\":{\"38\":1}}],[\"次\",{\"1\":{\"38\":1}}],[\"次方\",{\"1\":{\"23\":1}}],[\"次的循环次数\",{\"1\":{\"11\":1}}],[\"次所以这个程序实际上需要约\",{\"1\":{\"11\":1}}],[\"最终变成一层的可以直接解决的问题\",{\"1\":{\"38\":1}}],[\"最终得出的结果与只对结果取模是一样的\",{\"1\":{\"26\":1}}],[\"最后再将他们拼接到一起\",{\"1\":{\"64\":1}}],[\"最后我们来简单介绍一下归并排序\",{\"1\":{\"38\":1}}],[\"最后我们将这\",{\"1\":{\"38\":1}}],[\"最后把中间柱子上的那个盘子移到终点柱子上\",{\"1\":{\"38\":1}}],[\"最后是这个函数的主体部分\",{\"1\":{\"32\":1}}],[\"最底下的一层和上面\",{\"1\":{\"38\":1}}],[\"最适合的解决方法除了调试\",{\"1\":{\"35\":1}}],[\"最好先查清楚怎么用\",{\"1\":{\"20\":1}}],[\"最多只能表示到\",{\"1\":{\"20\":1}}],[\"最简单的方式是以1亿次循环为标准\",{\"1\":{\"20\":1}}],[\"最要紧的是排序的过程\",{\"1\":{\"11\":1}}],[\"最重要的来了\",{\"1\":{\"11\":1}}],[\"j\",{\"1\":{\"11\":1,\"38\":3}}],[\"例如\",{\"1\":{\"11\":1}}],[\"有些人特别钟爱用\",{\"1\":{\"49\":1}}],[\"有些同学可能做了这个题单发现有些题目递归来做特别容易超时\",{\"1\":{\"38\":1}}],[\"有的时候我们还是需要获取某个东西的绝对位置\",{\"1\":{\"70\":1}}],[\"有的\",{\"1\":{\"42\":2}}],[\"有关\",{\"1\":{\"14\":1}}],[\"有时剪枝是优化时间的很关键的一步\",{\"1\":{\"11\":1}}],[\"有负号\",{\"1\":{\"2\":1}}],[\"以\",{\"1\":{\"58\":1}}],[\"以方便我们进行碰撞检测等操作\",{\"1\":{\"70\":1}}],[\"以方便我们将\",{\"1\":{\"38\":1}}],[\"以方便在其它函数里面找到这个变量\",{\"1\":{\"58\":1}}],[\"以此类推\",{\"1\":{\"52\":1,\"58\":1}}],[\"以便于更好地理解\",{\"1\":{\"41\":1}}],[\"以后的题目中可能会出现对某一数字取模的情况\",{\"1\":{\"26\":1}}],[\"以避免一些逻辑上的问题\",{\"1\":{\"23\":1}}],[\"以避免空间超限和时间超限的问题\",{\"1\":{\"20\":1}}],[\"以及游戏音效的随意施放\",{\"1\":{\"82\":1}}],[\"以及\",{\"1\":{\"79\":1}}],[\"以及其中高得离谱的错误率\",{\"1\":{\"35\":2}}],[\"以及一种最重要的写法\",{\"1\":{\"23\":1}}],[\"以及之后要学到的\",{\"1\":{\"20\":1}}],[\"以及地图障碍的记录\",{\"1\":{\"20\":1}}],[\"以及剪枝是否到位\",{\"1\":{\"11\":1}}],[\"以外的编辑器使用\",{\"1\":{\"14\":1}}],[\"以表歉意\",{\"1\":{\"2\":1}}],[\"稍微超一点点也不大要紧\",{\"1\":{\"11\":1}}],[\"正是因为上述原因导致我们重复去求解了明明只需要求解一次的问题\",{\"1\":{\"38\":1}}],[\"正常做数据范围应该是能过的\",{\"1\":{\"35\":1}}],[\"正常机子\",{\"1\":{\"11\":1}}],[\"正确性验证\",{\"0\":{\"8\":1}}],[\"去掉一些没必要的常数\",{\"1\":{\"11\":1}}],[\"按照最大的数据范围计算出在最坏的情况下\",{\"1\":{\"11\":1}}],[\"看完这个\",{\"1\":{\"11\":1}}],[\"看够了再盯着自己循环次数最多的那个地方看\",{\"1\":{\"11\":1}}],[\"看看\",{\"1\":{\"11\":1}}],[\"一种理解是根据主角位置的不同将其他物体发出的声音按照方向环绕在玩家耳边\",{\"1\":{\"82\":1}}],[\"一种好的代码格式\",{\"1\":{\"20\":1}}],[\"一样痛苦的配环境环节\",{\"1\":{\"61\":1}}],[\"一不小心就会出错\",{\"1\":{\"58\":1}}],[\"一开始只是平平无奇的一个\",{\"1\":{\"52\":1}}],[\"一开始并没有考虑到这个问题\",{\"1\":{\"2\":1}}],[\"一个很简单的例子\",{\"1\":{\"79\":1}}],[\"一个变量\",{\"1\":{\"43\":1}}],[\"一个\",{\"1\":{\"35\":1,\"52\":2}}],[\"一个字符的时候\",{\"1\":{\"20\":1}}],[\"一定要把标记取消\",{\"1\":{\"35\":1}}],[\"一共有多少种排法\",{\"1\":{\"35\":1}}],[\"一直想让你们把关键的变量放在主函数外面的原因\",{\"1\":{\"32\":1}}],[\"一层一层\",{\"1\":{\"29\":1}}],[\"一些提示\",{\"1\":{\"23\":1}}],[\"一些注意点\",{\"1\":{\"20\":2}}],[\"一年中的月份\",{\"1\":{\"20\":1}}],[\"一一对应的给出\",{\"1\":{\"17\":1}}],[\"一次递归也算作一次循环\",{\"1\":{\"11\":1}}],[\"一问发现有些同学的算法不是很好\",{\"1\":{\"11\":1}}],[\"明明题目的时空限制放的都很宽啊\",{\"1\":{\"11\":1}}],[\"发现大家递归好像做的还行了\",{\"1\":{\"35\":1}}],[\"发现开始有越来越多的同学对空间超限以及时间超限发出了疑问\",{\"1\":{\"11\":1}}],[\"发出这个帖子之后\",{\"1\":{\"8\":1}}],[\"随着题目难度的增大\",{\"1\":{\"11\":1}}],[\"随机数据生成\",{\"0\":{\"8\":1}}],[\"虽然你也可以把它当作只有一个元素的数组使用\",{\"1\":{\"58\":1}}],[\"虽然这很好理解\",{\"1\":{\"52\":1}}],[\"虽然里面的参数好像不太一样\",{\"1\":{\"38\":1}}],[\"虽然某\",{\"1\":{\"26\":1}}],[\"虽然它实际上只有1bit\",{\"1\":{\"20\":1}}],[\"虽然\",{\"1\":{\"14\":1,\"20\":1}}],[\"虽然运气不好的话可能还是要跑很久\",{\"1\":{\"8\":1}}],[\"虽然说\",{\"1\":{\"2\":1}}],[\"生成之后的数据\",{\"1\":{\"8\":1}}],[\"found\",{\"1\":{\"85\":1}}],[\"for\",{\"0\":{\"23\":1,\"26\":1},\"1\":{\"11\":1,\"20\":1,\"23\":14,\"26\":2,\"35\":3,\"49\":4,\"52\":1}}],[\"fast\",{\"1\":{\"61\":1}}],[\"false\",{\"1\":{\"35\":4}}],[\"free\",{\"1\":{\"42\":1,\"46\":1,\"49\":2,\"58\":7}}],[\"friday\",{\"1\":{\"20\":1}}],[\"fib\",{\"1\":{\"38\":4}}],[\"first\",{\"1\":{\"35\":1}}],[\"files\",{\"1\":{\"14\":1}}],[\"file\",{\"1\":{\"8\":1}}],[\"function\",{\"0\":{\"32\":1},\"1\":{\"32\":1}}],[\"f\",{\"1\":{\"20\":1,\"38\":19}}],[\"flag\",{\"1\":{\"20\":1}}],[\"float\",{\"1\":{\"20\":6,\"52\":1}}],[\"fc对文件的判断要求可能比oj要求更高\",{\"1\":{\"8\":1}}],[\"fc\",{\"1\":{\"8\":2}}],[\"将游戏的内容继续压入\",{\"1\":{\"79\":1}}],[\"将标题画面的内容压入一个栈\",{\"1\":{\"79\":1}}],[\"将指令传入整棵树\",{\"1\":{\"76\":1}}],[\"将容量扩充至\",{\"1\":{\"49\":1}}],[\"将一些内容重述\",{\"1\":{\"41\":1}}],[\"将它们两两合并\",{\"1\":{\"38\":1}}],[\"将这种方法不太准确地称作递归的记忆化\",{\"1\":{\"38\":1}}],[\"将这个函数用在了约瑟夫问题当中\",{\"1\":{\"32\":1}}],[\"将基于递归的搜索的通用做法来给大家过一遍\",{\"1\":{\"35\":1}}],[\"将数组从\",{\"1\":{\"32\":1}}],[\"将\",{\"1\":{\"23\":1,\"35\":1}}],[\"将内容输入到程序中运行\",{\"1\":{\"8\":1}}],[\"将输出内容附到指定文件上<\",{\"1\":{\"8\":1}}],[\"洒洒水啦~>\",{\"1\":{\"8\":1}}],[\"嘛\",{\"1\":{\"8\":1}}],[\"关键的来了\",{\"1\":{\"42\":1}}],[\"关键字了\",{\"1\":{\"42\":1}}],[\"关闭输入显示\",{\"1\":{\"8\":1}}],[\"关于溢出\",{\"1\":{\"20\":1}}],[\"关于存储空间\",{\"1\":{\"20\":1}}],[\"关于整型变量的补充\",{\"1\":{\"20\":1}}],[\"关于\",{\"0\":{\"2\":1},\"1\":{\"20\":4}}],[\"p2\",{\"1\":{\"58\":5}}],[\"p2383\",{\"1\":{\"35\":1}}],[\"p1\",{\"1\":{\"58\":12}}],[\"p1433\",{\"1\":{\"35\":1}}],[\"push\",{\"0\":{\"79\":1},\"1\":{\"49\":3}}],[\"putchar\",{\"1\":{\"20\":1,\"52\":2}}],[\"pop\",{\"1\":{\"49\":2}}],[\"pos\",{\"1\":{\"46\":14,\"49\":10}}],[\"pointer\",{\"0\":{\"46\":1,\"49\":1,\"52\":1},\"1\":{\"46\":1,\"49\":1,\"52\":1}}],[\"pow\",{\"1\":{\"20\":2}}],[\"permutations\",{\"1\":{\"35\":2}}],[\"p\",{\"1\":{\"32\":1,\"58\":4}}],[\"pl\",{\"1\":{\"17\":1,\"32\":1}}],[\"p运行c\",{\"1\":{\"14\":1}}],[\"path\",{\"1\":{\"67\":2}}],[\"packages\",{\"1\":{\"14\":1}}],[\"pac=github\",{\"1\":{\"14\":1}}],[\"pause\",{\"1\":{\"8\":1,\"79\":1}}],[\"prev\",{\"1\":{\"46\":1}}],[\"proxy\",{\"1\":{\"14\":1}}],[\"problem\",{\"1\":{\"8\":1}}],[\"printf\",{\"1\":{\"8\":1,\"17\":4,\"20\":9,\"23\":4,\"29\":1,\"38\":3}}],[\"erase\",{\"1\":{\"49\":2}}],[\"errorlevel\",{\"1\":{\"8\":3}}],[\"ex\",{\"0\":{\"35\":1,\"46\":1,\"49\":1},\"1\":{\"35\":1,\"46\":1,\"49\":1}}],[\"exe\",{\"1\":{\"8\":6}}],[\"e\",{\"1\":{\"32\":1}}],[\"entity\",{\"1\":{\"73\":1}}],[\"engine\",{\"1\":{\"61\":1}}],[\"endofstorage\",{\"1\":{\"49\":5}}],[\"end\",{\"1\":{\"29\":2,\"49\":13}}],[\"enum\",{\"1\":{\"20\":2}}],[\"eof\",{\"1\":{\"26\":1}}],[\"else\",{\"1\":{\"23\":6,\"38\":1}}],[\"echooff\",{\"1\":{\"8\":1}}],[\"echo\",{\"1\":{\"8\":1}}],[\"接下来就大概的看一看实现的代码\",{\"1\":{\"49\":1}}],[\"接下来就轮到我们的对拍上场辣\",{\"1\":{\"8\":1}}],[\"接下来\",{\"1\":{\"35\":1,\"42\":1}}],[\"接下来进入十分重要的一环\",{\"1\":{\"35\":1}}],[\"接下来我们来具体解释这些批处理命令\",{\"1\":{\"8\":1}}],[\"接下来我们假设\",{\"1\":{\"8\":1}}],[\"接下来所有的文件都在同一个文件夹里\",{\"1\":{\"8\":1}}],[\"效率太低\",{\"1\":{\"8\":1}}],[\"学会了生成随机数\",{\"1\":{\"8\":1}}],[\"学习我的一些做法\",{\"1\":{\"5\":1}}],[\"到这里就不得不提一嘴\",{\"1\":{\"26\":1}}],[\"到\",{\"1\":{\"8\":3,\"32\":4,\"35\":1,\"38\":2}}],[\"就相当于\",{\"1\":{\"73\":1}}],[\"就相当于告诉\",{\"1\":{\"17\":1}}],[\"就不放了\",{\"1\":{\"73\":1}}],[\"就不需要写\",{\"1\":{\"42\":1}}],[\"就不在这里多写了\",{\"1\":{\"14\":1}}],[\"就行了\",{\"1\":{\"38\":1,\"61\":1}}],[\"就行了哦\",{\"1\":{\"32\":1}}],[\"就像斐波那契数列的第一和第二项一样\",{\"1\":{\"38\":1}}],[\"就没必要求下去了\",{\"1\":{\"35\":1}}],[\"就能得到\",{\"1\":{\"35\":1}}],[\"就需要将其中我们不需要的一些分支尽可能的去掉\",{\"1\":{\"35\":1}}],[\"就够了\",{\"1\":{\"35\":1}}],[\"就显得不那么优秀了\",{\"1\":{\"35\":1}}],[\"就是告诉函数它需要知道这些值\",{\"1\":{\"32\":1}}],[\"就是一个特殊的函数\",{\"1\":{\"32\":1}}],[\"就是取一个范围是\",{\"1\":{\"8\":1}}],[\"就只能借助这个库了\",{\"1\":{\"20\":1}}],[\"就变成了\",{\"1\":{\"20\":1}}],[\"就会输出对应的东西\",{\"1\":{\"17\":1}}],[\"就会发现\",{\"1\":{\"14\":1}}],[\"就停下来让你去\",{\"1\":{\"8\":1}}],[\"就在这里给大家介绍介绍\",{\"1\":{\"8\":1}}],[\"指令系统\",{\"0\":{\"76\":1}}],[\"指令的内部需要给出一个用\",{\"1\":{\"17\":1}}],[\"指不定就是内存泄露了\",{\"1\":{\"58\":1}}],[\"指针后再次使用\",{\"1\":{\"58\":1}}],[\"指针是\",{\"1\":{\"58\":1}}],[\"指针真的就没有了\",{\"1\":{\"52\":1}}],[\"指针指向这个\",{\"1\":{\"52\":1}}],[\"指针\",{\"0\":{\"58\":1},\"1\":{\"52\":1,\"58\":1}}],[\"指针等任意东西所占用的内存大小\",{\"1\":{\"11\":1}}],[\"指向的是一段内存空间的首地址\",{\"1\":{\"58\":1}}],[\"指向内存结尾\",{\"1\":{\"49\":1}}],[\"指向数组结尾\",{\"1\":{\"49\":1}}],[\"指向数组开头\",{\"1\":{\"49\":1}}],[\"指的是\",{\"1\":{\"58\":1}}],[\"指的是设置随机数种子\",{\"1\":{\"8\":1}}],[\"指的就是\",{\"1\":{\"8\":1}}],[\"指获取当前系统时间\",{\"1\":{\"8\":1}}],[\"值为val\",{\"1\":{\"49\":1}}],[\"值为\",{\"1\":{\"49\":1}}],[\"值\",{\"1\":{\"8\":1,\"32\":2}}],[\"它只需要负责所有实体都会做的事情\",{\"1\":{\"73\":1}}],[\"它在各大平台上都能顺利地运行\",{\"1\":{\"61\":1}}],[\"它基本上都考虑到了\",{\"1\":{\"61\":1}}],[\"它不会受限于当前作用域\",{\"1\":{\"58\":1}}],[\"它本质上是一个存储地址的变量\",{\"1\":{\"58\":1}}],[\"它很实在不会骗你\",{\"1\":{\"52\":1}}],[\"它很像一个从根开始不断分叉的树\",{\"1\":{\"35\":1}}],[\"它虽然优化了空间\",{\"1\":{\"49\":1}}],[\"它可能是整数\",{\"1\":{\"43\":1}}],[\"它将作为匿名结构体\",{\"1\":{\"42\":1}}],[\"它将多个不同类型的变量组合在一起\",{\"1\":{\"42\":1}}],[\"它将链接库也一起带了进去\",{\"1\":{\"14\":1}}],[\"它没有对象的概念\",{\"1\":{\"42\":1}}],[\"它又到底快在哪里呢\",{\"1\":{\"38\":1}}],[\"它们理解内存的方式不同\",{\"1\":{\"52\":1}}],[\"它们应该被称作起始柱子\",{\"1\":{\"38\":1}}],[\"它们的行号和列号相加是相等的\",{\"1\":{\"35\":1}}],[\"它们也正是搜索要注意的内容\",{\"1\":{\"35\":1}}],[\"它才能给你算出答案来\",{\"1\":{\"32\":1}}],[\"它才好将读入的值存过去\",{\"1\":{\"17\":1}}],[\"它来自于汇编语言\",{\"1\":{\"29\":1}}],[\"它就会一直执行\",{\"1\":{\"26\":1}}],[\"它是紧接着向后读一个字符\",{\"1\":{\"20\":1}}],[\"它是用\",{\"1\":{\"20\":1}}],[\"它的加载函数为openfromfile\",{\"1\":{\"67\":1}}],[\"它的含义就发生了改变\",{\"1\":{\"58\":1}}],[\"它的特点就是能够动态分配数组的内存\",{\"1\":{\"49\":1}}],[\"它的具体表现取决于编译器\",{\"1\":{\"20\":1}}],[\"它的最高位用来表示符号\",{\"1\":{\"20\":1}}],[\"它的能力是将它右侧的值赋给左侧的变量\",{\"1\":{\"17\":1}}],[\"它的默认内容如下\",{\"1\":{\"14\":1}}],[\"它最稳定\",{\"1\":{\"14\":1}}],[\"它有十分充足的仓库\",{\"1\":{\"14\":1}}],[\"它会将一段空间分配给你\",{\"1\":{\"58\":1}}],[\"它会从它能表示范围的另一端重新开始\",{\"1\":{\"20\":1}}],[\"它会在当前路径下创建一个名为\",{\"1\":{\"14\":1}}],[\"它会比较两个文件之间有什么区别\",{\"1\":{\"8\":1}}],[\"它会动态返回一个不同的\",{\"1\":{\"8\":1}}],[\"它实际上是以这个被围绕的实体为参照的相对位置\",{\"1\":{\"73\":1}}],[\"它实际上是\",{\"1\":{\"2\":1}}],[\"里面遗漏的东西\",{\"0\":{\"70\":1}}],[\"里面先搞\",{\"1\":{\"52\":1}}],[\"里面\",{\"1\":{\"52\":1,\"79\":1}}],[\"里面存三个指针\",{\"1\":{\"49\":1}}],[\"里面仍然有\",{\"1\":{\"23\":1}}],[\"里面的表示是\",{\"1\":{\"20\":6}}],[\"里面填入东西\",{\"1\":{\"17\":1}}],[\"里面看是什么数据\",{\"1\":{\"8\":1}}],[\"里\",{\"1\":{\"8\":1}}],[\"draw\",{\"1\":{\"79\":1}}],[\"dfs\",{\"1\":{\"35\":5}}],[\"dfs指的是深度优先搜索\",{\"1\":{\"35\":1}}],[\"development\",{\"1\":{\"82\":1}}],[\"dev\",{\"1\":{\"61\":2}}],[\"del\",{\"1\":{\"46\":1}}],[\"destroy\",{\"1\":{\"42\":1,\"49\":2}}],[\"depth\",{\"1\":{\"35\":1}}],[\"define\",{\"1\":{\"2\":1}}],[\"dy\",{\"1\":{\"35\":4}}],[\"dx\",{\"1\":{\"35\":4}}],[\"day\",{\"1\":{\"20\":6}}],[\"data3\",{\"1\":{\"42\":3,\"43\":4}}],[\"data2\",{\"1\":{\"42\":3,\"43\":4}}],[\"data1\",{\"1\":{\"42\":4,\"43\":4}}],[\"data\",{\"0\":{\"41\":1},\"1\":{\"8\":4,\"41\":1,\"42\":13,\"43\":7,\"46\":3}}],[\"dot\",{\"0\":{\"87\":1}}],[\"dotoj\",{\"1\":{\"52\":1},\"2\":{\"18\":1,\"19\":1,\"21\":1,\"22\":1,\"24\":1,\"25\":1,\"27\":1,\"28\":1,\"30\":1,\"31\":1,\"33\":1,\"34\":1,\"36\":1,\"37\":1,\"39\":1,\"40\":1,\"44\":1,\"45\":1,\"47\":1,\"48\":1,\"50\":1,\"51\":1,\"53\":1,\"54\":1,\"56\":1,\"57\":1,\"59\":1,\"60\":1}}],[\"dotoj补完计划\",{\"1\":{\"17\":1,\"32\":1}}],[\"dog\",{\"1\":{\"42\":8}}],[\"do\",{\"1\":{\"26\":3,\"58\":1}}],[\"double\",{\"1\":{\"20\":6,\"42\":2,\"43\":1}}],[\"d\",{\"1\":{\"8\":2,\"17\":5,\"20\":1,\"26\":1,\"29\":2,\"32\":1,\"38\":3,\"49\":1}}],[\"back\",{\"1\":{\"49\":5}}],[\"bat\",{\"1\":{\"8\":1}}],[\"begin\",{\"1\":{\"49\":21}}],[\"break\",{\"1\":{\"23\":1,\"26\":1,\"29\":1}}],[\"byte\",{\"1\":{\"20\":3,\"58\":1}}],[\"bool\",{\"1\":{\"20\":6,\"35\":3,\"79\":1}}],[\"b\",{\"1\":{\"8\":2,\"11\":2,\"17\":2,\"20\":3,\"26\":2,\"38\":5,\"42\":9,\"58\":6}}],[\"apt\",{\"1\":{\"61\":1}}],[\"and\",{\"1\":{\"61\":1}}],[\"ans=day+\",{\"1\":{\"20\":1}}],[\"ans\",{\"1\":{\"20\":2,\"29\":3,\"35\":9}}],[\"age\",{\"1\":{\"42\":1}}],[\"array\",{\"0\":{\"23\":1},\"1\":{\"23\":3}}],[\"argv\",{\"1\":{\"20\":1,\"49\":1}}],[\"argc\",{\"1\":{\"20\":1,\"49\":1}}],[\"abs\",{\"1\":{\"20\":1}}],[\"ascii\",{\"1\":{\"20\":1}}],[\"add\",{\"1\":{\"14\":1,\"46\":1}}],[\"a+b\",{\"1\":{\"8\":1}}],[\"a\",{\"0\":{\"26\":1},\"1\":{\"8\":2,\"11\":2,\"17\":6,\"20\":5,\"23\":6,\"26\":7,\"32\":5,\"35\":1,\"38\":7,\"42\":10,\"43\":1,\"58\":12}}],[\"handleevent\",{\"1\":{\"79\":1}}],[\"hanoi\",{\"1\":{\"38\":3}}],[\"https\",{\"1\":{\"61\":1}}],[\"h\",{\"1\":{\"8\":1,\"17\":3,\"20\":4,\"52\":1}}],[\"h>\",{\"1\":{\"8\":2,\"17\":2,\"20\":1,\"46\":2,\"49\":3}}],[\"h当中有定义\",{\"1\":{\"2\":1}}],[\"首先找到这个变量的变量名\",{\"1\":{\"58\":1}}],[\"首先用if特判解决掉最小的问题\",{\"1\":{\"38\":1}}],[\"首先是这个函数的返回值类型\",{\"1\":{\"32\":1}}],[\"首先\",{\"1\":{\"32\":1,\"35\":1,\"52\":1}}],[\"首先先来列一下常见的变量类型\",{\"1\":{\"20\":1}}],[\"首先在指定的文件夹路径下使用\",{\"1\":{\"14\":1}}],[\"首先你会需要循环n次来读入\",{\"1\":{\"11\":1}}],[\"首先我们需要一个保证正确的代码生成的可执行文件用来作为标准输出正确答案\",{\"1\":{\"8\":1}}],[\"首先我们需要自己写个程序来生成随机的测试数据\",{\"1\":{\"8\":1}}],[\"首先没有那么多的测试数据来给\",{\"1\":{\"8\":1}}],[\"其他的位置已经由主角决定好\",{\"1\":{\"73\":1}}],[\"其次\",{\"1\":{\"35\":1}}],[\"其次也并不知道你错在哪里\",{\"1\":{\"8\":1}}],[\"其它的搜索也许在形式上略有不同\",{\"1\":{\"35\":1}}],[\"其它的也不太容易错\",{\"1\":{\"23\":1}}],[\"其它的逻辑判断符号除了相等\",{\"1\":{\"23\":1}}],[\"其它内容个人根据需求自己看\",{\"1\":{\"20\":1}}],[\"其它情况下\",{\"1\":{\"2\":1}}],[\"其实上面那道图上寻路就可以进行剪枝优化\",{\"1\":{\"35\":1}}],[\"其实这章题目还是挺水的\",{\"1\":{\"32\":1}}],[\"其实在大部分情况下\",{\"1\":{\"20\":1}}],[\"其实十分的简单\",{\"1\":{\"11\":1}}],[\"其中未定义的数组元素会被赋值成\",{\"1\":{\"49\":1}}],[\"其中包含内部所有字段的空间\",{\"1\":{\"42\":1}}],[\"其中\",{\"1\":{\"14\":1,\"17\":1}}],[\"其中用取模来限制\",{\"1\":{\"8\":1}}],[\"别忘了每次更新的时候要把已经播放完的音效清除\",{\"1\":{\"82\":1}}],[\"别忘了包含stdlib\",{\"1\":{\"52\":1}}],[\"别忘了取消标记\",{\"1\":{\"35\":1}}],[\"别忘了给我点颗星~o\",{\"1\":{\"5\":1}}],[\"别人是错的你也不一定就是错的\",{\"1\":{\"8\":1}}],[\"别人是对的你不一定对\",{\"1\":{\"8\":1}}],[\"错误也很可能出在五花八门的地方\",{\"1\":{\"8\":1}}],[\"老师貌似是有选择性的听取了上次开会的提议\",{\"1\":{\"32\":1}}],[\"老师和其它同学的不尊重\",{\"1\":{\"5\":1}}],[\"老老实实使用\",{\"1\":{\"2\":1}}],[\"特别注意\",{\"1\":{\"35\":1}}],[\"特别的\",{\"1\":{\"32\":1}}],[\"特别一些\",{\"1\":{\"23\":1}}],[\"特别地\",{\"1\":{\"14\":1,\"58\":1}}],[\"特别提醒\",{\"1\":{\"5\":1,\"38\":1,\"49\":1}}],[\"特以此篇\",{\"1\":{\"2\":1}}],[\">data\",{\"1\":{\"46\":2}}],[\">next\",{\"1\":{\"46\":10}}],[\">prev\",{\"1\":{\"46\":7}}],[\">age\",{\"1\":{\"42\":1}}],[\">min\",{\"1\":{\"42\":1}}],[\">max\",{\"1\":{\"42\":1}}],[\">swap\",{\"1\":{\"42\":1}}],[\">>\",{\"1\":{\"23\":1}}],[\">\",{\"1\":{\"8\":3,\"11\":1,\"32\":1,\"35\":6,\"38\":3,\"42\":1,\"49\":5}}],[\">ω<\",{\"1\":{\"5\":1}}],[\">=\",{\"1\":{\"2\":1}}],[\"game\",{\"1\":{\"82\":1}}],[\"gui等进行更新是在是太麻烦了\",{\"1\":{\"76\":1}}],[\"godot\",{\"1\":{\"61\":1}}],[\"goto\",{\"1\":{\"8\":5,\"29\":5}}],[\"get函数的实现\",{\"1\":{\"67\":1}}],[\"get\",{\"1\":{\"49\":1}}],[\"getchar\",{\"1\":{\"2\":10,\"20\":1}}],[\"grow\",{\"1\":{\"42\":3}}],[\"gitee\",{\"1\":{\"14\":1}}],[\"git\",{\"1\":{\"14\":1}}],[\"gitignore\",{\"1\":{\"14\":1}}],[\"github\",{\"1\":{\"5\":1,\"14\":2}}],[\"g\",{\"1\":{\"14\":1}}],[\"并尽可能阻止内存泄露\",{\"0\":{\"67\":1}}],[\"并返回这段空间的首地址\",{\"1\":{\"58\":1}}],[\"并把它存在了\",{\"1\":{\"58\":1}}],[\"并不会影响前面你走过某个点\",{\"1\":{\"35\":1}}],[\"并不会严格的证明\",{\"1\":{\"26\":1}}],[\"并不是某种标准的命名法\",{\"1\":{\"20\":1}}],[\"并不清楚\",{\"1\":{\"8\":1}}],[\"并编辑includepath\",{\"1\":{\"14\":1}}],[\"并将代码拷贝到了\",{\"1\":{\"14\":1}}],[\"并回车\",{\"1\":{\"14\":1}}],[\"并询问是否需要安装\",{\"1\":{\"14\":1}}],[\"并像这样添加到配置当中即可\",{\"1\":{\"14\":1}}],[\"并在该文件夹中生成以下目录结构\",{\"1\":{\"14\":1}}],[\"并没有\",{\"1\":{\"11\":1}}],[\"并且某\",{\"1\":{\"38\":1}}],[\"并且我们要求你把所有的排法情况按照字典序输出\",{\"1\":{\"35\":1}}],[\"并且这些文件正好适合\",{\"1\":{\"14\":1}}],[\"并且输出结果if\",{\"1\":{\"8\":1}}],[\"并且编写了一段较为详尽的教程来告诉你我是怎么写出这个项目的\",{\"1\":{\"5\":1}}],[\"并直接在\",{\"1\":{\"2\":1}}],[\"恰好完成了其中一道期末项目的要求\",{\"1\":{\"5\":1}}],[\"还要考虑到球绕着主角的旋转情况\",{\"1\":{\"73\":1}}],[\"还关不掉\",{\"1\":{\"58\":1}}],[\"还没有明白递归到底是干嘛用的\",{\"1\":{\"38\":1}}],[\"还不明白\",{\"1\":{\"32\":1}}],[\"还有背景\",{\"1\":{\"76\":1}}],[\"还有一个重要的知识点\",{\"1\":{\"26\":1}}],[\"还有一些其它的数据范围\",{\"1\":{\"11\":1}}],[\"还有逻辑或\",{\"1\":{\"23\":1}}],[\"还有\",{\"1\":{\"20\":1,\"79\":1}}],[\"还有for循环有没有写成别的奇怪的东西\",{\"1\":{\"11\":1}}],[\"还在为不知道怎么写cpl课程的小游戏项目而烦恼吗\",{\"1\":{\"5\":1}}],[\"还是有一点的\",{\"1\":{\"46\":1}}],[\"还是建议同学们使用当周的知识点解决问题\",{\"1\":{\"20\":1}}],[\"还是\",{\"1\":{\"2\":1}}],[\"小游戏项目不知道怎么写\",{\"0\":{\"5\":1}}],[\"org\",{\"1\":{\"61\":1}}],[\"output\",{\"1\":{\"35\":1}}],[\"out\",{\"1\":{\"8\":4,\"17\":1}}],[\"off\",{\"1\":{\"8\":1}}],[\"o\",{\"1\":{\"5\":1}}],[\"otz\",{\"1\":{\"2\":1,\"17\":1}}],[\"oj\",{\"0\":{\"87\":1},\"1\":{\"2\":2,\"52\":1}}],[\"我就想用这个\",{\"1\":{\"61\":1}}],[\"我可不管\",{\"1\":{\"61\":1}}],[\"我相信大家都不想到处花上好几行的代码来实现它\",{\"1\":{\"58\":1}}],[\"我警告过你了\",{\"1\":{\"49\":1}}],[\"我每次求解出其中一个子问题就把它存到一个数组里边\",{\"1\":{\"38\":1}}],[\"我不会\",{\"1\":{\"61\":1}}],[\"我不知道\",{\"1\":{\"61\":1}}],[\"我不说是谁\",{\"1\":{\"49\":1}}],[\"我不说是哪道题\",{\"1\":{\"46\":1}}],[\"我不到啊\",{\"1\":{\"38\":1}}],[\"我不是佬\",{\"1\":{\"17\":1}}],[\"我是多少\",{\"1\":{\"38\":1}}],[\"我在\",{\"1\":{\"14\":1}}],[\"我把项目放在\",{\"1\":{\"5\":1}}],[\"我将代码都留了下来\",{\"1\":{\"5\":1}}],[\"我这恰好一不小心花了点时间写了一个小项目\",{\"1\":{\"5\":1}}],[\"我来助你\",{\"0\":{\"5\":1}}],[\"我真的错了\",{\"1\":{\"2\":1}}],[\"我们直接用上\",{\"1\":{\"82\":1}}],[\"我们直接输出移动方式就行了\",{\"1\":{\"38\":1}}],[\"我们有必要写两个类来分别处理音乐和音效\",{\"1\":{\"82\":1}}],[\"我们有时想要让下层的界面也要显示出来\",{\"1\":{\"79\":1}}],[\"我们想要达成这个简单的压入弹出\",{\"1\":{\"79\":1}}],[\"我们想要优化搜索\",{\"1\":{\"35\":1}}],[\"我们游戏的场景之间的切换\",{\"1\":{\"79\":1}}],[\"我们引入指令系统\",{\"1\":{\"76\":1}}],[\"我们借着scenenode顺便实现一下实体类\",{\"1\":{\"73\":1}}],[\"我们甚至能为这个闪电球再添加围绕它的别的什么球\",{\"1\":{\"73\":1}}],[\"我们甚至可以利用空间限制来另辟蹊径\",{\"1\":{\"11\":1}}],[\"我们把闪电球作为子节点连接到主角上\",{\"1\":{\"73\":1}}],[\"我们把它想象成一个有限长的数列\",{\"1\":{\"23\":1}}],[\"我们显然需要一个单独的东西来处理游戏音乐和音效的\",{\"1\":{\"67\":1}}],[\"我们尽量把这些过程都拆开\",{\"1\":{\"64\":1}}],[\"我们为什么不把它重新包装一下\",{\"1\":{\"64\":1}}],[\"我们用\",{\"1\":{\"58\":1}}],[\"我们用不同数据类型的指针指向这个变量\",{\"1\":{\"52\":1}}],[\"我们怎么来使用\",{\"1\":{\"58\":1}}],[\"我们现在得到了变量\",{\"1\":{\"58\":1}}],[\"我们现在还无法理解\",{\"1\":{\"17\":1}}],[\"我们建立的是指针变量\",{\"1\":{\"58\":1}}],[\"我们假设它是\",{\"1\":{\"58\":1}}],[\"我们注意到上面的malloc申请的实际上是一段连续的内存\",{\"1\":{\"52\":1}}],[\"我们使用malloc来申请内存\",{\"1\":{\"52\":1}}],[\"我们都知道\",{\"1\":{\"79\":1}}],[\"我们都清楚这次的\",{\"1\":{\"52\":1}}],[\"我们都非常清楚\",{\"1\":{\"2\":1}}],[\"我们创建一个\",{\"1\":{\"42\":1}}],[\"我们一定要解决所有的逆序对才行\",{\"1\":{\"38\":1}}],[\"我们一直在写的\",{\"1\":{\"32\":1}}],[\"我们实际上等价于对整个数组循环一边\",{\"1\":{\"38\":1}}],[\"我们得先清楚我们要从哪里开始画\",{\"1\":{\"79\":1}}],[\"我们得先把上面那个盘子移到中间柱子上面\",{\"1\":{\"38\":1}}],[\"我们得有最小的问题的答案\",{\"1\":{\"38\":1}}],[\"我们先写出类似学习sdl时的游戏结构\",{\"1\":{\"64\":1}}],[\"我们先解释一下归并排序的具体原理\",{\"1\":{\"38\":1}}],[\"我们先将\",{\"1\":{\"38\":1}}],[\"我们先来找边界条件\",{\"1\":{\"38\":1}}],[\"我们先用递归的思路来考虑这个问题\",{\"1\":{\"35\":1}}],[\"我们还是得好好理解为什么可以这样写\",{\"1\":{\"52\":1}}],[\"我们还是用斐波那契数列来举例子\",{\"1\":{\"38\":1}}],[\"我们还学习了数组\",{\"1\":{\"23\":1}}],[\"我们不想用它\",{\"1\":{\"38\":1}}],[\"我们不知道它是多少\",{\"1\":{\"38\":1}}],[\"我们不是碰到无关的就跳过\",{\"1\":{\"2\":1}}],[\"我们该怎么处理\",{\"1\":{\"38\":1}}],[\"我们知道数组的名字就是指向它第一个元素的指针\",{\"1\":{\"52\":1,\"58\":1}}],[\"我们知道\",{\"1\":{\"42\":1,\"58\":1}}],[\"我们知道自己是1\",{\"1\":{\"38\":1}}],[\"我们知道一个\",{\"1\":{\"11\":1}}],[\"我们肯定少不了前两项\",{\"1\":{\"38\":1}}],[\"我们肯定得从斐波那契数列讲起\",{\"1\":{\"38\":1}}],[\"我们去掉了一些没必要的搜索\",{\"1\":{\"35\":1}}],[\"我们去填下一位\",{\"1\":{\"35\":1}}],[\"我们稍微修改一下上面的代码\",{\"1\":{\"35\":1}}],[\"我们要找到最短路径\",{\"1\":{\"35\":1}}],[\"我们按照\",{\"1\":{\"35\":1}}],[\"我们便只需要考虑球的旋转就行\",{\"1\":{\"73\":1}}],[\"我们便实现了一个简单的操作\",{\"1\":{\"32\":1}}],[\"我们便能对大量的数据进行处理\",{\"1\":{\"23\":1}}],[\"我们来分析一下函数的定义方法\",{\"1\":{\"32\":1}}],[\"我们来具体解析几个陌生的东西\",{\"1\":{\"8\":1}}],[\"我们将n层的问题\",{\"1\":{\"38\":1}}],[\"我们将\",{\"1\":{\"32\":1}}],[\"我们在\",{\"1\":{\"32\":1}}],[\"我们在结尾附上位运算的运算法则\",{\"1\":{\"23\":1}}],[\"我们在后面加上方括号\",{\"1\":{\"23\":1}}],[\"我们在程序中输入输出都离不开它\",{\"1\":{\"17\":1}}],[\"我们也需要通过指定位置来调用某一个元素\",{\"1\":{\"23\":1}}],[\"我们也学到了基本的输入输出指令\",{\"1\":{\"17\":1}}],[\"我们需要根据4中的树形编排方式再实现一点点东西\",{\"1\":{\"70\":1}}],[\"我们需要开一个长度为\",{\"1\":{\"52\":1}}],[\"我们需要特别注意这一点\",{\"1\":{\"32\":1}}],[\"我们需要提前指定这个数组的大小\",{\"1\":{\"23\":1}}],[\"我们需要相对于原来的语句额外缩进一个\",{\"1\":{\"20\":1}}],[\"我们可以用\",{\"1\":{\"73\":1}}],[\"我们可以给每一个加载的内容都带上一个特殊的id\",{\"1\":{\"67\":1}}],[\"我们可以找到\",{\"1\":{\"58\":1}}],[\"我们可以利用这个swap函数来将某个和这个函数没有半毛钱关系的变量交换值\",{\"1\":{\"58\":1}}],[\"我们可以写一些更方便的函数来让我们的代码更加简洁\",{\"1\":{\"58\":1}}],[\"我们可以实现很多高级功能\",{\"1\":{\"58\":1}}],[\"我们可以将函数赋值给这些成员\",{\"1\":{\"42\":1}}],[\"我们可以使用函数指针来申明一些结构体成员\",{\"1\":{\"42\":1}}],[\"我们可以更加形象地解释一下\",{\"1\":{\"38\":1}}],[\"我们可以通过\",{\"1\":{\"26\":1}}],[\"我们可以看出\",{\"1\":{\"20\":1}}],[\"我们可以分出大概\",{\"1\":{\"11\":1}}],[\"我们又学了赋值语句和基本的四则运算\",{\"1\":{\"17\":1}}],[\"我们只是想不允许下一层内容更新\",{\"1\":{\"79\":1}}],[\"我们只要处理当前这一位我们要填什么\",{\"1\":{\"35\":1}}],[\"我们只要写出一行\",{\"1\":{\"17\":1}}],[\"我们只需要知道\",{\"1\":{\"17\":1}}],[\"我们只需要在仓库中找到对应的库名\",{\"1\":{\"14\":1}}],[\"我们学会了\",{\"1\":{\"17\":1}}],[\"我们每周的c语言课后会尽快在洛谷挑选一些适合大家练习的题目\",{\"1\":{\"17\":1}}],[\"我们的oj题目与上课内容脱节\",{\"1\":{\"17\":1}}],[\"我们已经准备好编译运行我们的\",{\"1\":{\"14\":1}}],[\"我们以上面的\",{\"1\":{\"32\":1}}],[\"我们以\",{\"1\":{\"14\":1}}],[\"我们就拿它来举例\",{\"1\":{\"52\":1}}],[\"我们就不需要进一步考虑下一个子问题了\",{\"1\":{\"35\":1}}],[\"我们就能得出求解八皇后问题的方法\",{\"1\":{\"35\":1}}],[\"我们就能定义一个名为\",{\"1\":{\"17\":1}}],[\"我们就可以使用\",{\"1\":{\"20\":2}}],[\"我们就可以根据不同题目的输入要求来构造大量的随机数据啦\",{\"1\":{\"8\":1}}],[\"我们就直接输出\",{\"1\":{\"35\":1}}],[\"我们就直接\",{\"1\":{\"8\":1}}],[\"我们并无法确定出题人用的是\",{\"1\":{\"2\":1}}],[\"出题\",{\"1\":{\"2\":1}}],[\"出现了意想不到的问题\",{\"1\":{\"2\":1}}],[\"达成了目标\",{\"1\":{\"2\":1}}],[\"而已\",{\"1\":{\"79\":1}}],[\"而将一个数组变为有序数组\",{\"1\":{\"38\":1}}],[\"而将一个长度为n的序列分割至最小需要\",{\"1\":{\"11\":1}}],[\"而将这个数组二分我们只需要分\",{\"1\":{\"38\":1}}],[\"而时间有的时候很难看出来有没有超\",{\"1\":{\"38\":1}}],[\"而我们如何去写递归\",{\"1\":{\"38\":1}}],[\"而当n\",{\"1\":{\"38\":1}}],[\"而当我们写入\",{\"1\":{\"17\":1}}],[\"而是根据音乐播放的进度选取文件当中的某一段读入\",{\"1\":{\"82\":1}}],[\"而是只会被在其前面的子问题影响\",{\"1\":{\"35\":1}}],[\"而是不断读入直到读入到我们需要的东西再进行处理\",{\"1\":{\"2\":1}}],[\"而仅仅是作为一个操作存在\",{\"1\":{\"32\":1}}],[\"而如果使用\",{\"1\":{\"23\":1}}],[\"而如果没有加大括号\",{\"1\":{\"23\":1}}],[\"而不是loadfromfile\",{\"1\":{\"67\":1}}],[\"而不是指针本身\",{\"1\":{\"58\":1}}],[\"而不是终点柱上\",{\"1\":{\"38\":1}}],[\"而不是和原来那句并排写\",{\"1\":{\"20\":1}}],[\"而不去在意输入格式的具体情况\",{\"1\":{\"2\":1}}],[\"而之后的给出的变量必须与按照前面字符串中出现的\",{\"1\":{\"17\":1}}],[\"而要想写入数据\",{\"1\":{\"17\":1}}],[\"而io指的是输入输出\",{\"1\":{\"17\":1}}],[\"而借助空间限制我们可以了解到\",{\"1\":{\"11\":1}}],[\"而且\",{\"1\":{\"76\":1}}],[\"而且它具有非常良好的跨平台能力\",{\"1\":{\"61\":1}}],[\"而且它实际上指向了数组的第一个元素\",{\"1\":{\"52\":1}}],[\"而且题目也解释的很清楚\",{\"1\":{\"52\":1}}],[\"而且从头到尾顺序访问并不受影响\",{\"1\":{\"46\":1}}],[\"而且所有字段共享同一块内存空间\",{\"1\":{\"43\":1}}],[\"而且当前路径之前并没有走过\",{\"1\":{\"35\":1}}],[\"而且别人看了至少也会觉着蛮清爽的\",{\"1\":{\"20\":1}}],[\"而且你想追求更大一些的表示范围的话\",{\"1\":{\"20\":1}}],[\"而且我们能用上面的输入输出来对这个变量进行操作\",{\"1\":{\"17\":1}}],[\"而且我们并不需要知道这是什么意思\",{\"1\":{\"17\":1}}],[\"而且找到我想要的数据就算运气好也要花不少时间\",{\"1\":{\"8\":1}}],[\"而且这样手动生成数据\",{\"1\":{\"8\":1}}],[\"而\",{\"1\":{\"8\":1,\"14\":1,\"17\":1,\"20\":2,\"23\":1}}],[\"你还需要东西来分类存储他们\",{\"1\":{\"76\":1}}],[\"你自己心里面应该有数\",{\"1\":{\"64\":1}}],[\"你用得到的功能\",{\"1\":{\"61\":1}}],[\"你一定要记得把指针空置\",{\"1\":{\"58\":1}}],[\"你想要申请一个\",{\"1\":{\"58\":1}}],[\"你想知道它们占了多少空间\",{\"1\":{\"11\":1}}],[\"你便没有办法再获得它了\",{\"1\":{\"58\":1}}],[\"你必须得在确定了输入之后再新建数组\",{\"1\":{\"58\":1}}],[\"你必须用逗号隔开并分别指定每一个变量的类型\",{\"1\":{\"32\":1}}],[\"你现在想把它存下来\",{\"1\":{\"58\":1}}],[\"你成功的取出了\",{\"1\":{\"58\":1}}],[\"你们应该能看懂\",{\"1\":{\"49\":1}}],[\"你最好加上前缀\",{\"1\":{\"42\":1}}],[\"你只需要一位一位读入二进制然后把它弄到一个\",{\"1\":{\"52\":1}}],[\"你只应当在清楚自己到底在做什么的时候使用它\",{\"1\":{\"43\":1}}],[\"你只能通过传入实例来实现\",{\"1\":{\"42\":1}}],[\"你只能在创建的时候立刻使用它\",{\"1\":{\"42\":1}}],[\"你只要尽可能顶着空间限制开\",{\"1\":{\"11\":1}}],[\"你没法再在别处使用它\",{\"1\":{\"42\":1}}],[\"你创建了这样一个类型\",{\"1\":{\"42\":1}}],[\"你需要先定义结构体类型及其成员\",{\"1\":{\"42\":1}}],[\"你第一步是要移到中间柱上\",{\"1\":{\"38\":1}}],[\"你有三个方向可以走\",{\"1\":{\"35\":1}}],[\"你走到某一个点\",{\"1\":{\"35\":1}}],[\"你能直接通过返回值来立即离开这个已经没有用的函数\",{\"1\":{\"32\":1}}],[\"你实际上可以发现函数只不过是把一些东西放到另一个地方去写罢了\",{\"1\":{\"32\":1}}],[\"你也可以不给结构体名字\",{\"1\":{\"42\":1}}],[\"你也可以使用\",{\"1\":{\"32\":1}}],[\"你也可以把\",{\"1\":{\"23\":1}}],[\"你也可以为某个特定的枚举指定值\",{\"1\":{\"20\":1}}],[\"你也可以借助空间限制来完成一些本来不可能的操作\",{\"1\":{\"11\":1}}],[\"你几乎能在里面找到所有你想要使用的\",{\"1\":{\"14\":1}}],[\"你再仔细看你会发现它大概是\",{\"1\":{\"11\":1}}],[\"你都需要进行\",{\"1\":{\"11\":1}}],[\"你会发现一个叫做空间限制的东西\",{\"1\":{\"11\":1}}],[\"你会发现它们在时间上的复杂度都是n²\",{\"1\":{\"11\":1}}],[\"你会发现\",{\"1\":{\"11\":1,\"14\":1,\"35\":1}}],[\"你要对这个数据进行归并排序\",{\"1\":{\"11\":1}}],[\"你这里的循环要进行多少次\",{\"1\":{\"11\":1}}],[\"你盯着数据范围看\",{\"1\":{\"11\":1}}],[\"你就堆在主函数里面\",{\"1\":{\"32\":1}}],[\"你就一定得知道该用多大\",{\"1\":{\"11\":1}}],[\"你就可以通过这些东西来计算自己应该用哪种数据类型\",{\"1\":{\"11\":1}}],[\"你就会发现用\",{\"1\":{\"2\":1}}],[\"你可以把它当作数组使用\",{\"1\":{\"58\":1}}],[\"你可以这样写\",{\"1\":{\"58\":1}}],[\"你可以用\",{\"1\":{\"58\":1}}],[\"你可以去看看之后出来的指针ex\",{\"1\":{\"52\":1}}],[\"你可以不写变量名\",{\"1\":{\"42\":1}}],[\"你可以在\",{\"1\":{\"42\":1}}],[\"你可以将\",{\"1\":{\"42\":1}}],[\"你可以将多个\",{\"1\":{\"8\":1}}],[\"你可以直接把它标记为已经走过\",{\"1\":{\"35\":1}}],[\"你可以编写一个判断是否确认符合进制规则的函数\",{\"1\":{\"32\":1}}],[\"你可以调用和修改这些变量\",{\"1\":{\"32\":1}}],[\"你可以采取更花式的写法\",{\"1\":{\"23\":1}}],[\"你可以使用逻辑与\",{\"1\":{\"23\":1}}],[\"你可以使用\",{\"1\":{\"20\":1,\"23\":2}}],[\"你可以开着这个程序来自动找到使你程序出错的针对性数据\",{\"1\":{\"8\":1}}],[\"你的程序虽然还是暴力\",{\"1\":{\"35\":1}}],[\"你的程序生成的可执行文件叫\",{\"1\":{\"8\":1}}],[\"你的\",{\"0\":{\"14\":1}}],[\"你的随机数程序生成的可执行文件叫\",{\"1\":{\"8\":1}}],[\"你猜怎么着\",{\"1\":{\"5\":1}}],[\"你看到我们是怎样绕过\",{\"1\":{\"2\":1}}],[\"处理符号问题\",{\"1\":{\"2\":1}}],[\"只能朝上下左右四个方向走\",{\"1\":{\"35\":1}}],[\"只能拿到\",{\"1\":{\"2\":1}}],[\"只需要配置好编译命令或者\",{\"1\":{\"61\":1}}],[\"只需要分配一块内存空间即可\",{\"1\":{\"43\":1}}],[\"只需要知道\",{\"1\":{\"38\":1}}],[\"只需要知道一个程序不能少了上面代码的任何一个东西\",{\"1\":{\"17\":1}}],[\"只需要在这三个数都符合条件的情况下\",{\"1\":{\"32\":1}}],[\"只多了一个\",{\"1\":{\"29\":1}}],[\"只要返回空的不就行了嘛\",{\"1\":{\"32\":1}}],[\"只要括号里的条件成立\",{\"1\":{\"26\":1}}],[\"只要你的思路没有错误\",{\"1\":{\"23\":1}}],[\"只有判断条件成立\",{\"1\":{\"23\":1}}],[\"只不过人家是\",{\"1\":{\"20\":1}}],[\"只不过位运算和加法都比乘法快\",{\"1\":{\"2\":1}}],[\"只是一种辅助手段\",{\"1\":{\"43\":1}}],[\"只是一个想为大家着想的菜菜oier\",{\"1\":{\"17\":1}}],[\"只是命令不同而已\",{\"1\":{\"8\":1}}],[\"+=\",{\"1\":{\"32\":1,\"42\":1}}],[\"++vec\",{\"1\":{\"49\":2}}],[\"++l\",{\"1\":{\"32\":1}}],[\"++i\",{\"1\":{\"23\":2,\"35\":3,\"49\":2,\"52\":1}}],[\"++j\",{\"1\":{\"11\":1}}],[\"+365ll\",{\"1\":{\"20\":1}}],[\"+1\",{\"1\":{\"20\":1}}],[\"+\",{\"1\":{\"2\":3,\"8\":2,\"11\":2,\"14\":2,\"17\":1,\"20\":12,\"26\":1,\"32\":1,\"35\":9,\"38\":5,\"49\":10,\"52\":1,\"58\":1}}],[\"3d\",{\"1\":{\"82\":1}}],[\"3时\",{\"1\":{\"38\":1}}],[\"365ll\",{\"1\":{\"20\":2}}],[\"3ll\",{\"1\":{\"20\":1}}],[\"31\",{\"1\":{\"20\":1}}],[\"32045\",{\"1\":{\"20\":3}}],[\"32\",{\"1\":{\"20\":3,\"52\":4}}],[\"3\",{\"0\":{\"26\":1,\"67\":1},\"1\":{\"2\":2,\"26\":1,\"38\":1,\"42\":1,\"43\":1}}],[\"<string\",{\"1\":{\"49\":1}}],[\"<stdlib\",{\"1\":{\"46\":1,\"49\":1}}],[\"<stdio\",{\"1\":{\"17\":2,\"20\":1,\"46\":1,\"49\":1}}],[\"<\",{\"1\":{\"8\":2,\"26\":2,\"32\":2,\"35\":6,\"38\":1,\"42\":1,\"49\":2,\"52\":1}}],[\"<<\",{\"1\":{\"2\":4,\"23\":2}}],[\"<=\",{\"1\":{\"2\":1,\"11\":1,\"23\":2,\"35\":3}}],[\"==\",{\"1\":{\"2\":1,\"23\":4,\"29\":1,\"35\":6,\"38\":3,\"49\":3,\"58\":1}}],[\"=\",{\"1\":{\"2\":8,\"8\":2,\"11\":1,\"17\":4,\"20\":7,\"23\":18,\"26\":3,\"29\":2,\"32\":5,\"35\":23,\"38\":4,\"42\":11,\"43\":3,\"46\":15,\"49\":20,\"52\":3,\"58\":12}}],[\"islowerstatevisible\",{\"1\":{\"79\":1}}],[\"isdigit\",{\"1\":{\"2\":4}}],[\"io就这些\",{\"1\":{\"20\":1}}],[\"io\",{\"0\":{\"20\":1},\"1\":{\"20\":3}}],[\"i\",{\"1\":{\"11\":1,\"23\":6,\"35\":13,\"38\":3,\"49\":17,\"52\":5}}],[\"install\",{\"1\":{\"61\":1}}],[\"insert\",{\"1\":{\"49\":2}}],[\"initialize\",{\"1\":{\"49\":2}}],[\"includepath\",{\"1\":{\"14\":1}}],[\"include\",{\"1\":{\"14\":3,\"17\":3,\"20\":1,\"46\":2,\"49\":3}}],[\"include<stdlib\",{\"1\":{\"8\":1}}],[\"include<stdio\",{\"1\":{\"8\":1}}],[\"in\",{\"1\":{\"8\":4,\"17\":1}}],[\"integer\",{\"1\":{\"20\":2}}],[\"intro\",{\"0\":{\"17\":1},\"1\":{\"17\":2}}],[\"int\",{\"1\":{\"2\":3,\"8\":7,\"11\":5,\"17\":8,\"20\":20,\"23\":4,\"29\":1,\"32\":10,\"35\":19,\"38\":6,\"42\":20,\"43\":1,\"46\":3,\"49\":28,\"52\":10,\"58\":19}}],[\"if\",{\"0\":{\"23\":1},\"1\":{\"2\":1,\"8\":2,\"20\":1,\"23\":20,\"29\":1,\"32\":2,\"35\":13,\"38\":3,\"46\":3,\"49\":6,\"58\":2}}],[\"9\",{\"1\":{\"2\":1,\"35\":1}}],[\"0\",{\"0\":{\"17\":1},\"1\":{\"2\":3,\"8\":3,\"17\":4,\"20\":8,\"23\":24,\"29\":3,\"32\":2,\"35\":12,\"38\":1,\"46\":1,\"49\":6,\"52\":2}}],[\"分而治之\",{\"1\":{\"64\":1}}],[\"分支结构以及循环结构\",{\"1\":{\"23\":1}}],[\"分\",{\"1\":{\"2\":1}}],[\"不仅仅是\",{\"1\":{\"82\":1}}],[\"不仅限于此\",{\"1\":{\"14\":1}}],[\"不说也应该知道干啥了吧\",{\"1\":{\"76\":1}}],[\"不好用\",{\"1\":{\"76\":1}}],[\"不好用了\",{\"1\":{\"2\":1}}],[\"不算高效但是更方便的游戏更新策略\",{\"0\":{\"76\":1}}],[\"不支持的类型\",{\"1\":{\"67\":1}}],[\"不是吗\",{\"1\":{\"64\":1}}],[\"不然到时候很有可能搞不清自己到底在做什么\",{\"1\":{\"64\":1}}],[\"不然没法调用数组的任意一个位置\",{\"1\":{\"52\":1}}],[\"不然就等着死循环吧\",{\"1\":{\"35\":1}}],[\"不允许使用\",{\"1\":{\"52\":1}}],[\"不\",{\"1\":{\"49\":1}}],[\"不具体讲了\",{\"1\":{\"38\":1}}],[\"不需要排序\",{\"1\":{\"38\":1}}],[\"不就行了吗\",{\"1\":{\"38\":1}}],[\"不能被随便拷贝\",{\"1\":{\"73\":1}}],[\"不能走\",{\"1\":{\"35\":1}}],[\"不能给出更有针对性的数据\",{\"1\":{\"8\":1}}],[\"不要继续往下找了\",{\"1\":{\"35\":1}}],[\"不要听题解瞎说\",{\"1\":{\"35\":1}}],[\"不要想着去运行\",{\"1\":{\"32\":1}}],[\"不足的将填上0\",{\"1\":{\"23\":1}}],[\"不一定每一个部分都要死板的填上东西\",{\"1\":{\"23\":1}}],[\"不建议使用除\",{\"1\":{\"14\":1}}],[\"不过有需要注意的一点\",{\"1\":{\"79\":1}}],[\"不过我们也并不会在resourceholder里面加载这种文件\",{\"1\":{\"67\":1}}],[\"不过我们在这里还需要补充一些东西\",{\"1\":{\"52\":1}}],[\"不过总体上来说\",{\"1\":{\"49\":1}}],[\"不过记得\",{\"1\":{\"38\":1}}],[\"不过归并的过程略微有些烧脑\",{\"1\":{\"38\":1}}],[\"不过\",{\"1\":{\"35\":1}}],[\"不过貌似也不是特别多的亚子\",{\"1\":{\"35\":1}}],[\"不过oj的机子貌似比较好\",{\"1\":{\"11\":1}}],[\"不过还好\",{\"1\":{\"2\":1}}],[\"当游戏画面渲染的时候\",{\"1\":{\"79\":1}}],[\"当这个函数结束\",{\"1\":{\"58\":1}}],[\"当中已经讲的差不多了\",{\"1\":{\"52\":1}}],[\"当中有它\",{\"1\":{\"49\":1}}],[\"当起始柱子上只有一个盘子的时候\",{\"1\":{\"38\":1}}],[\"当返回的时候\",{\"1\":{\"35\":1}}],[\"当返回前一位的时候\",{\"1\":{\"35\":1}}],[\"当所有的位置都填好了\",{\"1\":{\"35\":1}}],[\"当填好这一位\",{\"1\":{\"35\":1}}],[\"当一个函数有了返回值\",{\"1\":{\"32\":1}}],[\"当输入不确定数量的数据时\",{\"1\":{\"26\":1}}],[\"当输入数据一切正常的时候\",{\"1\":{\"2\":1}}],[\"当同学们使用\",{\"1\":{\"23\":1}}],[\"当\",{\"1\":{\"23\":1}}],[\"当我们想要获取某个变量的地址\",{\"1\":{\"58\":1}}],[\"当我们想要合并两个序列的时候\",{\"1\":{\"38\":1}}],[\"当我们用不同变量类型的指针指向同一个\",{\"1\":{\"52\":1}}],[\"当我们搞好这个\",{\"1\":{\"52\":1}}],[\"当我们需要交换两个相邻的数时\",{\"1\":{\"38\":1}}],[\"当我们到达终点或者没有路走了\",{\"1\":{\"35\":1}}],[\"当我们思考一道题如何去做的时候\",{\"1\":{\"20\":1}}],[\"当我们在定义过\",{\"1\":{\"58\":1}}],[\"当我们在做题的时候\",{\"1\":{\"20\":1}}],[\"当我们在\",{\"1\":{\"17\":1}}],[\"当我们的做法受到限制的时候\",{\"1\":{\"11\":1}}],[\"当然都需要是\",{\"1\":{\"52\":1}}],[\"当然还有第一题我们需要提到的指针问题\",{\"1\":{\"52\":1}}],[\"当然还要算上其它的一些变量函数啥的也会占内存\",{\"1\":{\"11\":1}}],[\"当然这只是解决那道题其中的一种方法\",{\"1\":{\"38\":1}}],[\"当然可以啊\",{\"1\":{\"32\":1}}],[\"当然\",{\"1\":{\"11\":1,\"20\":2,\"52\":1}}],[\"当然printf也有点点慢\",{\"1\":{\"2\":1}}],[\"当你结束游戏\",{\"1\":{\"79\":1}}],[\"当你选择开始游玩\",{\"1\":{\"79\":1}}],[\"当你启动游戏的时候\",{\"1\":{\"79\":1}}],[\"当你使用完了之后\",{\"1\":{\"58\":1}}],[\"当你想根据输入的值来确定你的数组大小时\",{\"1\":{\"58\":1}}],[\"当你想好你将会怎么来做这道题之后\",{\"1\":{\"11\":1}}],[\"当你在点\",{\"1\":{\"35\":1}}],[\"当你在很多地方都要做同一种操作\",{\"1\":{\"32\":1}}],[\"当你的函数已经得出结论\",{\"1\":{\"32\":1}}],[\"当你将函数定义在这些变量后面的时候\",{\"1\":{\"32\":1}}],[\"当你将系统时间设置为随机数种子的时候\",{\"1\":{\"8\":1}}],[\"当你\",{\"1\":{\"20\":1}}],[\"当你超过一个整形变量能够表示的范围时\",{\"1\":{\"20\":1}}],[\"当你拿不到完全分的时候\",{\"1\":{\"20\":1}}],[\"当你每次将某一个序列分割的时候\",{\"1\":{\"11\":1}}],[\"当某\",{\"1\":{\"8\":1}}],[\"直到将数组拆成长度为1\",{\"1\":{\"38\":1}}],[\"直到达到边界\",{\"1\":{\"38\":1}}],[\"直到读到非数字\",{\"1\":{\"2\":1}}],[\"直到读到我们需要的数字\",{\"1\":{\"2\":1}}],[\"直到读入到自己需要的数据\",{\"1\":{\"2\":1}}],[\"直接把它挪到终点柱子就好了\",{\"1\":{\"38\":1}}],[\"直接走\",{\"1\":{\"35\":1}}],[\"直接返回\",{\"1\":{\"35\":2}}],[\"直接跳过这一个方向\",{\"1\":{\"35\":1}}],[\"直接输出\",{\"1\":{\"35\":1}}],[\"直接上代码你就懂了\",{\"1\":{\"8\":1}}],[\"直接使用\",{\"1\":{\"2\":1}}],[\"wednesday\",{\"1\":{\"20\":1}}],[\"week\",{\"1\":{\"20\":1}}],[\"while\",{\"0\":{\"26\":1},\"1\":{\"2\":3,\"23\":1,\"26\":10,\"32\":2}}],[\"windows\",{\"1\":{\"2\":5,\"8\":2,\"14\":1,\"61\":1}}],[\"用这种结构\",{\"1\":{\"73\":1}}],[\"用于视觉特效的sf\",{\"1\":{\"67\":1}}],[\"用起来爽到高超\",{\"1\":{\"61\":1}}],[\"用地址\",{\"1\":{\"58\":1}}],[\"用一用的\",{\"1\":{\"49\":1}}],[\"用0占掉了第一格\",{\"1\":{\"35\":2}}],[\"用来表示这个数字是正数还是负数\",{\"1\":{\"2\":1}}],[\"用\",{\"1\":{\"2\":2,\"61\":1}}],[\"如不指定\",{\"1\":{\"20\":1}}],[\"如果直接使用绝对位置来计算固然可以\",{\"1\":{\"73\":1}}],[\"如果当前容量不够需要重新申请内存\",{\"1\":{\"49\":1}}],[\"如果有误自己去改\",{\"1\":{\"46\":1}}],[\"如果有一种代码能够统一的表示这些操作\",{\"1\":{\"32\":1}}],[\"如果滥用\",{\"1\":{\"43\":1}}],[\"如果一些方法涉及到与结构体实例发生交互\",{\"1\":{\"42\":1}}],[\"如果没有边界\",{\"1\":{\"38\":1}}],[\"如果想寻求些挑战\",{\"1\":{\"52\":1}}],[\"如果想要了解如何不超时\",{\"1\":{\"38\":1}}],[\"如果想用\",{\"1\":{\"20\":1}}],[\"如果已经走的步数都超过了现有的答案\",{\"1\":{\"35\":1}}],[\"如果这个位置在地图范围之外\",{\"1\":{\"35\":1}}],[\"如果这个位置并不能走\",{\"1\":{\"35\":1}}],[\"如果这个数字没有被用过\",{\"1\":{\"35\":1}}],[\"如果某个方向上是能走的路\",{\"1\":{\"35\":1}}],[\"如果某个方向上是障碍物或者地图边界\",{\"1\":{\"35\":1}}],[\"如果仍然不是很理解\",{\"1\":{\"35\":1}}],[\"如果我们将问题扩展到n皇后问题\",{\"1\":{\"35\":1}}],[\"如果说我们把前面已经找过的皇后全部过一遍一个一个判断\",{\"1\":{\"35\":1}}],[\"如果使用\",{\"1\":{\"23\":1}}],[\"如果判断不成立\",{\"1\":{\"23\":1}}],[\"如果条件不成立\",{\"1\":{\"23\":1}}],[\"如果该位是\",{\"1\":{\"20\":1}}],[\"如果它大于等于\",{\"1\":{\"11\":1}}],[\"如果看上去并不会超但是却时间超限了\",{\"1\":{\"11\":1}}],[\"如果不是\",{\"1\":{\"8\":1}}],[\"如果是一个数组\",{\"1\":{\"58\":1}}],[\"如果是\",{\"1\":{\"8\":1,\"26\":1}}],[\"如果需要更大的数据\",{\"1\":{\"8\":1}}],[\"如果你发现你的程序越跑越慢\",{\"1\":{\"58\":1}}],[\"如果你还在别处需要这个数组\",{\"1\":{\"58\":1}}],[\"如果你在这个变量名前面加上\",{\"1\":{\"58\":1}}],[\"如果你将整个搜索过程画图表示出来\",{\"1\":{\"35\":1}}],[\"如果你想要传入多个参数\",{\"1\":{\"32\":1}}],[\"如果你想使用多种判断\",{\"1\":{\"23\":1}}],[\"如果你想使用静态数组\",{\"1\":{\"11\":1}}],[\"如果你并没有学习函数并能灵活使用\",{\"1\":{\"32\":1}}],[\"如果你确定不会出现负数\",{\"1\":{\"20\":1}}],[\"如果你直接写变量名\",{\"1\":{\"17\":1}}],[\"如果你空间超限\",{\"1\":{\"11\":1}}],[\"如果你正在使用你是\",{\"1\":{\"8\":1}}],[\"如果你做过\",{\"1\":{\"2\":1}}],[\"如果你会用正则表达式的话\",{\"1\":{\"2\":1}}],[\"如若抄袭并不幸被查重\",{\"1\":{\"5\":1}}],[\"如何绕过这些问题呢\",{\"1\":{\"2\":1}}],[\"那想法就很简单了\",{\"1\":{\"79\":1}}],[\"那太麻烦了\",{\"1\":{\"76\":1}}],[\"那就是第二个元素\",{\"1\":{\"52\":1}}],[\"那就是第一个元素\",{\"1\":{\"52\":1}}],[\"那这个时候它本身就是有序的\",{\"1\":{\"38\":1}}],[\"那他之后怎么走都不会比答案更好了\",{\"1\":{\"35\":1}}],[\"那怎么办呢\",{\"1\":{\"35\":1}}],[\"那该多好啊\",{\"1\":{\"32\":1}}],[\"那自然写出来的代码是十分臃肿的\",{\"1\":{\"32\":1}}],[\"那样只会导致更大的混乱\",{\"1\":{\"20\":1}}],[\"那\",{\"1\":{\"17\":1}}],[\"那也就是每个数组有\",{\"1\":{\"11\":1}}],[\"那肯定没问题\",{\"1\":{\"11\":1}}],[\"那它肯定不会让你的空间超过这个限制\",{\"1\":{\"11\":1}}],[\"那你肯定就寄了\",{\"1\":{\"11\":1}}],[\"那你可以尝试输出\",{\"1\":{\"11\":1}}],[\"那你完全不用担心超时\",{\"1\":{\"11\":1}}],[\"那你也来看看吧\",{\"1\":{\"5\":1}}],[\"那往往是死循环导致的\",{\"1\":{\"11\":1}}],[\"那么借助指针的这个性质\",{\"1\":{\"58\":1}}],[\"那么它的数组名就是指向它第一个元素的地址\",{\"1\":{\"58\":1}}],[\"那么恭喜你\",{\"1\":{\"58\":1}}],[\"那么恭喜你犯了除编译错误以外第二傻的问题\",{\"1\":{\"11\":1}}],[\"那么数组到底是什么意思呢\",{\"1\":{\"52\":1,\"58\":1}}],[\"那么就可以使用联合体来存储\",{\"1\":{\"43\":1}}],[\"那么就走过去\",{\"1\":{\"35\":1}}],[\"那么答案初始值应该是最大的\",{\"1\":{\"35\":1}}],[\"那么这次的oj作业对你来说仍然十分煎熬磨人\",{\"1\":{\"32\":1}}],[\"那么这两个文件之间并没有差异\",{\"1\":{\"8\":1}}],[\"那么可以跳过求解步骤直接输出答案\",{\"1\":{\"29\":1}}],[\"那么\",{\"1\":{\"14\":1,\"17\":1,\"32\":1,\"42\":1}}],[\"那么你会发现\",{\"1\":{\"11\":1}}],[\"那么我们可以这样写\",{\"1\":{\"58\":1}}],[\"那么我们为什么不用不同的指针指向同一个\",{\"1\":{\"52\":1}}],[\"那么我们实际上需要排序下标\",{\"1\":{\"38\":1}}],[\"那么我们能怎么解决重复求解的问题呢\",{\"1\":{\"38\":1}}],[\"那么我们只要枚举每一行的皇后的列坐标就行\",{\"1\":{\"35\":1}}],[\"那么我们到底该怎么样控制我们程序的时空复杂度呢\",{\"1\":{\"11\":1}}],[\"那么我们怎么能更高效的获得可能使你程序出错的数据呢\",{\"1\":{\"8\":1}}],[\"那么说明有问题\",{\"1\":{\"8\":1}}],[\"那我们面临的将是无穷无尽的鄙视链\",{\"1\":{\"38\":1}}],[\"那我们就以\",{\"1\":{\"11\":1}}],[\"那我们可以利用\",{\"1\":{\"2\":1}}],[\"那我用我自己的程序跑出结果我也不知道对不对啊\",{\"1\":{\"8\":1}}],[\"那可真是太巧了\",{\"1\":{\"5\":1}}],[\"那用\",{\"1\":{\"2\":1}}],[\"那在\",{\"1\":{\"2\":1}}],[\"要想看懂它\",{\"1\":{\"46\":1}}],[\"要推出斐波那契数列\",{\"1\":{\"38\":1}}],[\"要是真的不知道大项目该怎么写\",{\"1\":{\"5\":1}}],[\"要慢不少\",{\"1\":{\"2\":1}}],[\"要智能的多\",{\"1\":{\"2\":1}}],[\"比起冒泡排序和选择排序的\",{\"1\":{\"38\":1}}],[\"比较麻烦\",{\"1\":{\"29\":1}}],[\"比如游戏暂停的时候\",{\"1\":{\"79\":1}}],[\"比如某游戏中主角有一个闪电球始终环绕着旋转\",{\"1\":{\"73\":1}}],[\"比如交换两个数\",{\"1\":{\"58\":1}}],[\"比如动态内存分配\",{\"1\":{\"58\":1}}],[\"比如我们想要排序下标从1到n的一个数组\",{\"1\":{\"38\":1}}],[\"比如将除法提前\",{\"1\":{\"26\":1}}],[\"比如开根\",{\"1\":{\"20\":1}}],[\"比如一周的星期几\",{\"1\":{\"20\":1}}],[\"比如一个\",{\"1\":{\"20\":1}}],[\"比如你可以使用\",{\"1\":{\"20\":1}}],[\"比如\",{\"1\":{\"11\":1,\"20\":5,\"23\":2,\"42\":1,\"43\":1}}],[\"比如说我们想要输出这个字符数组\",{\"1\":{\"52\":1}}],[\"比如说某些非逼你需要动态维护数组大小的\",{\"1\":{\"46\":1}}],[\"比如说你需要在创建时初始化一些字段值\",{\"1\":{\"42\":1}}],[\"比如说你开了一些数组\",{\"1\":{\"11\":1}}],[\"比如说两层的时候\",{\"1\":{\"38\":1}}],[\"比如说要想知道\",{\"1\":{\"38\":1}}],[\"比如说大家可能已经尝试通过在主函数里直接\",{\"1\":{\"32\":1}}],[\"比如说上面那个长式子\",{\"1\":{\"20\":1}}],[\"比如说\",{\"1\":{\"11\":1,\"58\":1}}],[\"比\",{\"1\":{\"2\":2,\"20\":1}}],[\"但实际上和单个\",{\"1\":{\"58\":1}}],[\"但实际上这个不是最要紧的\",{\"1\":{\"11\":1}}],[\"但抛开好理解不谈\",{\"1\":{\"52\":1}}],[\"但它也用掉了一部分的时间用来维护这个动态数组\",{\"1\":{\"49\":1}}],[\"但我们更习惯称它位动态数组\",{\"1\":{\"49\":1}}],[\"但反而更有利于代码的管理\",{\"1\":{\"42\":1}}],[\"但你会发现你实际上大部分的代码都是在复制粘贴\",{\"1\":{\"32\":1}}],[\"但当处在多重循环之中\",{\"1\":{\"29\":1}}],[\"但某\",{\"1\":{\"20\":1}}],[\"但可以为这个变量的特定值附上特定的名字\",{\"1\":{\"20\":1}}],[\"但\",{\"1\":{\"14\":1,\"58\":2}}],[\"但不要太多\",{\"1\":{\"11\":1}}],[\"但用另一种方式\",{\"1\":{\"2\":1}}],[\"但是在画面上我们仍想要看到下一层内容\",{\"1\":{\"79\":1}}],[\"但是十分麻烦\",{\"1\":{\"73\":1}}],[\"但是太麻烦了\",{\"1\":{\"67\":1}}],[\"但是已经能足够我们写一些简单的东西了\",{\"1\":{\"64\":1}}],[\"但是没有题\",{\"1\":{\"58\":1}}],[\"但是指针也是\",{\"1\":{\"58\":1}}],[\"但是不同的变量类型理解内存上每一位的方式不一样\",{\"1\":{\"52\":1}}],[\"但是不能直接抄袭\",{\"1\":{\"5\":1}}],[\"但是显然题目不允许我们这样做\",{\"1\":{\"52\":1}}],[\"但是链表的好处在于它的内存是动态的\",{\"1\":{\"46\":1}}],[\"但是它只能存放一种数据类型\",{\"1\":{\"43\":1}}],[\"但是它们更快\",{\"1\":{\"20\":1}}],[\"但是结构体如果用的好的话\",{\"1\":{\"42\":1}}],[\"但是冒泡排序太慢了\",{\"1\":{\"38\":1}}],[\"但是冒泡排序和插入排序它们就不太好过了\",{\"1\":{\"11\":1}}],[\"但是如果你将\",{\"1\":{\"38\":1}}],[\"但是我们能知道它由\",{\"1\":{\"38\":1}}],[\"但是就是能过\",{\"1\":{\"35\":1}}],[\"但是也逃不过这种思路\",{\"1\":{\"35\":1}}],[\"但是这对我们理解递归有很有效的帮助\",{\"1\":{\"38\":1}}],[\"但是这样做\",{\"1\":{\"35\":1}}],[\"但是这种智能\",{\"1\":{\"2\":1}}],[\"但是好像基于递归来暴力求解一些问题还不太熟练\",{\"1\":{\"35\":1}}],[\"但是数量增加\",{\"1\":{\"35\":1}}],[\"但是他告诉同学们\",{\"1\":{\"26\":1}}],[\"但是使用时\",{\"1\":{\"23\":1}}],[\"但是适当的空行可以让你的程序看起来区分步骤更加明显\",{\"1\":{\"20\":1}}],[\"但是表示的精度有限\",{\"1\":{\"20\":1}}],[\"但是实际用起来效果并不尽如人意\",{\"1\":{\"14\":1}}],[\"但是请注意范围可能会超过\",{\"1\":{\"8\":1}}],[\"但是大部分情况下\",{\"1\":{\"2\":1}}],[\"但是\",{\"1\":{\"2\":1,\"64\":1}}],[\"但是交上去就不大对劲\",{\"1\":{\"2\":1}}],[\"2d\",{\"1\":{\"82\":1}}],[\"2ll\",{\"1\":{\"20\":2}}],[\"255\",{\"1\":{\"20\":2}}],[\"256\",{\"1\":{\"11\":3}}],[\"2147483647\",{\"1\":{\"20\":2,\"35\":2}}],[\"2147483648\",{\"1\":{\"20\":4}}],[\"2023\",{\"1\":{\"35\":1}}],[\"2022\",{\"0\":{\"17\":1,\"20\":1,\"23\":1,\"26\":1,\"29\":1,\"32\":1,\"35\":1,\"38\":1,\"41\":1,\"46\":1,\"49\":1,\"52\":1}}],[\"200\",{\"1\":{\"11\":1}}],[\"2\",{\"0\":{\"23\":1,\"64\":1},\"1\":{\"2\":1,\"17\":1,\"23\":3,\"26\":1,\"35\":2,\"38\":12,\"49\":1,\"58\":4}}],[\"是一款非常好用的图形界面库\",{\"1\":{\"61\":1}}],[\"是一种非常好的做法\",{\"1\":{\"2\":1}}],[\"是非常优秀的数据结构\",{\"1\":{\"46\":1}}],[\"是最难的题\",{\"1\":{\"35\":1}}],[\"是不是感觉比不用函数的思路简单许多\",{\"1\":{\"32\":1}}],[\"是我们建的数组的名字\",{\"1\":{\"23\":1}}],[\"是我们常用的小数变量类型\",{\"1\":{\"20\":1}}],[\"是个整十数的年份\",{\"1\":{\"23\":1}}],[\"是闰年\",{\"1\":{\"23\":1}}],[\"是因为在计算机中\",{\"1\":{\"20\":1}}],[\"是它的文件名后缀\",{\"1\":{\"17\":1}}],[\"是指使编译器包含\",{\"1\":{\"17\":1}}],[\"是由国人开发的基于\",{\"1\":{\"14\":1}}],[\"是按照字节来计算的\",{\"1\":{\"11\":1}}],[\"是\",{\"1\":{\"8\":1,\"11\":1}}],[\"是数字\",{\"1\":{\"2\":1}}],[\"是负数\",{\"1\":{\"2\":1}}],[\"是无法通过的\",{\"1\":{\"2\":1}}],[\"是用时间来换的\",{\"1\":{\"2\":1}}],[\"是这样的\",{\"1\":{\"2\":2}}],[\"读入的速度\",{\"1\":{\"2\":1}}],[\"读入同样多的数据量\",{\"1\":{\"2\":1}}],[\"读入数据的时候\",{\"1\":{\"2\":1}}],[\"读掉换行符的方式\",{\"1\":{\"2\":1}}],[\"应该\",{\"1\":{\"2\":1}}],[\"14\",{\"1\":{\"42\":1,\"43\":1}}],[\"14ll\",{\"1\":{\"20\":1}}],[\"114514\",{\"1\":{\"46\":1}}],[\"11\",{\"1\":{\"35\":1}}],[\"153ll\",{\"1\":{\"20\":3}}],[\"12ll\",{\"1\":{\"20\":2}}],[\"1e10\",{\"1\":{\"11\":1}}],[\"1亿\",{\"1\":{\"11\":5}}],[\"10005\",{\"1\":{\"32\":1,\"38\":1}}],[\"100000\",{\"1\":{\"23\":1,\"52\":2}}],[\"100005\",{\"1\":{\"23\":1}}],[\"10000\",{\"1\":{\"8\":3}}],[\"100ll+y\",{\"1\":{\"20\":1}}],[\"100ll\",{\"1\":{\"20\":2}}],[\"100∗1024∗1024\",{\"1\":{\"11\":1}}],[\"100\",{\"1\":{\"11\":1,\"23\":2}}],[\"1024\",{\"1\":{\"11\":4,\"20\":2}}],[\"10\",{\"1\":{\"2\":1,\"23\":1,\"32\":1}}],[\"1\",{\"0\":{\"20\":1,\"61\":1},\"1\":{\"2\":5,\"8\":9,\"11\":4,\"17\":1,\"20\":15,\"23\":23,\"26\":1,\"32\":6,\"35\":21,\"38\":23,\"42\":3,\"43\":1,\"49\":4,\"52\":1,\"58\":2}}],[\"的结构来解决这个问题\",{\"1\":{\"73\":1}}],[\"的变量类型是一样的\",{\"1\":{\"58\":1}}],[\"的地址\",{\"1\":{\"58\":1}}],[\"的地图\",{\"1\":{\"35\":1}}],[\"的指针变量\",{\"1\":{\"58\":1}}],[\"的指令\",{\"1\":{\"8\":1}}],[\"的符号位可能会让你很头疼\",{\"1\":{\"52\":1}}],[\"的字符数组\",{\"1\":{\"52\":1}}],[\"的全排列问题\",{\"1\":{\"35\":1}}],[\"的乘积等于十进制下的\",{\"1\":{\"32\":1}}],[\"的范围内\",{\"1\":{\"32\":2}}],[\"的值也会随之发生改变\",{\"1\":{\"58\":1}}],[\"的值将不可预测\",{\"1\":{\"43\":3}}],[\"的值成功的限制在了\",{\"1\":{\"32\":1}}],[\"的值的范围\",{\"1\":{\"8\":1}}],[\"的语句\",{\"1\":{\"29\":1}}],[\"的大致内容\",{\"1\":{\"23\":1}}],[\"的大部分同学都使用了\",{\"1\":{\"14\":1}}],[\"的内容\",{\"1\":{\"20\":1}}],[\"的内存空间\",{\"1\":{\"20\":1}}],[\"的内存空间是因为\",{\"1\":{\"20\":1}}],[\"的整数倍\",{\"1\":{\"20\":1}}],[\"的整型变量\",{\"1\":{\"17\":1}}],[\"的库\",{\"1\":{\"20\":1}}],[\"的ascii值\",{\"1\":{\"20\":1}}],[\"的数组\",{\"1\":{\"38\":1}}],[\"的数组和\",{\"1\":{\"38\":1}}],[\"的数字按某种顺序排好\",{\"1\":{\"35\":1}}],[\"的数字\",{\"1\":{\"20\":1}}],[\"的数据的随机数程序\",{\"1\":{\"8\":1}}],[\"的补码就是\",{\"1\":{\"20\":1}}],[\"的题目\",{\"1\":{\"20\":1}}],[\"的练习题单~\",{\"1\":{\"20\":1}}],[\"的时候要特别注意这点\",{\"1\":{\"82\":1}}],[\"的时候\",{\"1\":{\"17\":1,\"23\":1}}],[\"的时候发现利用\",{\"1\":{\"2\":1}}],[\"的具体意思\",{\"1\":{\"17\":1}}],[\"的其它课程成绩并不是很好\",{\"1\":{\"17\":1}}],[\"的安装路径\",{\"1\":{\"14\":1}}],[\"的文件夹\",{\"1\":{\"14\":1}}],[\"的新项目\",{\"1\":{\"14\":1}}],[\"的\",{\"1\":{\"14\":3,\"20\":1,\"23\":1,\"58\":1}}],[\"的循环次数\",{\"1\":{\"11\":1}}],[\"的最大可以到多少\",{\"1\":{\"11\":1}}],[\"的程序返回值\",{\"1\":{\"8\":1}}],[\"的随机整数值\",{\"1\":{\"8\":1}}],[\"的意思\",{\"1\":{\"2\":1}}],[\"的问题拆分成更小的同时又是方便解决的问题\",{\"1\":{\"38\":1}}],[\"的问题的了吗\",{\"1\":{\"2\":1}}],[\"的问题\",{\"1\":{\"2\":1}}],[\"来向编译器申请一段内存空间\",{\"1\":{\"58\":1}}],[\"来新建一个指向\",{\"1\":{\"58\":1}}],[\"来调用s数组的第i位了\",{\"1\":{\"52\":1}}],[\"来调用数组的某一位\",{\"1\":{\"52\":1}}],[\"来存放一些工具函数\",{\"1\":{\"42\":1}}],[\"来看一下展示具体做法的代码\",{\"1\":{\"35\":1}}],[\"来看下面一个例子\",{\"1\":{\"32\":1}}],[\"来告诉你们一个使用实例\",{\"1\":{\"32\":1}}],[\"来直接退出\",{\"1\":{\"32\":1}}],[\"来直接表示字符0代表的值\",{\"1\":{\"20\":1}}],[\"来提前结束主函数\",{\"1\":{\"32\":1}}],[\"来解释一下函数的结构\",{\"1\":{\"32\":1}}],[\"来简单提一下这两种循环\",{\"1\":{\"26\":1}}],[\"来获取\",{\"1\":{\"23\":1}}],[\"来连接多个判断\",{\"1\":{\"23\":1}}],[\"来作为判断条件\",{\"1\":{\"23\":1}}],[\"来对某个值进行分类\",{\"1\":{\"23\":1}}],[\"来表示\",{\"1\":{\"20\":1}}],[\"来表示星期二\",{\"1\":{\"20\":1}}],[\"来表示星期一\",{\"1\":{\"20\":1}}],[\"来表示换行\",{\"1\":{\"2\":2}}],[\"来充分利用这\",{\"1\":{\"20\":1}}],[\"来帮助大家理解当周的课程\",{\"1\":{\"17\":1}}],[\"来帮助我们打包项目\",{\"1\":{\"14\":1}}],[\"来帮助我们绕过这个\",{\"1\":{\"2\":1}}],[\"来帮你\",{\"1\":{\"17\":1}}],[\"来创建并编译一个新的sdl2项目吧\",{\"1\":{\"14\":1}}],[\"来优化整数的读入过程\",{\"1\":{\"2\":1}}],[\"来指定输入的格式\",{\"1\":{\"2\":1}}],[\"大小可以由你自己指定\",{\"1\":{\"58\":1}}],[\"大问题好像也就这么简简单单的解决了\",{\"1\":{\"38\":1}}],[\"大部分c语言老师实际上已经讲过递归了\",{\"1\":{\"38\":1}}],[\"大得多\",{\"1\":{\"20\":1}}],[\"大体格式如下\",{\"1\":{\"17\":1}}],[\"大家可以去算一算到底调用了多少次\",{\"1\":{\"38\":1}}],[\"大家可能会问\",{\"1\":{\"20\":1}}],[\"大家可能知道\",{\"1\":{\"20\":1}}],[\"大家可能在做\",{\"1\":{\"2\":1}}],[\"大家一定要多加练习\",{\"1\":{\"32\":1}}],[\"大家应该都会\",{\"1\":{\"32\":1}}],[\"大家好啊\",{\"1\":{\"32\":1}}],[\"大家需要用到的还是整型变量\",{\"1\":{\"20\":1}}],[\"大家都很熟\",{\"1\":{\"8\":1}}],[\"大大地提高了各位的做题体验\",{\"1\":{\"2\":1}}],[\"换行的\",{\"1\":{\"2\":1}}],[\"r是否在某一个进制下符合条件\",{\"1\":{\"32\":1}}],[\"run\",{\"1\":{\"14\":1}}],[\"rand\",{\"1\":{\"8\":6}}],[\"random\",{\"1\":{\"8\":4}}],[\"reference\",{\"1\":{\"58\":1}}],[\"resize\",{\"1\":{\"49\":1}}],[\"reserve\",{\"1\":{\"49\":4}}],[\"recursion\",{\"0\":{\"35\":1,\"38\":1},\"1\":{\"35\":1,\"38\":1}}],[\"reverse\",{\"1\":{\"32\":1}}],[\"return\",{\"1\":{\"8\":2,\"17\":2,\"20\":2,\"32\":4,\"35\":10,\"38\":4,\"42\":3,\"46\":1,\"49\":6}}],[\"readint\",{\"1\":{\"2\":2}}],[\"r\",{\"1\":{\"2\":1,\"8\":3,\"32\":7}}],[\"也能够媲美对象\",{\"1\":{\"42\":1}}],[\"也去听了课\",{\"1\":{\"38\":1}}],[\"也不能走\",{\"1\":{\"35\":1}}],[\"也不要忘了去算一算自己到底用掉了多少空间\",{\"1\":{\"20\":1}}],[\"也就只有把整段代码的逻辑重新过一遍才有可能解决了\",{\"1\":{\"35\":1}}],[\"也就是分别用一个\",{\"1\":{\"52\":1}}],[\"也就是使用数组下标那种方式快速访问其中的任意一个元素\",{\"1\":{\"46\":1}}],[\"也就是循环了\",{\"1\":{\"38\":1}}],[\"也就是确定进制那道题\",{\"1\":{\"32\":1}}],[\"也就是一个\",{\"1\":{\"32\":1}}],[\"也就是内存地址是\",{\"1\":{\"20\":1}}],[\"也就是\",{\"1\":{\"20\":2}}],[\"也就是把正数的二进制取反再加\",{\"1\":{\"20\":1}}],[\"也就是2的31次方减去1\",{\"1\":{\"20\":1}}],[\"也就是说这个音乐播放时需要保证文件一直能够访问到\",{\"1\":{\"82\":1}}],[\"也就是说你每次将序列分成两半\",{\"1\":{\"11\":1}}],[\"也就是说\",{\"1\":{\"2\":2,\"8\":1,\"11\":1,\"32\":1,\"58\":2}}],[\"也就是大家平时碰到的\",{\"1\":{\"2\":1}}],[\"也可能是字符\",{\"1\":{\"43\":1}}],[\"也可能是浮点数\",{\"1\":{\"43\":1}}],[\"也可能不知道\",{\"1\":{\"20\":1}}],[\"也可以使用\",{\"1\":{\"61\":1}}],[\"也可以用来填充图上的连通块\",{\"1\":{\"35\":1}}],[\"也可以不填\",{\"1\":{\"23\":1}}],[\"也可以直接给某个变量附上初值\",{\"1\":{\"23\":1}}],[\"也许也可以让你更有耐心地去debug\",{\"1\":{\"20\":1}}],[\"也有\",{\"1\":{\"20\":1}}],[\"也学到了基本的interger类型变量的定义\",{\"1\":{\"17\":1}}],[\"也会在题单的介绍中\",{\"1\":{\"17\":1}}],[\"也会在你的环境中探测使用它认为最合适的工具链\",{\"1\":{\"14\":1}}],[\"也太麻烦了吧\",{\"1\":{\"8\":1}}],[\"也即用\",{\"1\":{\"2\":1}}],[\"newcapacity\",{\"1\":{\"49\":2}}],[\"next\",{\"1\":{\"46\":1}}],[\"null\",{\"1\":{\"46\":5,\"49\":1,\"58\":2}}],[\"numa\",{\"1\":{\"20\":2}}],[\"num\",{\"1\":{\"20\":4}}],[\"ny\",{\"1\":{\"35\":4}}],[\"nx\",{\"1\":{\"35\":4}}],[\"node\",{\"1\":{\"46\":16}}],[\"now\",{\"1\":{\"35\":3}}],[\"not\",{\"1\":{\"8\":2,\"85\":1}}],[\"nlog2​n\",{\"1\":{\"11\":1}}],[\"n的数据范围是1到100000\",{\"1\":{\"11\":1}}],[\"n\",{\"1\":{\"2\":14,\"8\":1,\"11\":3,\"17\":1,\"20\":1,\"23\":6,\"26\":1,\"29\":5,\"32\":8,\"35\":21,\"38\":50,\"49\":11,\"52\":1,\"58\":3}}],[\"len\",{\"1\":{\"52\":2}}],[\"libsfml\",{\"1\":{\"61\":1}}],[\"library\",{\"1\":{\"61\":1}}],[\"list\",{\"1\":{\"46\":14}}],[\"linux\",{\"1\":{\"2\":2,\"8\":2,\"61\":1}}],[\"llu\",{\"1\":{\"20\":1}}],[\"lld\",{\"1\":{\"20\":5,\"38\":1}}],[\"luogu\",{\"1\":{\"17\":1,\"20\":1,\"23\":1,\"26\":1,\"29\":1,\"32\":1,\"35\":1,\"38\":1,\"43\":1,\"46\":1,\"49\":1,\"52\":1,\"55\":1,\"58\":1}}],[\"lua\",{\"1\":{\"14\":5}}],[\"load函数的实现\",{\"1\":{\"67\":1}}],[\"log2\",{\"1\":{\"38\":2}}],[\"log2​n\",{\"1\":{\"11\":1}}],[\"log\",{\"1\":{\"20\":1}}],[\"loops\",{\"1\":{\"29\":1}}],[\"loop\",{\"0\":{\"29\":1},\"1\":{\"8\":6}}],[\"long\",{\"1\":{\"8\":2,\"11\":2,\"20\":34,\"38\":4}}],[\"l\",{\"1\":{\"8\":4,\"32\":5}}],[\"lf\",{\"0\":{\"2\":1},\"1\":{\"2\":5,\"20\":1}}],[\"下次需要就直接拿出来用\",{\"1\":{\"38\":1}}],[\"下一个排列中用到的函数\",{\"1\":{\"32\":1}}],[\"下面\",{\"1\":{\"58\":1}}],[\"下面是归并排序的一个应用的讲解\",{\"1\":{\"38\":1}}],[\"下面来解决一个稍微难理解一点的\",{\"1\":{\"38\":1}}],[\"下面来举一个某\",{\"1\":{\"20\":1}}],[\"下面讲一点搜索的优化小技巧\",{\"1\":{\"35\":1}}],[\"下面就可以来开始打包项目了\",{\"1\":{\"14\":1}}],[\"下面就来大致的讲一讲罢\",{\"1\":{\"11\":1}}],[\"下建议使用\",{\"1\":{\"14\":1}}],[\"下实际上是一样的\",{\"1\":{\"8\":1}}],[\"下怎么写对拍了\",{\"1\":{\"8\":1}}],[\"下就不一样了\",{\"1\":{\"2\":1}}],[\"下的换行符是\",{\"1\":{\"2\":1}}],[\"下的换行符实际上并不一样\",{\"1\":{\"2\":1}}],[\"下的换行符和\",{\"1\":{\"2\":1}}],[\"下出题\",{\"1\":{\"2\":1}}],[\"平台下生成数据会有什么区别呢\",{\"1\":{\"2\":1}}],[\"平台的环境下自动生成数据\",{\"1\":{\"2\":1}}],[\"在之后销毁掉换成另一段\",{\"1\":{\"82\":1}}],[\"在之后的\",{\"1\":{\"49\":1}}],[\"在游戏每帧的更新过程中对所有不同类型的实体\",{\"1\":{\"76\":1}}],[\"在游戏中我们时常能见到某个实体围绕另一个实体做运动\",{\"1\":{\"73\":1}}],[\"在main函数中↓\",{\"1\":{\"58\":1}}],[\"在第二题当中\",{\"1\":{\"52\":1}}],[\"在上一次介绍中我们在文末说到了这样一段话\",{\"1\":{\"52\":1}}],[\"在数组的第\",{\"1\":{\"49\":1}}],[\"在数组尾部删除一个元素\",{\"1\":{\"49\":1}}],[\"在数组尾部添加一个元素\",{\"1\":{\"49\":1}}],[\"在数据都是非负整数的情况下甚至可以舍去这条判断\",{\"1\":{\"2\":1}}],[\"在pos指向的元素之后添加一个新的元素\",{\"1\":{\"46\":1}}],[\"在销毁时做一些清理工作\",{\"1\":{\"42\":1}}],[\"在创建结构体变量实例时\",{\"1\":{\"42\":1}}],[\"在具体使用的时候\",{\"1\":{\"42\":1}}],[\"在一个数列中\",{\"1\":{\"38\":1}}],[\"在递归的过程中\",{\"1\":{\"38\":1}}],[\"在其中我们可以看到\",{\"1\":{\"38\":1}}],[\"在其中可以直接定义一个变量\",{\"1\":{\"23\":1}}],[\"在与同学观看的时候发现了代码中的错误\",{\"1\":{\"35\":1}}],[\"在二维图上的路径搜索\",{\"1\":{\"35\":1}}],[\"在全排列这一代码的基础上稍加修改\",{\"1\":{\"35\":1}}],[\"在求解下一个子问题之前一定要把当前子问题对之后子问题求解造成的影响记下来\",{\"1\":{\"35\":1}}],[\"在每个递归的子问题当中\",{\"1\":{\"35\":1}}],[\"在每次循环结束并完成\",{\"1\":{\"23\":1}}],[\"在每次循环结束的时候\",{\"1\":{\"23\":1}}],[\"在函数的使用过程中\",{\"1\":{\"32\":1}}],[\"在函数中没有变量与之重名的情况下\",{\"1\":{\"32\":1}}],[\"在主函数中可以直接调用这个函数来实现这个操作\",{\"1\":{\"32\":1}}],[\"在你想用的时候\",{\"1\":{\"32\":1}}],[\"在高级语言中不建议使用\",{\"1\":{\"29\":1}}],[\"在运算过程中随时取模\",{\"1\":{\"26\":1}}],[\"在使用过后也指定销毁方法\",{\"1\":{\"42\":1}}],[\"在使用时\",{\"1\":{\"42\":1}}],[\"在使用\",{\"1\":{\"23\":1}}],[\"在使用之前\",{\"1\":{\"20\":1}}],[\"在答疑中发现有人尝试用字符存大于\",{\"1\":{\"20\":1}}],[\"在学完\",{\"1\":{\"17\":1}}],[\"在课程中\",{\"1\":{\"17\":1}}],[\"在这个平面上不同位置发出的声音\",{\"1\":{\"82\":1}}],[\"在这之后我们将造出一系列轮子\",{\"1\":{\"64\":1}}],[\"在这周的\",{\"1\":{\"32\":1}}],[\"在这周的课程中\",{\"1\":{\"17\":1}}],[\"在这一章中我们学会了\",{\"1\":{\"23\":1}}],[\"在这里特别需要注意的是\",{\"1\":{\"82\":1}}],[\"在这里需要注意的是\",{\"1\":{\"82\":1}}],[\"在这里某\",{\"1\":{\"41\":1}}],[\"在这里就不重复放这道题的具体解法了\",{\"1\":{\"35\":1}}],[\"在这里我们实际上还没有准备任何的音乐\",{\"1\":{\"82\":1}}],[\"在这里我们注意到几个问题\",{\"1\":{\"35\":1}}],[\"在这里我们以\",{\"1\":{\"14\":1}}],[\"在这里我们假定数据范围是\",{\"1\":{\"8\":1}}],[\"在这里提一嘴\",{\"1\":{\"8\":1}}],[\"在某\",{\"1\":{\"17\":1}}],[\"在此不多说\",{\"1\":{\"14\":1}}],[\"在命令行中运行以下命令来使用\",{\"1\":{\"14\":1}}],[\"在捣鬼\",{\"1\":{\"2\":1}}],[\"在\",{\"1\":{\"2\":1,\"11\":1,\"14\":1,\"20\":1,\"32\":2,\"49\":1}}],[\"某cqの奇妙冒险\",{\"1\":{\"55\":1}}],[\"某个子问题的求解不会被之后求解的另一个子问题所影响\",{\"1\":{\"35\":1}}],[\"某\",{\"0\":{\"55\":1},\"1\":{\"2\":1,\"8\":2,\"11\":2,\"17\":4,\"20\":2,\"23\":2,\"32\":3,\"35\":1,\"38\":8}}],[\"这本书为我们提供了非常合适的常量\",{\"1\":{\"82\":1}}],[\"这几样东西一摆\",{\"1\":{\"76\":1}}],[\"这只是第一步\",{\"1\":{\"64\":1}}],[\"这并不是很好看\",{\"1\":{\"64\":1}}],[\"这件事做起来很轻松\",{\"1\":{\"64\":1}}],[\"这还用配环境\",{\"1\":{\"61\":1}}],[\"这段空间来自堆空间\",{\"1\":{\"58\":1}}],[\"这两种函数是我们经常可能要用到的\",{\"1\":{\"58\":1}}],[\"这点要注意\",{\"1\":{\"58\":1}}],[\"这怎么能忍\",{\"1\":{\"52\":1}}],[\"这么好用\",{\"1\":{\"49\":1}}],[\"这么强大的工具\",{\"1\":{\"2\":1}}],[\"这时你又会重新看到原来的那个标题画面\",{\"1\":{\"79\":1}}],[\"这时\",{\"1\":{\"73\":1}}],[\"这时我们既要考虑主角的运动情况\",{\"1\":{\"73\":1}}],[\"这时我们称\",{\"1\":{\"38\":1}}],[\"这时候\",{\"1\":{\"29\":1,\"79\":1}}],[\"这之后我们将最底下的那一层移到终点柱子上\",{\"1\":{\"38\":1}}],[\"这三个变量的表示的柱子实际上会不断变化\",{\"1\":{\"38\":1}}],[\"这是好习惯\",{\"1\":{\"58\":1}}],[\"这是一种还算很常用的用来避免重复求解子问题的优化方法\",{\"1\":{\"38\":1}}],[\"这是对课程\",{\"1\":{\"5\":1}}],[\"这实际上并不在我们的关心范围内\",{\"1\":{\"38\":1}}],[\"这到底是什么意思呢\",{\"1\":{\"38\":1}}],[\"这到底是什么情况\",{\"1\":{\"2\":1}}],[\"这其实十分重要\",{\"1\":{\"35\":1}}],[\"这在一些题目里面\",{\"1\":{\"35\":1}}],[\"这在平时\",{\"1\":{\"2\":1}}],[\"这道题会被选在题单里面\",{\"1\":{\"35\":1}}],[\"这\",{\"1\":{\"35\":1}}],[\"这也意味着你的数组在新建时就受限于当前作用域\",{\"1\":{\"58\":1}}],[\"这也正导致了链表需要更多的内存用来记录与某一个节点相连的其他节点\",{\"1\":{\"46\":1}}],[\"这也正是某\",{\"1\":{\"32\":1}}],[\"这也是为什么\",{\"1\":{\"58\":1}}],[\"这也是一个优化的小技巧\",{\"1\":{\"32\":1}}],[\"这也是某\",{\"1\":{\"32\":1}}],[\"这也就直接决定了\",{\"1\":{\"20\":1}}],[\"这有什么用呢\",{\"1\":{\"32\":1}}],[\"这代码当然是个死循环\",{\"1\":{\"32\":1}}],[\"这章主要是要求我们通过函数将代码分块\",{\"1\":{\"32\":1}}],[\"这章主要是考察各位同学对变量类型的把控并使用变量类型及四则运算以及\",{\"1\":{\"20\":1}}],[\"这次还是没有题目做\",{\"1\":{\"49\":1}}],[\"这次依旧没有经过检查\",{\"1\":{\"49\":1}}],[\"这次我们介绍一个很方便但是在\",{\"1\":{\"49\":1}}],[\"这次我们将从全排列问题开始讲起\",{\"1\":{\"35\":1}}],[\"这次只有三道题\",{\"1\":{\"43\":1}}],[\"这次题目的难度可能浮动有点大\",{\"1\":{\"38\":1}}],[\"这次题目选炸了\",{\"1\":{\"38\":1}}],[\"这次题单里面更多的会出现二维数组的题目\",{\"1\":{\"29\":1}}],[\"这次的题单提前\",{\"1\":{\"38\":1}}],[\"这次的题单也许会出现之前题单中出现的题目\",{\"1\":{\"32\":1}}],[\"这次希望大家使用函数的方法来解决这些题目\",{\"1\":{\"32\":1}}],[\"这次是第一次准时推出的c\",{\"1\":{\"32\":1}}],[\"这很有可能是运算过程中产生的结果可能过大\",{\"1\":{\"26\":1}}],[\"这便是递归的原理\",{\"1\":{\"38\":1}}],[\"这便是最基本也是最常见的两种搜索\",{\"1\":{\"35\":1}}],[\"这便是\",{\"1\":{\"23\":1}}],[\"这可能会导致一些意料之外的结果\",{\"1\":{\"23\":1}}],[\"这可怎么办呢\",{\"1\":{\"8\":1}}],[\"这使得我们开始有能力处理大量的数据\",{\"1\":{\"23\":1}}],[\"这俩货其实根本没必要知道\",{\"1\":{\"20\":1}}],[\"这意味着换行符和空格也包括在内\",{\"1\":{\"20\":1}}],[\"这一步可以直接输出\",{\"1\":{\"38\":1}}],[\"这一步其实很容易\",{\"1\":{\"14\":1}}],[\"这一位上原本填的数字不要了\",{\"1\":{\"35\":1}}],[\"这一位具体能填哪些数字由前面已经填过的位置决定\",{\"1\":{\"35\":1}}],[\"这一章的内容实际上在题单\",{\"1\":{\"52\":1}}],[\"这一章的内容貌似确实就该这么多\",{\"1\":{\"17\":1}}],[\"这一章仍然在与上两章内容重复\",{\"1\":{\"29\":1}}],[\"这一章实际上和上一章并没有区别\",{\"1\":{\"26\":1}}],[\"这一\",{\"1\":{\"17\":1}}],[\"这一部分是需要同学们记住的\",{\"1\":{\"17\":1}}],[\"这些方法不会与实例进行交互\",{\"1\":{\"42\":1}}],[\"这些if条件之后的语句可以执行\",{\"1\":{\"23\":1}}],[\"这些\",{\"1\":{\"20\":1}}],[\"这些编辑器有\",{\"1\":{\"14\":1}}],[\"这些东西都在\",{\"1\":{\"8\":1}}],[\"这东西不要太简单\",{\"1\":{\"11\":1}}],[\"这就告诉你们\",{\"1\":{\"52\":1}}],[\"这就是第一题想考察的地方\",{\"1\":{\"52\":1}}],[\"这就是抽象为两层的汉诺塔问题的处理方法\",{\"1\":{\"38\":1}}],[\"这就是函数的用途所在\",{\"1\":{\"32\":1}}],[\"这就是归并排序在时间上的复杂度\",{\"1\":{\"11\":1}}],[\"这就过不去时间限制了\",{\"1\":{\"11\":1}}],[\"这你不超时谁超时\",{\"1\":{\"11\":1}}],[\"这个函数\",{\"1\":{\"58\":1}}],[\"这个函数和\",{\"1\":{\"58\":1}}],[\"这个函数就会直接结束\",{\"1\":{\"32\":1}}],[\"这个操作在某些问题中很常用\",{\"1\":{\"58\":1}}],[\"这个指针指向的变量\",{\"1\":{\"58\":1}}],[\"这个指针变量里面\",{\"1\":{\"58\":1}}],[\"这个动态数组还是很推荐学一学\",{\"1\":{\"49\":1}}],[\"这个就给个提示\",{\"1\":{\"38\":1}}],[\"这个就不给代码了\",{\"1\":{\"38\":1}}],[\"这个二元组为这个数列的一个逆序对\",{\"1\":{\"38\":1}}],[\"这个实际上比汉诺塔问题更加好理解\",{\"1\":{\"38\":1}}],[\"这个可太经典了\",{\"1\":{\"38\":1}}],[\"这个数字不用了\",{\"1\":{\"35\":1}}],[\"这个输出自己写\",{\"1\":{\"35\":1}}],[\"这个区间反转\",{\"1\":{\"32\":1}}],[\"这个非常的重要\",{\"1\":{\"32\":1}}],[\"这个不必说\",{\"1\":{\"32\":1}}],[\"这个是值得注意的\",{\"1\":{\"20\":1}}],[\"这个传奇的符号\",{\"1\":{\"17\":1}}],[\"这个很好理解啊\",{\"1\":{\"17\":1}}],[\"这个库来头可不小\",{\"1\":{\"17\":1}}],[\"这个变量的地址\",{\"1\":{\"58\":1}}],[\"这个变量\",{\"1\":{\"11\":1}}],[\"这个时候你需要检查你所有的while循环有没有出现恒为真的情况\",{\"1\":{\"11\":1}}],[\"这个时候你可以盯着题目给定的数据范围看\",{\"1\":{\"11\":1}}],[\"这个\",{\"1\":{\"8\":1,\"23\":1}}],[\"这样我们就也可以很轻松地借助相对位置得到绝对位置了\",{\"1\":{\"70\":1}}],[\"这样我们便通过将已经求解过的答案存到一个数组里来避免同一个子问题的重复求解\",{\"1\":{\"38\":1}}],[\"这样既能保证文件只被加载一次\",{\"1\":{\"67\":1}}],[\"这样如何\",{\"1\":{\"64\":1}}],[\"这样做的原理是什么呢\",{\"1\":{\"52\":1}}],[\"这样做在时间上并不合理\",{\"1\":{\"38\":1}}],[\"这样写就会很好改动\",{\"1\":{\"42\":1}}],[\"这样看上去麻烦\",{\"1\":{\"42\":1}}],[\"这样在存储时\",{\"1\":{\"43\":1}}],[\"这样在定义变量时\",{\"1\":{\"42\":1}}],[\"这样在读入的过程中就自然而然地略过了无关的字符\",{\"1\":{\"2\":1}}],[\"这样层层缩小\",{\"1\":{\"38\":1}}],[\"这样才能保证答案最短\",{\"1\":{\"35\":1}}],[\"这样可以更快地提高打字速度\",{\"1\":{\"20\":1}}],[\"这样\",{\"1\":{\"20\":2,\"38\":1}}],[\"这样就完成了对音乐和音效的播放的类的编写\",{\"1\":{\"82\":1}}],[\"这样就可以实现类似的方法功能了\",{\"1\":{\"42\":1}}],[\"这样就不会走上去了\",{\"1\":{\"35\":1}}],[\"这样就大致讲解了函数的使用方法\",{\"1\":{\"32\":1}}],[\"这样就造出了一个全自动的判别机\",{\"1\":{\"8\":1}}],[\"这样就写好了一个生成\",{\"1\":{\"8\":1}}],[\"这样种子就会在不断的变化\",{\"1\":{\"8\":1}}],[\"这里暂且不提\",{\"1\":{\"67\":1}}],[\"这里我们又要用到\",{\"1\":{\"58\":1}}],[\"这里演示的是两个方向都能查找的链表\",{\"1\":{\"46\":1}}],[\"这里为了方便\",{\"1\":{\"35\":2}}],[\"这里有一个小技巧就是如果是障碍物\",{\"1\":{\"35\":1}}],[\"这里到处都是重点\",{\"1\":{\"35\":1}}],[\"这里面的操作都会进行一次\",{\"1\":{\"23\":1}}],[\"这里是随便命名\",{\"1\":{\"20\":1}}],[\"这里是某\",{\"1\":{\"17\":1,\"20\":1,\"32\":1,\"38\":1}}],[\"这里需要输出一个变量\",{\"1\":{\"17\":1}}],[\"这里就不介绍\",{\"1\":{\"8\":1}}],[\"这里要注意的是\",{\"1\":{\"8\":1}}],[\"这里要特别注意\",{\"1\":{\"8\":1}}],[\"这里了\",{\"1\":{\"5\":1}}],[\"这里的\",{\"1\":{\"2\":1,\"58\":2}}],[\"这里假定你没有引用\",{\"1\":{\"2\":1}}],[\"这里举个例子可能会更清楚一点\",{\"1\":{\"2\":1}}],[\"样例在本地跑的是对的\",{\"1\":{\"2\":1}}],[\"shader的加载方式为\",{\"1\":{\"67\":1}}],[\"shift\",{\"1\":{\"14\":1}}],[\"sfml\",{\"0\":{\"61\":1,\"88\":1},\"1\":{\"61\":4,\"82\":1},\"2\":{\"62\":1,\"63\":1,\"65\":1,\"66\":1,\"68\":1,\"69\":1,\"71\":1,\"72\":1,\"74\":1,\"75\":1,\"77\":1,\"78\":1,\"80\":1,\"81\":1,\"83\":1,\"84\":1}}],[\"soundplayer\",{\"1\":{\"82\":1}}],[\"something\",{\"1\":{\"58\":1}}],[\"solve\",{\"1\":{\"20\":2}}],[\"sz\",{\"1\":{\"49\":3}}],[\"swap\",{\"1\":{\"42\":3,\"58\":2}}],[\"search\",{\"1\":{\"35\":1}}],[\"sqrt\",{\"1\":{\"20\":1}}],[\"sudo\",{\"1\":{\"61\":1}}],[\"sunday\",{\"1\":{\"20\":1}}],[\"sum\",{\"1\":{\"17\":1}}],[\"saturday\",{\"1\":{\"20\":1}}],[\"state\",{\"1\":{\"79\":2}}],[\"statestack\",{\"0\":{\"79\":1},\"1\":{\"79\":1}}],[\"standard\",{\"1\":{\"17\":1}}],[\"strlen\",{\"1\":{\"52\":1}}],[\"struct\",{\"0\":{\"42\":1},\"1\":{\"42\":13,\"43\":1,\"46\":2,\"49\":1}}],[\"step\",{\"1\":{\"35\":9}}],[\"stdbool\",{\"1\":{\"20\":1}}],[\"stdio\",{\"1\":{\"17\":2}}],[\"std\",{\"1\":{\"8\":4}}],[\"stdlib\",{\"1\":{\"8\":1}}],[\"src\",{\"1\":{\"14\":2}}],[\"srand\",{\"1\":{\"8\":2}}],[\"sdl\",{\"1\":{\"61\":2}}],[\"sdltest\",{\"1\":{\"14\":5}}],[\"sdl2\",{\"0\":{\"14\":1},\"1\":{\"14\":4}}],[\"simple\",{\"1\":{\"61\":1}}],[\"size\",{\"1\":{\"49\":9}}],[\"sizeof\",{\"1\":{\"11\":4,\"42\":1,\"46\":2,\"49\":2,\"52\":1,\"58\":3}}],[\"sign\",{\"1\":{\"2\":3}}],[\"scanf读入整数好慢好慢\",{\"1\":{\"2\":1}}],[\"scanf\",{\"1\":{\"2\":8,\"17\":3,\"20\":9,\"26\":1,\"29\":1,\"38\":1,\"49\":1,\"58\":1}}],[\"s\",{\"1\":{\"2\":2,\"52\":3}}],[\"cmakelists\",{\"1\":{\"61\":1}}],[\"clion\",{\"1\":{\"61\":1}}],[\"capacity\",{\"1\":{\"49\":5}}],[\"cycle\",{\"1\":{\"32\":6}}],[\"cbrt\",{\"1\":{\"20\":1}}],[\"c语言是认识这些东西的\",{\"1\":{\"20\":1}}],[\"cn\",{\"1\":{\"17\":1,\"20\":1,\"23\":1,\"26\":1,\"29\":1,\"32\":1,\"35\":1,\"38\":1,\"43\":1,\"46\":1,\"49\":1,\"52\":1,\"55\":1,\"58\":1}}],[\"ctrl\",{\"1\":{\"14\":1}}],[\"create\",{\"1\":{\"14\":1,\"42\":1}}],[\"crlf\",{\"0\":{\"2\":1},\"1\":{\"2\":6}}],[\"cocos2d\",{\"1\":{\"61\":1}}],[\"const\",{\"1\":{\"35\":4}}],[\"continue\",{\"1\":{\"23\":1,\"26\":1}}],[\"com\",{\"1\":{\"17\":1,\"20\":1,\"23\":1,\"26\":1,\"29\":1,\"32\":1,\"35\":1,\"38\":1,\"43\":1,\"46\":1,\"49\":1,\"52\":1,\"55\":1,\"58\":1}}],[\"compare\",{\"1\":{\"8\":1}}],[\"code\",{\"1\":{\"8\":4}}],[\"cpl\",{\"2\":{\"4\":1,\"7\":1,\"10\":1,\"13\":1,\"16\":1,\"18\":1,\"19\":1,\"21\":1,\"22\":1,\"24\":1,\"25\":1,\"27\":1,\"28\":1,\"30\":1,\"31\":1,\"33\":1,\"34\":1,\"36\":1,\"37\":1,\"39\":1,\"40\":1,\"44\":1,\"45\":1,\"47\":1,\"48\":1,\"50\":1,\"51\":1,\"53\":1,\"54\":1,\"56\":1,\"57\":1,\"59\":1,\"60\":1}}],[\"check\",{\"1\":{\"8\":1}}],[\"char\",{\"1\":{\"2\":1,\"11\":1,\"20\":7,\"38\":3,\"42\":2,\"43\":1,\"49\":1,\"52\":3}}],[\"challenge\",{\"1\":{\"2\":2}}],[\"ch\",{\"1\":{\"2\":10,\"20\":2}}],[\"c题的早期版本\",{\"1\":{\"2\":1}}],[\"c\",{\"0\":{\"86\":1,\"88\":1},\"1\":{\"2\":1,\"8\":1,\"11\":2,\"14\":4,\"17\":2,\"20\":5,\"23\":1,\"32\":2,\"38\":10,\"42\":2,\"49\":1,\"58\":3},\"2\":{\"3\":1,\"6\":1,\"9\":1,\"12\":1,\"15\":1}}],[\"c++stl\",{\"1\":{\"49\":1}}],[\"c++\",{\"1\":{\"2\":1,\"14\":5,\"42\":1,\"49\":1,\"61\":1},\"2\":{\"62\":1,\"63\":1,\"65\":1,\"66\":1,\"68\":1,\"69\":1,\"71\":1,\"72\":1,\"74\":1,\"75\":1,\"77\":1,\"78\":1,\"80\":1,\"81\":1,\"83\":1,\"84\":1}}],[\"cq\",{\"0\":{\"55\":1},\"1\":{\"2\":3,\"8\":4,\"11\":2,\"17\":7,\"20\":7,\"23\":2,\"26\":2,\"32\":6,\"35\":2,\"38\":10,\"41\":1}}],[\"和f\",{\"1\":{\"38\":1}}],[\"和超时爆空间说拜拜\",{\"0\":{\"11\":1}}],[\"和\",{\"0\":{\"2\":1},\"1\":{\"2\":2,\"8\":1,\"17\":1,\"20\":9,\"26\":1,\"32\":1,\"38\":2,\"43\":3,\"58\":2,\"79\":1}}],[\"主页\",{\"0\":{\"0\":1}}]],\"version\":2}}")).map(([e,t])=>[e,Mt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n,id:o}})=>{const r=St[s];e==="suggest"?self.postMessage([e,o,et(t,r,n)]):e==="search"?self.postMessage([e,o,tt(t,r,n)]):self.postMessage({suggestions:[e,o,et(t,r,n)],results:[e,o,tt(t,r,n)]})};
//# sourceMappingURL=index.js.map
