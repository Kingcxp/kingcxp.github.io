import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,b as p,o as e}from"./app-BGVLH4Lj.js";const t={};function c(o,n){return e(),a("div",null,n[0]||(n[0]=[p(`<h2 id="函数" tabindex="-1"><a class="header-anchor" href="#函数"><span>函数</span></a></h2><p>我们之前已经提过 <code>main</code> 函数了，对吧？那你应该已经理解了函数的基本结构了，我们这里再回顾一下。</p><p>函数是 <code>C</code> 语言中非常重要的一个概念，它允许我们将代码模块化，从而提高代码的可读性和可维护性。</p><p>函数的定义格式如下：</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c"><pre><code class="language-c"><span class="line">返回类型 函数名<span class="token punctuation">(</span>参数列表<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token comment">// 函数体</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中，返回类型是函数返回值的类型，函数名是函数的名称，参数列表是函数的参数，函数体是函数的具体实现。</p><div class="hint-container tip"><p class="hint-container-title">提示</p><p>和变量命名一样，函数名也建议使用 <code>snake_case</code> 命名法。</p></div><h2 id="函数的调用" tabindex="-1"><a class="header-anchor" href="#函数的调用"><span>函数的调用</span></a></h2><p>函数的调用格式如下：</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c"><pre><code class="language-c"><span class="line">函数名<span class="token punctuation">(</span>参数列表<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>其中，参数列表是函数的参数，可以是一个或多个。</p><p>例如，我们定义了一个函数 <code>add</code>，它接受两个整数作为参数，并返回它们的和：</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c"><pre><code class="language-c"><span class="line"><span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container warning"><p class="hint-container-title">注意</p><p>即使多个传入参数的类型是相同的，你也不能把它们写在一起！你必须挨个为它们指定名称</p><p>因为参数的位置顺序决定了调用时的顺序，所以参数的顺序非常重要。</p></div><p>我们可以通过以下方式调用这个函数：</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c"><pre><code class="language-c"><span class="line"><span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><div class="hint-container tip"><p class="hint-container-title">提示</p><p>函数也可以先声明，再在之后给出定义，而函数在声明后就可以被使用：</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c"><pre><code class="language-c"><span class="line"><span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 函数声明</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 函数调用</span></span>
<span class="line">  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 函数定义</span></span>
<span class="line">  <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></div><h2 id="递归" tabindex="-1"><a class="header-anchor" href="#递归"><span>递归</span></a></h2><p>既然函数在声明后就可以被调用，而在函数定义之前（<code>{}</code> 之前），函数的声明就已经完成了，那我们能在函数中调用它自己吗？</p><p>答案自然是可以的，而这种在自己的函数体求解过程中使用自己得出的结果的方法，就是递归。</p><p>听起来可能有一些绕，但我们可以通过一个简单的例子来理解它。</p><p>例如，我们需要计算斐波那契数列的第 <code>n</code> 项，假设我们定义了它的结果由函数 <code>f(n)</code> 得出</p><p>我们也知道，斐波那契数列的前两项是 <code>1</code>，后面的每一项都是前两项的和</p><p>因此，<code>f(n)</code> 应当等于 <code>f(n-1) + f(n-2)</code>，而 <code>f(1)</code> 和 <code>f(2)</code> 都等于 <code>1</code></p><p>所以，我们可以写出以下代码：</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c"><pre><code class="language-c"><span class="line"><span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">||</span> n <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line">  <span class="token keyword">return</span> <span class="token function">f</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">f</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container warning"><p class="hint-container-title">注意</p><p>对于递归的编写，需要注意两个关键点：</p><ol><li>递归的终止条件</li></ol><p>我们需要在递归的过程中设置一个终止条件，以防止递归无限进行下去。在上面的例子中，我们设置了 <code>n == 1 || n == 2</code> 作为终止条件。</p><ol start="2"><li>对于当前问题，如何拆分子问题</li></ol><p>我们需要找到一个方法，将当前问题拆分为更小的子问题，并在子问题的解中找到当前问题的解。在上面的例子中，我们将 <code>f(n)</code> 拆分为 <code>f(n-1)</code> 和 <code>f(n-2)</code>。</p></div><div class="hint-container tip"><p class="hint-container-title">提示</p><p>这里还有一个更难的例子：汉诺塔问题</p><p>我们先来找边界条件：</p><p>当起始柱子上只有一个盘子的时候，直接把它挪到终点柱子就好了。</p><p>然后我们来找盘子为 <code>n</code> 层时的处理方法：</p><p>实际上我们可以把 <code>n</code> 层抽象成两层：最底下的一层和上面 <code>n - 1</code> 层，以方便我们将 <code>n</code> 的问题拆分成更小的同时又能方便解决的问题。</p><p>然后考虑两层：我们得先把上面那个盘子移到中间柱子上面，再把下面一个盘子移到终点柱子上，最后把中间柱子上的那个盘子移到终点柱子上，完成汉诺塔的位移。</p><p>所以我们怎么具体构造这个递归呢？先给代码后解释：</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c"><pre><code class="language-c"><span class="line"><span class="token keyword">void</span> <span class="token function">hanoi</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">char</span> a<span class="token punctuation">,</span> <span class="token keyword">char</span> b<span class="token punctuation">,</span> <span class="token keyword">char</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%d:%c-&gt;%c&quot;</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> a<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line">  <span class="token keyword">else</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token function">hanoi</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> c<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%d:%c-&gt;%c&quot;</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> a<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token function">hanoi</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> b<span class="token punctuation">,</span> a<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>先解释一下这个函数中各个参数的含义， <code>n</code> 自然不用说，表示 <code>n</code> 层，但是如果你将 <code>a，b，c</code> 认作是一柱二柱三柱那格局就小了，它们应该被称作起始柱子，中间柱子和终点柱子。在递归的过程中，这三个变量的表示的柱子实际上会不断变化，因为你在一些步骤中终点柱并不是最开始的那个终点柱：比如说两层的时候，你第一步是要移到中间柱上，而不是终点柱上，中间柱才是你这一步的终点柱。</p><p>首先用 <code>if</code> 特判解决掉最小的问题，我们直接输出移动方式就行了。</p><p>然后关键的在下面，对于 <code>n</code> 层，我们先将 <code>n - 1</code> 层从起始柱子通过终点柱子的帮助移到中间柱子去，这之后我们将最底下的那一层移到终点柱子上，这一步可以直接输出，最后我们将这 <code>n - 1</code> 层从中间柱子通过起点柱子的帮助，移到终点柱子上，这就是抽象为两层的汉诺塔问题的处理方法。</p><p>通过这样的处理，我们将 <code>n</code> 层的问题，转化成了一次移动和两次 <code>n - 1</code> 层的问题，这样层层缩小，最终变成一层的可以直接解决的问题。</p><p>实际上递归就是一种量变引起质变的方式，通过不断地解决小问题，总有一天你会发现，欸，大问题好像也就这么简简单单的解决了。</p></div><h3 id="搜搜你的" tabindex="-1"><a class="header-anchor" href="#搜搜你的"><span>搜搜你的</span></a></h3><blockquote><p>听说过二维迷宫吗？就那种一个方格里到处都是 0 和 1 的那种？</p></blockquote><p>现在有一个二维迷宫，你需要从起点 <code>(1, 1)</code> 出发，找到一条路径，使得你能够到达终点 <code>(n, m)</code>，其中 <code>n</code> 和 <code>m</code> 是迷宫的大小。</p><p>你只能向右或向下移动，不能向上或向左移动。</p><p>请你编写一个程序，输出一条路径，使得你能够到达终点。</p><p>如果没有路径，则输出 <code>No Solution</code>。</p><p>输入格式：</p><p>第一行包含两个整数 <code>n</code> 和 <code>m</code>，表示迷宫的大小。</p><p>接下来 <code>n</code> 行，每行包含 <code>m</code> 个整数，表示迷宫的布局。</p><p>输出格式：</p><p>一行一个整数，表示需要走多少步到达终点</p><p>如果没有路径，则输出 <code>-1</code>。</p><p>输入样例：</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">3 3</span>
<span class="line">0 1 0</span>
<span class="line">0 0 0</span>
<span class="line">0 1 0</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出样例：</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">4</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这道题该怎么解决呢？完全没办法啊？</p><p>实际上，它也可以用递归解决，要得到从起点到终点的路径，那我只需要知道终点可以从哪些地方到达就可以咯？</p><p>那终点可以从哪里来呢？从终点左边一格或者从终点上边一格来，那这两格又从哪里来呢？显然是从它们左边一格或者上边一格来，以此类推，直到起点。</p><p>我们也可以从起点反过来推，从起点开始，选择方向一路走到撞墙，如果某一步所有方向都走不通，就回到上一步，再选择一个方向走，直到走到终点。</p><p>同时，由于走到终点可能不止有一条路径，因此我们需要找到其中步数最短的那条路径</p><p>于是很轻松地就能写出以下代码：</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c"><pre><code class="language-c"><span class="line"><span class="token comment">// 如果是常量数组，可以不指定大小，编译器会自动计算大小</span></span>
<span class="line"><span class="token keyword">const</span> <span class="token keyword">int</span> dx<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">const</span> <span class="token keyword">int</span> dy<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">int</span> best_steps <span class="token operator">=</span> <span class="token number">2147483647</span><span class="token punctuation">;</span> <span class="token comment">// 最大的 int 值，因为此时还没有找到路径</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">,</span> <span class="token keyword">int</span> steps<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token comment">// 边界条件：超出范围或者是已经走过</span></span>
<span class="line">  <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> y <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> x <span class="token operator">&gt;</span> n <span class="token operator">||</span> y <span class="token operator">&gt;</span> m <span class="token operator">||</span> vis<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">return</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line">  <span class="token comment">// 如果到达终点，输出结果</span></span>
<span class="line">  <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> n <span class="token operator">&amp;&amp;</span> y <span class="token operator">==</span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    best_steps <span class="token operator">=</span> steps <span class="token operator">&gt;</span> best_steps <span class="token operator">?</span> best_steps <span class="token operator">:</span> steps<span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">return</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">  <span class="token comment">// 向四个方向搜索</span></span>
<span class="line">  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">4</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// 将当前点标记为走过</span></span>
<span class="line">    vis<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token function">dfs</span><span class="token punctuation">(</span>x <span class="token operator">+</span> dx<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> y <span class="token operator">+</span> dy<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> steps <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token comment">// 还原现场，走不通，无事发生，继续尝试其他方向</span></span>
<span class="line">    vis<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token comment">// 输入迷宫大小</span></span>
<span class="line">  <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">&quot;%d%d&quot;</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">,</span> <span class="token operator">&amp;</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token comment">// 输入迷宫</span></span>
<span class="line">  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">      <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">&quot;%d&quot;</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>maze<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line">  <span class="token comment">// 从起点开始搜索</span></span>
<span class="line">  <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token comment">// 输出结果</span></span>
<span class="line">  <span class="token keyword">if</span> <span class="token punctuation">(</span>best_steps <span class="token operator">==</span> <span class="token number">2147483647</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;-1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%d&quot;</span><span class="token punctuation">,</span> best_steps<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line">  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>很简单吧？但是想想这样找要找多久……</p><p>你会发现，这个代码的时间复杂度是指数级的，因为每一步都有四个方向可以选择，所以大概会有 <code>4^n</code> 种可能的情况。</p><p>而计算机在 <code>1</code> 秒之内最多只能执行 <code>10^8</code> 次运算，所以这个代码最多只能处理 <code>n</code> 小于等于 <code>8</code> 的情况。而 <code>n</code> 在这道题的数据范围可以达到 <code>100</code>，这显然是不合适的</p><p>因此，我们需要找到削减搜索空间的方法，来降低时间复杂度。</p><p>我们先给出答案，再来理解：</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c"><pre><code class="language-c"><span class="line"><span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">,</span> <span class="token keyword">int</span> steps<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token comment">// 边界条件：超出范围或者是已经走过</span></span>
<span class="line">  <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> y <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> x <span class="token operator">&gt;</span> n <span class="token operator">||</span> y <span class="token operator">&gt;</span> m <span class="token operator">||</span> vis<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">return</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">  <span class="token comment">// ①</span></span>
<span class="line">  <span class="token keyword">if</span> <span class="token punctuation">(</span>steps <span class="token operator">&gt;</span> best_steps<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">return</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">  <span class="token comment">// ②</span></span>
<span class="line">  <span class="token keyword">if</span> <span class="token punctuation">(</span>ans <span class="token operator">==</span> n <span class="token operator">+</span> m <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">return</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">  <span class="token comment">// 如果到达终点，输出结果</span></span>
<span class="line">  <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> n <span class="token operator">&amp;&amp;</span> y <span class="token operator">==</span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    best_steps <span class="token operator">=</span> steps <span class="token operator">&gt;</span> best_steps <span class="token operator">?</span> best_steps <span class="token operator">:</span> steps<span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">return</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">  <span class="token comment">// 向四个方向搜索</span></span>
<span class="line">  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">4</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// 将当前点标记为走过</span></span>
<span class="line">    vis<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token function">dfs</span><span class="token punctuation">(</span>x <span class="token operator">+</span> dx<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> y <span class="token operator">+</span> dy<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> steps <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token comment">// 还原现场，走不通，无事发生，继续尝试其他方向</span></span>
<span class="line">    vis<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们添加了两个判断条件，分别是 <code>①</code> 和 <code>②</code>。</p><p><code>①</code> 的作用是，如果当前已经走过的步数已经超过了之前找到的最短路径，那么就没有必要继续搜索了，因为无论如何，我们也不可能找到更短的路径。</p><p><code>②</code> 的作用是，如果当前已经走过的步数已经超过了从起点到终点的最短路径，那么就没有必要继续搜索了，因为无论如何，我们也不可能找到一条路径。</p><p>这两个判断条件可以大大削减搜索空间，从而降低时间复杂度。</p><div class="hint-container tip"><p class="hint-container-title">提示</p><p>另外，调转搜索方向的顺序也能削减搜索空间，因为理论上向右和向下走更多的路径更容易最短，所以可以优先搜索向右和向下走的情况，这样能更快地找到最短路径。</p></div><div class="hint-container warning"><p class="hint-container-title">注意</p><p>递归是一种非常强大的算法思想，它可以用来解决很多复杂的问题，但是需要注意递归的边界条件和时间开销。</p></div><h2 id="递推" tabindex="-1"><a class="header-anchor" href="#递推"><span>递推</span></a></h2><p>递归是将大问题拆分为小问题，而递推是将小问题合并为大问题，实际上就是递归的反向</p><p>相对于递归的抽象，递推更加具体，反而更好理解，它是一种通过迭代的方式，逐步求解问题的方法，是一种正向的过程。</p><p>例如，我们要求解斐波那契数列的第 <code>1 ~ n</code> 项，我们可以从 <code>f(1)</code> 和 <code>f(2)</code> 开始，逐步计算 <code>f(3)</code>、<code>f(4)</code>、<code>f(5)</code> 等等，直到 <code>f(n)</code>。</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c"><pre><code class="language-c"><span class="line"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">int</span> n<span class="token punctuation">;</span></span>
<span class="line">  <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">&quot;%d&quot;</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token keyword">int</span> f<span class="token punctuation">[</span><span class="token number">1005</span><span class="token punctuation">]</span><span class="token punctuation">;</span></span>
<span class="line">  f<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> f<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    f<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line">  <span class="token comment">// ...</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container tip"><p class="hint-container-title">提示</p><p>递推和递归是两种不同的算法思想，它们各有优缺点，具体使用哪种方法，需要根据问题的性质和需求来决定。</p><p>一般来说，递归在处理一些具有递归性质的问题时，如树、图等，会显得更加简洁和直观，而递推在处理一些具有迭代性质的问题时，如数列、动态规划等，会显得更加高效和直接。</p><p>树和图看不明白是什么意思的话，在学完语言开始将算法之后会详细讲解。</p></div><h2 id="试一试" tabindex="-1"><a class="header-anchor" href="#试一试"><span>试一试！</span></a></h2><p><a href="https://www.luogu.com.cn/training/243762#problems" target="_blank" rel="noopener noreferrer">DotOJ 补完计划 - 南哪 2022-5-function</a><br><a href="https://www.luogu.com.cn/training/245059#problems" target="_blank" rel="noopener noreferrer">DotOJ 补完计划 - 南哪 2022-6-recursion</a><br><a href="https://www.luogu.com.cn/training/249748#problems" target="_blank" rel="noopener noreferrer">DotOJ 补完计划 - 南哪 2022-6-recursion EX</a></p>`,71)]))}const u=s(t,[["render",c]]),r=JSON.parse(`{"path":"/posts/CPL-Remake/4.html","title":"4. 函数、递归和递推","lang":"zh-CN","frontmatter":{"title":"4. 函数、递归和递推","date":"2025-07-28T00:00:00.000Z","icon":"compress","order":5,"category":["CPL"],"tag":["C Programming Language"],"author":"Kingcq","description":"函数 我们之前已经提过 main 函数了，对吧？那你应该已经理解了函数的基本结构了，我们这里再回顾一下。 函数是 C 语言中非常重要的一个概念，它允许我们将代码模块化，从而提高代码的可读性和可维护性。 函数的定义格式如下： 其中，返回类型是函数返回值的类型，函数名是函数的名称，参数列表是函数的参数，函数体是函数的具体实现。 提示 和变量命名一样，函数名...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"4. 函数、递归和递推\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-07-28T00:00:00.000Z\\",\\"dateModified\\":\\"2025-07-29T05:20:31.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Kingcq\\"}]}"],["meta",{"property":"og:url","content":"https://kingcxp.github.io/posts/CPL-Remake/4.html"}],["meta",{"property":"og:site_name","content":"Kingcq's Blog"}],["meta",{"property":"og:title","content":"4. 函数、递归和递推"}],["meta",{"property":"og:description","content":"函数 我们之前已经提过 main 函数了，对吧？那你应该已经理解了函数的基本结构了，我们这里再回顾一下。 函数是 C 语言中非常重要的一个概念，它允许我们将代码模块化，从而提高代码的可读性和可维护性。 函数的定义格式如下： 其中，返回类型是函数返回值的类型，函数名是函数的名称，参数列表是函数的参数，函数体是函数的具体实现。 提示 和变量命名一样，函数名..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-07-29T05:20:31.000Z"}],["meta",{"property":"article:author","content":"Kingcq"}],["meta",{"property":"article:tag","content":"C Programming Language"}],["meta",{"property":"article:published_time","content":"2025-07-28T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-07-29T05:20:31.000Z"}]]},"git":{"createdTime":1753766173000,"updatedTime":1753766431000,"contributors":[{"name":"Kingcq","username":"Kingcq","email":"404291187@qq.com","commits":2,"url":"https://github.com/Kingcq"}]},"readingTime":{"minutes":10.48,"words":3145},"filePathRelative":"posts/CPL-Remake/4.md","excerpt":"<h2>函数</h2>\\n<p>我们之前已经提过 <code>main</code> 函数了，对吧？那你应该已经理解了函数的基本结构了，我们这里再回顾一下。</p>\\n<p>函数是 <code>C</code> 语言中非常重要的一个概念，它允许我们将代码模块化，从而提高代码的可读性和可维护性。</p>\\n<p>函数的定义格式如下：</p>\\n<div class=\\"language-c line-numbers-mode\\" data-highlighter=\\"prismjs\\" data-ext=\\"c\\"><pre><code class=\\"language-c\\"><span class=\\"line\\">返回类型 函数名<span class=\\"token punctuation\\">(</span>参数列表<span class=\\"token punctuation\\">)</span> <span class=\\"token punctuation\\">{</span></span>\\n<span class=\\"line\\">  <span class=\\"token comment\\">// 函数体</span></span>\\n<span class=\\"line\\"><span class=\\"token punctuation\\">}</span></span>\\n<span class=\\"line\\"></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>","autoDesc":true}`);export{u as comp,r as data};
