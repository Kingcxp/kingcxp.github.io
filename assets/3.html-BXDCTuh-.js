import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,b as o,o as a}from"./app-B6yu4Jx0.js";const p="/assets/3-1-B6ziC3Lh.jpg",r="/assets/3-2-gEIuIK2c.jpg",n="/assets/3-3-CupqvfEj.jpg",c="/assets/3-4-DDIUY9un.jpg",g={};function s(l,t){return a(),i("div",null,t[0]||(t[0]=[o('<p>把文件一个一个声明并且读入固然十分有效，但是太麻烦了，根本不好用。</p><p>所以为什么我们不自己写一个类，让他来控制所有文件的存取呢？我们可以给每一个加载的内容都带上一个特殊的id，想要的时候再通过id把它取出来，这样既能保证文件只被加载一次，同时也能让存取的步骤更加的简单：</p><figure><img src="'+p+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>load函数的实现：</p><figure><img src="'+r+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>get函数的实现：</p><figure><img src="'+n+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>为什么要准备两种load：</p><p>用于视觉特效的sf::Shader的加载方式为：</p><figure><img src="'+c+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>可以看到它在加载的过程中需要不止一个参数，所以再准备一个load以备不时之需。</p><p>不支持的类型？：<br> 由于sf::Music打开方式的特殊性（这里暂且不提），它的加载函数为openFromFile(path)而不是loadFromFile(path)。所以无法在这里加载，不过我们也并不会在ResourceHolder里面加载这种文件，我们显然需要一个单独的东西来处理游戏音乐和音效的。</p>',12)]))}const f=e(g,[["render",s],["__file","3.html.vue"]]),u=JSON.parse(`{"path":"/posts/C__-SFML-%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/3.html","title":"3. 更轻松地存取文件，并尽可能阻止内存泄露","lang":"zh-CN","frontmatter":{"title":"3. 更轻松地存取文件，并尽可能阻止内存泄露","date":"2024-03-11T00:00:00.000Z","icon":"file-circle-check","order":3,"category":["C++ SFML"],"tag":["C++","SFML"],"author":"Kingcq","description":"把文件一个一个声明并且读入固然十分有效，但是太麻烦了，根本不好用。 所以为什么我们不自己写一个类，让他来控制所有文件的存取呢？我们可以给每一个加载的内容都带上一个特殊的id，想要的时候再通过id把它取出来，这样既能保证文件只被加载一次，同时也能让存取的步骤更加的简单： load函数的实现： get函数的实现： 为什么要准备两种load： 用于视觉特效的...","head":[["meta",{"property":"og:url","content":"https://kingcxp.github.io/posts/C__-SFML-%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/3.html"}],["meta",{"property":"og:site_name","content":"Kingcq's Blog"}],["meta",{"property":"og:title","content":"3. 更轻松地存取文件，并尽可能阻止内存泄露"}],["meta",{"property":"og:description","content":"把文件一个一个声明并且读入固然十分有效，但是太麻烦了，根本不好用。 所以为什么我们不自己写一个类，让他来控制所有文件的存取呢？我们可以给每一个加载的内容都带上一个特殊的id，想要的时候再通过id把它取出来，这样既能保证文件只被加载一次，同时也能让存取的步骤更加的简单： load函数的实现： get函数的实现： 为什么要准备两种load： 用于视觉特效的..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-02-05T07:41:30.000Z"}],["meta",{"property":"article:author","content":"Kingcq"}],["meta",{"property":"article:tag","content":"C++"}],["meta",{"property":"article:tag","content":"SFML"}],["meta",{"property":"article:published_time","content":"2024-03-11T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-02-05T07:41:30.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"3. 更轻松地存取文件，并尽可能阻止内存泄露\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-03-11T00:00:00.000Z\\",\\"dateModified\\":\\"2025-02-05T07:41:30.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Kingcq\\"}]}"]]},"headers":[],"git":{"createdTime":1738740544000,"updatedTime":1738741290000,"contributors":[{"name":"Kingcq","username":"Kingcq","email":"404291187@qq.com","commits":2,"url":"https://github.com/Kingcq"}]},"readingTime":{"minutes":1.09,"words":327},"filePathRelative":"posts/C++-SFML-游戏开发/3.md","localizedDate":"2024年3月11日","excerpt":"<p>把文件一个一个声明并且读入固然十分有效，但是太麻烦了，根本不好用。</p>\\n<p>所以为什么我们不自己写一个类，让他来控制所有文件的存取呢？我们可以给每一个加载的内容都带上一个特殊的id，想要的时候再通过id把它取出来，这样既能保证文件只被加载一次，同时也能让存取的步骤更加的简单：</p>\\n<figure><figcaption></figcaption></figure>\\n<p>load函数的实现：</p>\\n<figure><figcaption></figcaption></figure>\\n<p>get函数的实现：</p>\\n<figure><figcaption></figcaption></figure>","autoDesc":true}`);export{f as comp,u as data};
